<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>muduo_part2 | Welcome</title><meta name="author" content="John Doe"><meta name="copyright" content="John Doe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="C++编译链接模型C++20才有模块机制，可以直接使用其他文件提供的接口。之前都是只能通过引入头文件来使用的，缺点很多：  一方面效率很低 一方面可能出现冲突（比如写QT时，slot被覆盖了，需要更换两个头文件的顺序才行）， 一方面很带可能来隐患，头文件时编译时使用的，库文件时运行时使用的，如果两者的版本不一致会导致很多问题。   c的出现受制于当时的硬件条件，单遍编译、先定义再使用、局部变量必须">
<meta property="og:type" content="article">
<meta property="og:title" content="muduo_part2">
<meta property="og:url" content="https://tjzhang-src.github.io/.github.io/2025/08/02/muduo-part2/index.html">
<meta property="og:site_name" content="Welcome">
<meta property="og:description" content="C++编译链接模型C++20才有模块机制，可以直接使用其他文件提供的接口。之前都是只能通过引入头文件来使用的，缺点很多：  一方面效率很低 一方面可能出现冲突（比如写QT时，slot被覆盖了，需要更换两个头文件的顺序才行）， 一方面很带可能来隐患，头文件时编译时使用的，库文件时运行时使用的，如果两者的版本不一致会导致很多问题。   c的出现受制于当时的硬件条件，单遍编译、先定义再使用、局部变量必须">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2025-08-02T07:25:23.000Z">
<meta property="article:modified_time" content="2025-08-02T07:26:22.025Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="c++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/.github.io/img/favicon.png"><link rel="canonical" href="https://tjzhang-src.github.io/.github.io/2025/08/02/muduo-part2/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//hm.baidu.com"/><link rel="stylesheet" href="/.github.io/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?4cc6526274b17acfe67a4be7d70e8d1c";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-FF1BJEGK51"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-FF1BJEGK51');
</script><script>const GLOBAL_CONFIG = { 
  root: '/.github.io/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'muduo_part2',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-08-02 15:26:22'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (false) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/.github.io/archives/"><div class="headline">文章</div><div class="length-num">46</div></a><a href="/.github.io/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/.github.io/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/.github.io/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/.github.io/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/.github.io/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/.github.io/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/.github.io/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/.github.io/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/.github.io/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/.github.io/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s2.loli.net/2023/02/26/9fQnztK2ImqyLwS.webp')"><nav id="nav"><span id="blog-info"><a href="/.github.io/" title="Welcome"><span class="site-name">Welcome</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/.github.io/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/.github.io/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/.github.io/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/.github.io/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/.github.io/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/.github.io/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/.github.io/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/.github.io/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">muduo_part2</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-08-02T07:25:23.000Z" title="发表于 2025-08-02 15:25:23">2025-08-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-08-02T07:26:22.025Z" title="更新于 2025-08-02 15:26:22">2025-08-02</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>19分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="muduo_part2"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="C-编译链接模型"><a href="#C-编译链接模型" class="headerlink" title="C++编译链接模型"></a>C++编译链接模型</h3><p>C++20才有模块机制，可以直接使用其他文件提供的接口。之前都是只能通过引入头文件来使用的，缺点很多：</p>
<ul>
<li>一方面效率很低</li>
<li>一方面可能出现冲突（比如写QT时，slot被覆盖了，需要更换两个头文件的顺序才行），</li>
<li>一方面很带可能来<strong>隐患</strong>，头文件时编译时使用的，库文件时运行时使用的，如果两者的版本不一致会导致很多问题。</li>
</ul>
<blockquote>
<p>c的出现受制于当时的硬件条件，单遍编译、先定义再使用、局部变量必须在开头定义、对于外部变量只需要指导类型和名字，不需要知道地址，这些都是为了在低资源硬件环境下编译c程序做的规定，由于cpp想要兼容c，导致他也接受了这些糟粕。</p>
</blockquote>
<p><strong>关于为什么c会分为头文件和源文件</strong>，其实即使是现代的C编译器，头文件也不是必须的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//cat alpha.c;cat beta.c</span><br><span class="line">int main() &#123;</span><br><span class="line">    print_hello();</span><br><span class="line">&#125;</span><br><span class="line">void print_hello() &#123;</span><br><span class="line">    puts(&quot;hello&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//gcc alpha.c beta.c -o app;</span><br><span class="line">//./app</span><br><span class="line">hello</span><br></pre></td></tr></table></figure>

<p>对于<strong>C语言</strong>而言，遇到未知符号，则将其作为外部符号等待链接就行了。</p>
<ul>
<li>这种写法基本上能work，是因为当时的数据类型比较简单，就只有int。</li>
<li>而且这么做可以很方便的<strong>将从不同语言编译到的目标文件链接到一起。</strong>（gcc在编译期间就已经丢弃了类的元数据）</li>
</ul>
<p>随着结构体的引入，问题变得更加复杂，函数调用需要提前声明，这就是头文件出现的缘由。有个问题是为什么不能直接去查找对应的源文件呢，因为<code>C</code>假设对方可能不是<code>C</code>编写的代码（比如可能是<code>Fortran</code>、汇编），所以每个源文件都只包含最基本的机器代码（没必要包含类的元数据）。所以为了访问C语言编写的其他函数或者其他语言（比如<strong>汇编</strong>）编写的其他函数，都需要为其创建一个匹配的头文件，然后供需要的源文件使用。</p>
<blockquote>
<p>虽然<code>C</code>编译可以直接产生目标文件，从而很方便的与其他语言链接，不过常用的语言貌似就只有汇编。如果能和其他功能更强大的语言链接，可能C还会更常用。可以“直接产生目标文件”的这个特点也带来了很大的缺点，比如目标文件不包含元数据，导致C&#x2F;C++很难实现一些java中的特性，反射啥的。</p>
</blockquote>
<h4 id="C-的编译模型"><a href="#C-的编译模型" class="headerlink" title="C++的编译模型"></a>C++的编译模型</h4><h5 id="单遍编译"><a href="#单遍编译" class="headerlink" title="单遍编译"></a>单遍编译</h5><p>编译器只能根据当前看到的代码做决策。这特别影响了名字查找（name lookup）和函数重载决议。</p>
<h6 id="名字查找："><a href="#名字查找：" class="headerlink" title="名字查找："></a><strong>名字查找：</strong></h6><p>C++中的名字包括类型名、函数名、变量名、typdef名、template名，比如<code>Foo&lt;T&gt; a;</code>如果不知道这三个名字是什么，那么可以有很多种<strong>合理的解释</strong>：</p>
<ul>
<li>Foo是个<code>template&lt;typename X&gt; class Foo;</code>，T是<strong>类型参数</strong>。</li>
<li>Foo是个<code>template&lt;int X&gt; class Foo;</code>， T是一个非类型参数。</li>
<li>Foo，T，a都是int变量，这里只是对三者比较大小。</li>
<li>而且<code>&lt;</code>还有可能被重载</li>
</ul>
<p>还有一个经典的例子，AA BB()是声明函数，而非定义变量。一个更有迷惑性的是<code>MyClass obj(MyClass())</code>,他是声明一个函数obj，他接收一个函数作为参数，这个函数返回MyClass类型的对象，不接受参数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;MyClass constructor\n&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">say</span><span class="params">()</span> <span class="type">const</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Hello\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 这行到底是函数声明还是对象定义？</span></span><br><span class="line"><span class="function">MyClass <span class="title">obj</span><span class="params">(MyClass())</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    obj.<span class="built_in">say</span>();  <span class="comment">// ❌ 如果是函数声明，这里编译会报错</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">####################[测试]####################</span><br><span class="line">MyClass.cpp:<span class="number">12</span>:<span class="number">9</span>: error: request <span class="keyword">for</span> member ‘say’ in ‘obj’, which is of non-<span class="keyword">class</span> <span class="title class_">type</span> ‘<span class="built_in">MyClass</span>(<span class="built_in">MyClass</span> (*)())’</span><br><span class="line">   <span class="number">12</span> |     obj.<span class="built_in">say</span>();  <span class="comment">// ❌ 如果是函数声明，这里编译会报错</span></span><br><span class="line">      |         ^~~</span><br></pre></td></tr></table></figure>

<p>由此可见，cpp理解名字有着很大的误差。主要原因是因为cpp只能根据解析源码来了解名字的含义，需要将文件从头到问解析一遍。而其它语言可能通过直接读取目标代码的元数据来获取所需信息。（比如java会将元数据编译进.class文件，运行时的反射机制也是通过这种元数据实现的；cpp不会保留每个class的元数据，也没法实现反射）</p>
<p>为此作者提出使用 <code>-Wshadow</code>选项来对同名变量的遮挡情况发出警告。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-Wall：启用所有常见警告。</span><br><span class="line">-Wextra：启用更多额外的警告。</span><br><span class="line">-Werror：将所有警告视为错误。</span><br><span class="line">-Wconversion：警告隐式类型转换，这可能会改变值。</span><br><span class="line">-Wshadow：警告变量遮蔽（即在内层作用域声明一个与外层作用域同名的变量）。</span><br></pre></td></tr></table></figure>

<h6 id="函数重载决议"><a href="#函数重载决议" class="headerlink" title="函数重载决议"></a>函数重载决议</h6><p>当编译器读到一个函数调用语句时，他只能从<strong>当前已经看到的同名</strong>函数中选择最佳函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void foo(int)&#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;foo(int)&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void foo(char)&#123;</span><br><span class="line">        cout &lt;&lt; &quot;foo(char)&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bar()&#123;</span><br><span class="line">        foo(&#x27;a&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">void foo(char)&#123;</span><br><span class="line">        cout &lt;&lt; &quot;foo(char)&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line">int main()&#123;</span><br><span class="line">        bar();</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br><span class="line">####这里交换顺序后，结果是不同的</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其实由于C++’新增了不少语言特性，C++编译器并不能真正像C那样进行过眼即忘的单遍编译。但是C++必须兼容C的语意，因此编译器不得不装得好像是单遍编译(准确地说是单遍parse)一样，哪怕它内部是multiple pass的。</p>
</blockquote>
<h5 id="前向声明"><a href="#前向声明" class="headerlink" title="前向声明"></a>前向声明</h5><p>利用前向声明来较少编译期依赖，</p>
<p>函数声明与定义：通常能够查出参数列表不同，但不一定能查出返回类型不同。原型<strong>声明的变量名是无效的</strong>，以定义时为准，</p>
<p>有时候，只使用前向声明就已经足够了：</p>
<ul>
<li>定义或声明<code>Foo*</code>和<code>Foo&amp;</code>,用于函数参数，返回类型等等。</li>
<li><strong>声明一个</strong>以Foo为参数会返回类型的<strong>函数</strong>。（只在声明语句中使用就没事）</li>
</ul>
<p>不能重载<code>&amp;&amp; || , operator&amp;</code>这四个运算符。</p>
<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p>两个重要的问题：</p>
<ul>
<li>函数重载，名字改编（生成独一无二的符号名）。利用extern “C”来和C程序库集成。</li>
<li>vague linkage（模糊链接），C要求一个符号在一个程序只能有一个定义；而对于有模糊链接属性的C++对象，每个定义是弱定义，最终会有链接器去选择一个定义。</li>
</ul>
<h5 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h5><p>为了实现重载，需要先利用名字改变来为重载函数生成独一无二的名字，生成的名字像下面的样子：<code>_Z3foob</code>, </p>
<ul>
<li>这也是为什么不建议变量用下划线开头的原因。</li>
<li>这也是为什么函数名、参数数量、参数类型、参数顺序会影响重载的原因（会导致修饰后的名称不一致）；而参数名和返回值类型不影响。</li>
</ul>
<blockquote>
<p>这也导致一个bug，可能使用的函数原型的返回值是错的，但是可以链接没有报错。</p>
</blockquote>
<h5 id="inline函数"><a href="#inline函数" class="headerlink" title="inline函数"></a>inline函数</h5><p>如何在头文件定义函数，可以使用inline函数来避免重复定义。</p>
<h5 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h5><p>当模板在不同的文件具现化模板后，相同的模板的函数在不同的目标文件中定义，为了避免重复定义问题，模板的成员函数具有若定义的属性。这样可以避免报错。（类似的，inline函数也具有弱定义的属性，<strong>当inline失败时</strong>，为了避免多个文件同时定义该函数，利用弱定义）</p>
<ul>
<li>通常在编译期就会实例化模板，需要给出对应类型的定义，这要求我们必须将模板的定义放到头文件中。</li>
<li>但其实，如果编译期不给出模板的定义，只给出模板的声明，在<strong>编译期不会报错</strong>，然后在连接阶段会报<strong>找不到定义的错误</strong>。为了解决这个问题，可以在任何一个能访问到模板定义的地方实现实例化<strong>需要用到</strong>的类型。（可以利用这种方式来<strong>限制用户只能使用某几个特殊的模板类型</strong>）</li>
</ul>
<blockquote>
<p>当写一个库foo时，如果他依赖一个模板bar，则可以将模板bar的定义放到源文件中，bar的声明放到头文件，然后再源文件实例化几个需要的类型。这样可以避免用户的代码访问到模板，提高编译速度。</p>
</blockquote>
<p>C++可以使用<code>extern template</code>特性，可以手动实例化，从而避免每个使用模板的文件都进行实例化，提高编译速度。</p>
<h5 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h5><p>每个定义或者继承了虚函数的类都有一个<code>vtable</code>。而该类的每个对象都有一个指向该表<code>vtable</code>的指针，即<code>vptr</code>。</p>
<h4 id="头文件的使用规则"><a href="#头文件的使用规则" class="headerlink" title="头文件的使用规则"></a>头文件的使用规则</h4><h5 id="头文件的害处"><a href="#头文件的害处" class="headerlink" title="头文件的害处"></a>头文件的害处</h5><ul>
<li>传递性，头文件可以导入其他头文件，导致代码膨胀；任何一个头文件改动都会重新编译所有依赖于它的源文件。</li>
<li>顺序性，一个头文件可以包含多个头文件，这些头文件之间可能有顺序区分。</li>
<li>差异性<ul>
<li>内容差异，两个源文件编译时，如果编译选项不一致，会导致二进制代码不兼容，所有源文件都应该使用相同的编译选项。（如果需要使用其他人的库，除了拿到头文件和库文件，还需要知道这个库的编译选项。）</li>
<li>时间差异，头文件与库文件的内容不一致。</li>
</ul>
</li>
</ul>
<p>反观现代的编程语言，模块化做得更好：</p>
<ul>
<li>对于解释性语言，import的时候直接将对应模块的源文件解析一遍。</li>
<li>对于编译性语言，编译出来的目标文件包含了足够的元数据，import的时候可以直接读目标文件的内容。</li>
</ul>
<p>这两种方式都可以避免声明定义不一致的问题。</p>
<h5 id="头文件的使用规则-1"><a href="#头文件的使用规则-1" class="headerlink" title="头文件的使用规则"></a>头文件的使用规则</h5><p>常见的观点：</p>
<ul>
<li>将文件的编译依赖降至最小</li>
<li>将定义式之间的依赖关系降低至最小，避免循环依赖</li>
<li>让class名字、头文件名字、源文件名字直接相关</li>
<li><code>#include once</code>用的名字应该包含文件的路径的全名</li>
</ul>
<p>tips: 如何知道某一个类&#x2F;函数是通过哪个头文件被引入当前源文件的？比如要知道程序是通过哪个文件引入string这个类的，可以在当前目录创建一个包含<code>#error error</code>的名字为<code>string</code>的文件，然后在编译时使用<code>-I .</code>选项将当前目录纳入头文件搜索路径。（有个问题是如何通过一个类名判断它所在的头文件是哪个，可以通过一些标准网站来查找，比如string类对应的头文件可以在这里面找到<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/string/basic_string.html">std::basic_string - cppreference.com</a>）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rtlab<span class="number">-3090</span>:~/cpp/laji/string$ g++ test.cpp -I . -o ooo</span><br><span class="line">In file included from /usr/include/c++/<span class="number">11</span>/bits/locale_classes.h:<span class="number">40</span>,</span><br><span class="line">                 from /usr/include/c++/<span class="number">11</span>/bits/ios_base.h:<span class="number">41</span>,</span><br><span class="line">                 from /usr/include/c++/<span class="number">11</span>/ios:<span class="number">42</span>,</span><br><span class="line">                 from /usr/include/c++/<span class="number">11</span>/ostream:<span class="number">38</span>,</span><br><span class="line">                 from /usr/include/c++/<span class="number">11</span>/iostream:<span class="number">39</span>,</span><br><span class="line">                 from test.cpp:<span class="number">1</span>:</span><br><span class="line">./string:<span class="number">1</span>:<span class="number">2</span>: error: <span class="meta">#<span class="keyword">error</span> <span class="keyword">error</span></span></span><br><span class="line">    <span class="number">1</span> | <span class="meta">#<span class="keyword">error</span> <span class="keyword">error</span></span></span><br><span class="line">      |  ^~~~~</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这种找头文件的方式与通过<code>IDE</code>的<code>ctrl+click</code>跳转还是有一点区别的，假如有如下几个文件：</p>
<ul>
<li>locale_classes.h 该文件中包含了<code>&lt;string&gt;</code>，意味着所有引用locale_classes文件的文件都会包含string，</li>
<li>basic_string.h， 在string文件中，引用了basic_string文件，然后在basic_string文件中，有着string的定义，</li>
</ul>
<p>当通过IDE的<code>ctrl+click</code>跳转时，会直接进入basic_string文件，找到string定义的地方。</p>
<p>通过前往所述的方法，利用显示从当前文件到locale_classes之间的整个调用路径，它能找到的最深的文件路径是<strong>直接引用string</strong>的那一个文件。</p>
</blockquote>
<h4 id="工程项目中库文件的组织原则"><a href="#工程项目中库文件的组织原则" class="headerlink" title="工程项目中库文件的组织原则"></a>工程项目中库文件的组织原则</h4><p>改动程序或者它依赖的库都应该重新测试。</p>
<p>像java，python，需要检查库、解释器、jvm等的版本。</p>
<blockquote>
<p>库API(头文件)：人类可读的接口，比如函数签名，参数</p>
<p>编译器ABI：编译器如和将代码翻译为二进制，比如函数调用规则，对齐，名字修饰等。</p>
<p>库ABI: 包含了库API以及编译器ABI。</p>
<p>操作系统ABI：规定了系统调用和底层服务的二进制接口，比如如何触发系统调用，<code>int 80</code>等。</p>
</blockquote>
<p>编译器版本与标准库版本直接相关。</p>
<p>C++库的发布方式：</p>
<table>
<thead>
<tr>
<th></th>
<th>动态库</th>
<th>静态库</th>
<th>源码库</th>
</tr>
</thead>
<tbody><tr>
<td>发布方式</td>
<td>头文件+<code>.so</code>文件</td>
<td>头文件+<code>.a</code>文件</td>
<td>头文件+<code>.cc</code>文件</td>
</tr>
<tr>
<td>查询依赖关系</td>
<td>通过ldd可以查询一个可执行文件的依赖</td>
<td>编译期信息（还有cmake啥的吧）</td>
<td>编译期信息（还有cmake啥的吧）</td>
</tr>
</tbody></table>
<p>要保证应用程序之间的独立性，要让多个动态库的多个版本能够共存。</p>
<h5 id="动态库的危害"><a href="#动态库的危害" class="headerlink" title="动态库的危害"></a>动态库的危害</h5><p>虽然通过更新动态库，可以随时增加新特性，但是更新动态库的版本后，程序的行为变得<strong>不可预期</strong>。（能不能正常运行都是一个问题）</p>
<h5 id="静态库的危害"><a href="#静态库的危害" class="headerlink" title="静态库的危害"></a>静态库的危害</h5><p>优点：</p>
<ul>
<li>依赖关系在编译期确定</li>
<li>发布速度更快，比较没有<code>PIT</code>表（Procedure Import Table）</li>
<li>只需要发布单个可执行文件</li>
</ul>
<blockquote>
<p>向后兼容：</p>
<ul>
<li>对代码而言，指的是新版本的代码&#x2F;软件，能够兼容旧版本的数据格式、<strong>接口</strong>或功能。</li>
<li>对编译器而言，指的是新版编译器仍能正确编译、运行旧版本语法或代码风格写的程序。</li>
</ul>
<p><strong>依赖冲突</strong>（钻石依赖）：当前应用程序间接依赖于某个库的多个版本，可能导致符号冲突，不可预判的行为。</p>
</blockquote>
<p>静态链接在针对这种依赖冲突的问题，虽然可能将报错从运行期提前到编译期，但解决问题依然很麻烦，以下几种可能遇到的问题：</p>
<ul>
<li>一个依赖于库A的库突然依赖更高版本的库A时，导致其他依赖于库A的库都需要升级高版本。</li>
<li>重复链接，应用程序依赖于某个库的多个版本</li>
</ul>
<p>更新系统时，新系统的系统<code>ABI</code>可能与旧系统不兼容，理论上需要重新编译库文件。更新编译器时，编译器<code>ABI</code>（比如为C++11修改了ABI）可能发生变化，理论上需要重新编译库文件。</p>
<p>如何解决源码库吗？</p>
<h5 id="源码编译"><a href="#源码编译" class="headerlink" title="源码编译"></a>源码编译</h5><p>可以确保所有源文件在相同的条件下编译的，不用为库的版本操心。</p>
<p>由于<code>C++</code>的头文件与源文件分离，并且编译产生的目标文件<code>.o</code>没有包含足够的元数据，如果要在项目中使用一个库，还必须提供对应的头文件。因为同时需要这两个东西，就会导致这<strong>两者不匹配的情况。</strong>（c++编译的目标文件就只是二进制代码，并不包含任何如何使用该类的信息，比如函数声明，类结构）</p>
<blockquote>
<p>from gpt:</p>
<h2 id="C-有必要用库吗？"><a href="#C-有必要用库吗？" class="headerlink" title="C++ 有必要用库吗？"></a>C++ 有必要用库吗？</h2><p><strong>必须的。</strong>因为 C++ 本身没有电池齐全（batteries included）：</p>
<ul>
<li>C++ 标准库太“基础”了（比如没网络库、图形库、并发框架、解析库等）</li>
<li>高质量第三方库是构建现代 C++ 项目的核心<br>例如：<ul>
<li>并发网络：<code>Boost.Asio</code>, <code>libuv</code>, <code>gRPC</code></li>
<li>序列化：<code>protobuf</code>, <code>msgpack</code>, <code>flatbuffers</code></li>
<li>UI：<code>Qt</code>, <code>FTXUI</code></li>
<li>日志：<code>spdlog</code>, <code>glog</code></li>
<li>单元测试：<code>GoogleTest</code>, <code>Catch2</code></li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="C-面向对象与虚函数"><a href="#C-面向对象与虚函数" class="headerlink" title="C++面向对象与虚函数"></a>C++面向对象与虚函数</h3><blockquote>
<p>虽然 C++ 支持面向对象编程（如类、继承、多态等），但它的语法和机制在设计上并不如 Java、C# 等“原生支持”面向对象的语言来得自然和系统化。它是一种通过对 C 语言的扩展实现的 OO。</p>
</blockquote>
<p>C++ class 是值语义，而非对象语义。这带来的影响很多：</p>
<ul>
<li>直接赋值时，会发生拷贝构造，而非引用复制。</li>
<li>如果想使用深拷贝，需要显示编码</li>
</ul>
<h4 id="朴实的C-设计"><a href="#朴实的C-设计" class="headerlink" title="朴实的C++设计"></a>朴实的<code>C++</code>设计</h4><p>C++复杂，但<strong>不代表要使用复杂的方式来使用它</strong>。（作者不建议大规模使用面对对象、继承、多态）</p>
<p>利用接口类&#x2F;实现类的一个好处就是可以实现依赖注入。（将对象从类的外部传入）</p>
<h4 id="程序库的二进制兼容性"><a href="#程序库的二进制兼容性" class="headerlink" title="程序库的二进制兼容性"></a>程序库的二进制兼容性</h4><p>比如一个图形库，支持<code>1920*1200</code>像素，很多项目用到了该库。后来为了支持<code>2560*1600</code>像素，可以有两种解决方式：</p>
<ul>
<li>发布一个新的图形库，让使用了该图像库的其他项目重新编译。这会导致其他项目重新发布一个版本。</li>
<li>更新现有的库文件，但是新库和旧项目可能出现不兼容的问题。</li>
</ul>
<p>本章的二进制兼容性主要是指库文件单独升级，现有可执行文件是否受影响，<strong>主要是动态链接库</strong>的 ABI（怎么感觉应该是API呢）, 至于编译器以及操作系统的ABI 见上一章。</p>
<h5 id="二进制兼容性"><a href="#二进制兼容性" class="headerlink" title="二进制兼容性"></a>二进制兼容性</h5><p>使用动态库的方式提供函数库，那么头文件和库文件不应该被轻易修改。</p>
<p>希望在升级库文件（或者Linux Kernel）时，不必重新编译使用了这个库的可执行文件。（在可执行文件仍然使用旧的头文件时，仍然可使用新的库文件。这意味着我们的可执行文件不用重新编译，不用发布新版本，想一下，如果依赖的每个库更新时，我们都需要重新编译以及发布，那么带来的工作量有多大）</p>
<blockquote>
<p>源代码兼容性：老代码使用新头文件，能编译通过。（感觉二进制兼容比源代码兼容要求要高）</p>
<p>向后兼容性：（兼容过去的版本，不同的软件版本，给使用者留下了一个使用接口，最新的软件仍然提供老版本的使用接口，则是兼容）在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E8%85%A6">计算机</a>中指在一个<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E8%85%A6%E7%A8%8B%E5%BC%8F">程序</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%BA%93_(%E8%AE%A1%E7%AE%97%E6%9C%BA)">库</a>或<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%94%B5%E8%84%91%E7%A1%AC%E4%BB%B6">硬件</a>更新到较新<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%89%88%E6%9C%AC">版本</a>后，用旧版本程序创建的文档或系统仍能被正常操作或使用，在旧版本库的基础上开发的程序仍能正常<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BC%96%E8%AF%91">编译</a>运行。</p>
</blockquote>
<blockquote>
<p>当多个应用或库依赖不同版本的同一个 DLL，但系统无法正确加载对应版本时，就会出现“DLL Hell”。</p>
</blockquote>
<h5 id="什么情况会破坏库的-ABI"><a href="#什么情况会破坏库的-ABI" class="headerlink" title="什么情况会破坏库的 ABI"></a>什么情况会破坏库的 <code>ABI</code></h5><p>这取决于C++的实现方式，比如Visual C++， G++。</p>
<p>C++编译器 ABI 的主要内容包括以下几个方面：</p>
<ul>
<li>函数参数传递的方式</li>
<li>虚函数的调用方式，通常是vptr&#x2F;vtbl</li>
<li>struct 和 class 的内存布局</li>
<li>name mangling</li>
<li>RTTI 和 异常处理</li>
</ul>
<p>C&#x2F;C++是通过<strong>头文件</strong>来暴露出动态库的使用方法（函数调用以及对象布局）。通过判断这个头文件的<strong>使用方法</strong>是否与新版本库的<strong>实际使用方法</strong>相匹配，就知道这个改动是否是二进制兼容。</p>
<p>比如：</p>
<ul>
<li>动态库中有 <code>non-virtual</code>函数<code>void foo(int)</code>，新版本的库变为了<code>void foo(double)</code>，这会导致两个函数的名字修饰不一致，进而找不到符号。</li>
<li>对于上面的情况，将<code>non-virtual</code>函数变为<code>virtual</code>函数。虚函数不是通过签名（符号）来找对应的实现的，<strong>而是通过索引</strong>。在编译时，就会将 foo 函数转变为内部 vtable 中某个索引（即函数指针）的调用（索引顺序是声明顺序）。当库被修改后，对应索引的函数指针变化了，如果还是按照旧版本的头文件使用索引，虽然编译不会报错，但在运行时会遇到未定义的行为。（一种可能的做法是在foo函数后面新增新的函数，这样生成的vtable只会在后面新增索引，<strong>也许能保证向后兼容</strong>，<strong>还得考虑当前类是否被继承。</strong>）</li>
</ul>
<p>源代码兼容但二进制不兼容的例子：</p>
<ul>
<li>给函数增加默认参数（默认参数是通过在编译时在调用函数时手动加上该参数来实现的，默认参数只存在于函数声明处，无需出现在定义处，<strong>定义不知道也不关心有没有默认参数</strong>）</li>
<li>增加虚函数，会导致vtbl的排列变化，要考虑当前类是否被继承。</li>
<li>增加默认模板参数类型<code>Foo&lt;T&gt;</code>变为 <code>Foo&lt;T, Alloc=alloc&lt;T&gt;&gt;</code>，</li>
<li>改变 enum 的值</li>
</ul>
<p>考虑如下的情况：给<code>class Bar</code> 新增数据成员，导致 <code>sizeof(Bar)</code> 变大以及内部结构变化，这通常不安全，也有例外：</p>
<ul>
<li>如果客户代码中使用了<code>new Bar</code>，这是不安全的（因为会调用malloc，会根据头文件中的数据类型来确定类的大小，这和源文件中类的大小不一致；然后会调用源文件中的构造函数，这很可能会导致用来未分配的内存）。<strong>可以通过<code>factory</code>返回<code>Bar*</code>或者<code>shared_ptr&lt;Bar&gt;</code>。</strong></li>
<li>避免直接访问类中的变量，而是通过成员函数访问。</li>
<li>避免调用<code>inline</code>修饰的成员函数。而是使用<code>outline function</code>。</li>
</ul>
<h5 id="哪些做法可能是二进制兼容的"><a href="#哪些做法可能是二进制兼容的" class="headerlink" title="哪些做法可能是二进制兼容的"></a>哪些做法可能是二进制兼容的</h5><ul>
<li>增加新的 <code>class</code></li>
<li>增加 <code>non-virtual</code>成员函数或<code>static</code>成员函数</li>
<li>修改数据成员的名称，二进制代码是通过偏移量访问数据成员的。</li>
<li>个人测试：修改只虚函数名字，并保证参数返回值，虚函数声明顺序不变，貌似也可以实现二进制兼容。见<a target="_blank" rel="noopener" href="https://github.com/tjzhang-src/cpp/tree/master/muduo/chapter11/virtual">cpp&#x2F;muduo&#x2F;chapter11&#x2F;virtual</a></li>
</ul>
<h5 id="为了避免二进制不兼容"><a href="#为了避免二进制不兼容" class="headerlink" title="为了避免二进制不兼容"></a>为了避免二进制不兼容</h5><p>有如下的做法：</p>
<ul>
<li>使用静态链接</li>
<li>仔细管理动态库的版本，详见<a href="https://tjzhang-src.github.io/.github.io/2023/03/19/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-%E7%AC%AC%E5%85%AB%E7%AB%A0/#%E5%85%B1%E4%BA%AB%E5%BA%93%E5%91%BD%E5%90%8D%E6%96%B9%E5%BC%8F">共享库命名方式</a></li>
<li>pimpl技法，多一层间接性</li>
</ul>
<h4 id="避免使用虚函数作为库的接口"><a href="#避免使用虚函数作为库的接口" class="headerlink" title="避免使用虚函数作为库的接口"></a>避免使用虚函数作为库的接口</h4><p>如果打算写一个库，需要考虑：</p>
<ul>
<li>动态库 <code>or</code> 静态库</li>
<li>以什么方式暴露库的接口：全局函数、类的<code>non-virtual</code>成员函数、类的<code>virtual</code>函数。</li>
</ul>
<p>有两个基本假设：</p>
<ul>
<li>代码有<code>bug</code>，会发布<code>bug fixes</code></li>
<li>代码会有新功能，要升级</li>
</ul>
<p>针对第一个假设：</p>
<ul>
<li>如果要热修复，则只能使用动态库；</li>
<li>否则使用静态库更容易部署。</li>
</ul>
<p>针对第二个假设：</p>
<ul>
<li>如果第一步用的是使用动态库<ul>
<li>如果只是 修 bug，那么二进制库文件应该达到二进制兼容</li>
<li>如果要新增功能，应该对用户代码友好</li>
</ul>
</li>
<li>如果第一步用的静态库，那么不会遇到上面的问题。</li>
</ul>
<h5 id="虚函数作为库的接口的两大用途"><a href="#虚函数作为库的接口的两大用途" class="headerlink" title="虚函数作为库的接口的两大用途"></a>虚函数作为库的接口的两大用途</h5><ul>
<li>调用，库提供某个功能，以虚函数为接口暴露给客户端代码。</li>
<li>回调，事件通知，重写虚函数作为回调时使用的函数。（该方法已过时，可以利用<code>bind</code>这种做法）</li>
</ul>
<h5 id="虚函数作为接口的弊端"><a href="#虚函数作为接口的弊端" class="headerlink" title="虚函数作为接口的弊端"></a>虚函数作为接口的弊端</h5><p><strong>要实现二进制兼容性十分困难</strong>，一旦发布，不能修改，只能重写编译。</p>
<p>比如如果要新增几个接口（虚函数），为了保证二进制兼容性，只能将新函数放到 <code>interface</code>的接口，这么做既丑陋又危险（一旦被继承）。</p>
<h4 id="动态库接口的推荐做法"><a href="#动态库接口的推荐做法" class="headerlink" title="动态库接口的推荐做法"></a>动态库接口的推荐做法</h4><blockquote>
<p>（思路，看不到库中头文件的具体实现更容易实现二进制兼容性，具体来说是避免看见头文件类中的数据成员，知道数据成员了就知道类的大小，将来增加数据成员后使用sizeof会出错，虽然）</p>
<p>Pimpl方法：类中包含一个指向某个具体类型的指针。实现定义在该具体类型的<strong>源文件</strong>中。（代码见<a target="_blank" rel="noopener" href="https://github.com/tjzhang-src/cpp/tree/master/muduo/chapter11/pimpl">cpp&#x2F;muduo&#x2F;chapter11&#x2F;pimpl</a>），这样可以隐藏Impl类，任何类都看不到该类，</p>
<ul>
<li>当修改Impl类时，不会导致其依赖于Impl的类重新编译（Person除外，毕竟Impl就定义在Person文件里面的）</li>
<li>减少了编译依赖，</li>
</ul>
</blockquote>
<ul>
<li>动态库的使用范围有限，做好版本管理即可。（头文件和类分为用户可见部分和不可见部分，针对用户可见部分，需要注意二进制兼容性）</li>
<li>使用 pimpl 方法，多使用 non-member non-friend函数来作为接口。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://tjzhang-src.github.io/.github.io">John Doe</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://tjzhang-src.github.io/.github.io/2025/08/02/muduo-part2/">https://tjzhang-src.github.io/.github.io/2025/08/02/muduo-part2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://tjzhang-src.github.io/.github.io" target="_blank">Welcome</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/.github.io/tags/c/">c++</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/.github.io/2025/04/08/muduo/" title="muduo"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">muduo</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/.github.io/2024/09/17/cplusplusprimer/" title="cplusplusprimer"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-17</div><div class="title">cplusplusprimer</div></div></a></div><div><a href="/.github.io/2023/02/28/c-%E5%9F%BA%E7%A1%801/" title="c++基础1"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-28</div><div class="title">c++基础1</div></div></a></div><div><a href="/.github.io/2024/09/17/effective-cplusplus/" title="effective_cplusplus"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-17</div><div class="title">effective_cplusplus</div></div></a></div><div><a href="/.github.io/2024/09/17/more-effective-cpulsplus/" title="more_effective_cpulsplus"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-17</div><div class="title">more_effective_cpulsplus</div></div></a></div><div><a href="/.github.io/2025/04/08/muduo/" title="muduo"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-08</div><div class="title">muduo</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Waline</span><span class="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/.github.io/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">John Doe</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/.github.io/archives/"><div class="headline">文章</div><div class="length-num">46</div></a><a href="/.github.io/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/.github.io/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/tjzhang-src"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.</span> <span class="toc-text">C++编译链接模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E7%9A%84%E7%BC%96%E8%AF%91%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">C++的编译模型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E9%81%8D%E7%BC%96%E8%AF%91"><span class="toc-number">1.1.1.</span> <span class="toc-text">单遍编译</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%90%8D%E5%AD%97%E6%9F%A5%E6%89%BE%EF%BC%9A"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">名字查找：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E5%86%B3%E8%AE%AE"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">函数重载决议</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%8D%E5%90%91%E5%A3%B0%E6%98%8E"><span class="toc-number">1.1.2.</span> <span class="toc-text">前向声明</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5"><span class="toc-number">1.2.</span> <span class="toc-text">链接</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">1.2.1.</span> <span class="toc-text">函数重载</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#inline%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.2.</span> <span class="toc-text">inline函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.2.3.</span> <span class="toc-text">模板</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.4.</span> <span class="toc-text">虚函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99"><span class="toc-number">1.3.</span> <span class="toc-text">头文件的使用规则</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E5%AE%B3%E5%A4%84"><span class="toc-number">1.3.1.</span> <span class="toc-text">头文件的害处</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99-1"><span class="toc-number">1.3.2.</span> <span class="toc-text">头文件的使用规则</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E7%A8%8B%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%BA%93%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%84%E7%BB%87%E5%8E%9F%E5%88%99"><span class="toc-number">1.4.</span> <span class="toc-text">工程项目中库文件的组织原则</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8D%B1%E5%AE%B3"><span class="toc-number">1.4.1.</span> <span class="toc-text">动态库的危害</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E5%8D%B1%E5%AE%B3"><span class="toc-number">1.4.2.</span> <span class="toc-text">静态库的危害</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91"><span class="toc-number">1.4.3.</span> <span class="toc-text">源码编译</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E6%9C%89%E5%BF%85%E8%A6%81%E7%94%A8%E5%BA%93%E5%90%97%EF%BC%9F"><span class="toc-number"></span> <span class="toc-text">C++ 有必要用库吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8E%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">1.</span> <span class="toc-text">C++面向对象与虚函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%B4%E5%AE%9E%E7%9A%84C-%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.1.</span> <span class="toc-text">朴实的C++设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%BA%93%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="toc-number">1.2.</span> <span class="toc-text">程序库的二进制兼容性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="toc-number">1.2.1.</span> <span class="toc-text">二进制兼容性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%BC%9A%E7%A0%B4%E5%9D%8F%E5%BA%93%E7%9A%84-ABI"><span class="toc-number">1.2.2.</span> <span class="toc-text">什么情况会破坏库的 ABI</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E5%81%9A%E6%B3%95%E5%8F%AF%E8%83%BD%E6%98%AF%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%85%BC%E5%AE%B9%E7%9A%84"><span class="toc-number">1.2.3.</span> <span class="toc-text">哪些做法可能是二进制兼容的</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BA%86%E9%81%BF%E5%85%8D%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%8D%E5%85%BC%E5%AE%B9"><span class="toc-number">1.2.4.</span> <span class="toc-text">为了避免二进制不兼容</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E8%99%9A%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%BA%93%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.3.</span> <span class="toc-text">避免使用虚函数作为库的接口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%BA%93%E7%9A%84%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%B8%A4%E5%A4%A7%E7%94%A8%E9%80%94"><span class="toc-number">1.3.1.</span> <span class="toc-text">虚函数作为库的接口的两大用途</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%BC%8A%E7%AB%AF"><span class="toc-number">1.3.2.</span> <span class="toc-text">虚函数作为接口的弊端</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%BA%93%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%8E%A8%E8%8D%90%E5%81%9A%E6%B3%95"><span class="toc-number">1.4.</span> <span class="toc-text">动态库接口的推荐做法</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/.github.io/2025/08/02/muduo-part2/" title="muduo_part2">muduo_part2</a><time datetime="2025-08-02T07:25:23.000Z" title="发表于 2025-08-02 15:25:23">2025-08-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/.github.io/2025/04/08/muduo/" title="muduo">muduo</a><time datetime="2025-04-08T01:30:10.000Z" title="发表于 2025-04-08 09:30:10">2025-04-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/.github.io/2025/02/22/xv6/" title="xv6">xv6</a><time datetime="2025-02-22T13:38:24.000Z" title="发表于 2025-02-22 21:38:24">2025-02-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/.github.io/2024/12/04/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/" title="Linux高性能服务器编程">Linux高性能服务器编程</a><time datetime="2024-12-04T09:01:31.000Z" title="发表于 2024-12-04 17:01:31">2024-12-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/.github.io/2024/12/03/%E5%9B%BE%E8%A7%A3HTTP/" title="图解HTTP">图解HTTP</a><time datetime="2024-12-03T03:35:49.000Z" title="发表于 2024-12-03 11:35:49">2024-12-03</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://s2.loli.net/2023/02/26/9fQnztK2ImqyLwS.webp')"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2025 By John Doe</div><div class="footer_custom_text">Hi, welcome to my <a href="https://tjzhang-src.github.io/.github.io/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/.github.io/js/utils.js"></script><script src="/.github.io/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>function loadWaline () {
  function initWaline () {
    const waline = Waline.init(Object.assign({
      el: '#waline-wrap',
      serverURL: 'https://blog-comment-bfstu88s1-ttj2023.vercel.app/',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      path: window.location.pathname,
      comment: false,
    }, null))
  }

  const walineCSSLoad = document.getElementById('waline-css')

  if (typeof Waline === 'object') {
    walineCSSLoad ? initWaline() : getCSS('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.css','waline-css').then(initWaline)
  }
  else {
    getCSS('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.css','waline-css').then(() => {
      getScript('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.js').then(initWaline)
    })
  }
}

if ('Waline' === 'Waline' || !true) {
  if (true) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
  else setTimeout(loadWaline, 0)
} else {
  function loadOtherComment () {
    loadWaline()
  }
}</script><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'https://tjzhang-src.github.io/.github.io/2025/08/02/muduo-part2/'
    this.page.identifier = '/.github.io/2025/08/02/muduo-part2/'
    this.page.title = 'muduo_part2'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }

  document.getElementById('darkmode').addEventListener('click', () => {
    setTimeout(() => window.disqusReset(), 200)
  })
}

if ('Waline' === 'Disqus' || !true) {
  if (true) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>