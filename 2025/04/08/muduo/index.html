<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>muduo | Welcome</title><meta name="author" content="John Doe"><meta name="copyright" content="John Doe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="线程安全的对象生命周期管理析构函数&amp;多线程多线程共享对象，对象的线程安全特性可以由对象内的同步原语保护。但是对象的析构没法通过内部的同步原语保护。（猜测要通过外部的同步原语保护）  比如如何保证在执行成员函数期间，对象不会被其他线程析构。  线程安全线程安全的类满足如下三个条件：  多线程可以同时访问，表现正常。 无论这些线程的执行顺序如何交织。 调用端无需同步操作。   C++大部分类，">
<meta property="og:type" content="article">
<meta property="og:title" content="muduo">
<meta property="og:url" content="https://tjzhang-src.github.io/.github.io/2025/04/08/muduo/index.html">
<meta property="og:site_name" content="Welcome">
<meta property="og:description" content="线程安全的对象生命周期管理析构函数&amp;多线程多线程共享对象，对象的线程安全特性可以由对象内的同步原语保护。但是对象的析构没法通过内部的同步原语保护。（猜测要通过外部的同步原语保护）  比如如何保证在执行成员函数期间，对象不会被其他线程析构。  线程安全线程安全的类满足如下三个条件：  多线程可以同时访问，表现正常。 无论这些线程的执行顺序如何交织。 调用端无需同步操作。   C++大部分类，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2025-04-08T01:30:10.000Z">
<meta property="article:modified_time" content="2025-08-02T07:16:46.939Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="c++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/.github.io/img/favicon.png"><link rel="canonical" href="https://tjzhang-src.github.io/.github.io/2025/04/08/muduo/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//hm.baidu.com"/><link rel="stylesheet" href="/.github.io/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?4cc6526274b17acfe67a4be7d70e8d1c";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-FF1BJEGK51"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-FF1BJEGK51');
</script><script>const GLOBAL_CONFIG = { 
  root: '/.github.io/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'muduo',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-08-02 15:16:46'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (false) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/.github.io/archives/"><div class="headline">文章</div><div class="length-num">46</div></a><a href="/.github.io/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/.github.io/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/.github.io/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/.github.io/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/.github.io/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/.github.io/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/.github.io/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/.github.io/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/.github.io/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/.github.io/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s2.loli.net/2023/02/26/9fQnztK2ImqyLwS.webp')"><nav id="nav"><span id="blog-info"><a href="/.github.io/" title="Welcome"><span class="site-name">Welcome</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/.github.io/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/.github.io/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/.github.io/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/.github.io/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/.github.io/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/.github.io/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/.github.io/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/.github.io/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">muduo</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-04-08T01:30:10.000Z" title="发表于 2025-04-08 09:30:10">2025-04-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-08-02T07:16:46.939Z" title="更新于 2025-08-02 15:16:46">2025-08-02</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">2.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>7分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="muduo"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="线程安全的对象生命周期管理"><a href="#线程安全的对象生命周期管理" class="headerlink" title="线程安全的对象生命周期管理"></a>线程安全的对象生命周期管理</h3><h4 id="析构函数-amp-多线程"><a href="#析构函数-amp-多线程" class="headerlink" title="析构函数&amp;多线程"></a>析构函数&amp;多线程</h4><p>多线程共享对象，对象的线程安全特性可以由对象内的同步原语保护。但是对象的析构没法通过内部的同步原语保护。（猜测要通过外部的同步原语保护）</p>
<blockquote>
<p>比如如何保证在执行成员函数期间，对象不会被其他线程析构。</p>
</blockquote>
<h5 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h5><p>线程安全的类满足如下三个条件：</p>
<ul>
<li>多线程可以同时访问，表现正常。</li>
<li>无论这些线程的执行顺序如何交织。</li>
<li>调用端无需同步操作。</li>
</ul>
<blockquote>
<p>C++大部分类，string，vector都不是线程安全的，也可以理解，毕竟需要线程安全的时间也不多，没必要增加额外的开销。</p>
</blockquote>
<h4 id="对象构造-amp-线程安全"><a href="#对象构造-amp-线程安全" class="headerlink" title="对象构造&amp;线程安全"></a>对象构造&amp;线程安全</h4><p>如何保证对象构造的线程安全：在构造期间不要泄露<code>this</code>指针。</p>
<p>可以使用两段式构造。</p>
<h4 id="对象销毁-amp-线程安全"><a href="#对象销毁-amp-线程安全" class="headerlink" title="对象销毁&amp;线程安全"></a>对象销毁&amp;线程安全</h4><p>很难解决的问题。文章从面对对象程序设计的角度提出了一些问题。</p>
<p>对象的关系包括三种：</p>
<ul>
<li>composition(组合)：如<code>struct A&#123;struct B b;&#125;;</code>b的生命周期由A决定，A对象被析构时，b也被析构。</li>
<li>association(关联)：在形式上与下面一条很类似，生命周期独立。</li>
<li>aggregation(聚合)：如<code>struct A&#123;struct B* b&#125;;</code>b，生命周期独立。如果b被释放，则会面临竞态条件。</li>
</ul>
<blockquote>
<p>shared_ptr，循环引用导致两者都没办法被释放。</p>
</blockquote>
<blockquote>
<p>空悬指针：指向已经被释放内存的指针，比如a，b同时指向一段内存，但是a释放了该段内存。</p>
</blockquote>
<h4 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h4><blockquote>
<p>传递原始指针简直就是一个灾难，前者没法判断后者对指针的操作，后者也没办法判断前者对指针的操作。</p>
</blockquote>
<p>shared_ptr是强引用，会增加对象的引用，而weak_ptr不会，他只想想知道对象是否存在。</p>
<p>使用智能指针通常可以解决如下问题：</p>
<ul>
<li>缓冲区溢出：可以自动记录缓冲区的长度，通过成员函数访问</li>
<li>空悬指针：用智能指针就不空悬了</li>
<li>重复释放&#x2F;内存泄漏</li>
<li>不配对的new&#x2F;delete</li>
</ul>
<p>这两个智能指针都是值语意，不会有如下写法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto ptr = new shared_ptr&lt;Foo&gt;(new Foo);//谁能干出这种事啊？</span><br></pre></td></tr></table></figure>

<h4 id="shared-ptr的线程安全"><a href="#shared-ptr的线程安全" class="headerlink" title="shared_ptr的线程安全"></a>shared_ptr的线程安全</h4><p>shared_ptr的内部数据包含计数的地址和内存区域的地址，包含两个值，多线程同时读写一个shared_ptr对象时，可能导致错误。——<strong>即shared_ptr对象本身不是线程安全的。</strong></p>
<p><strong>对shared_ptr指向的内存区域也不一定是内存安全的</strong>，需要程序员包含。</p>
<p>使用shared_ptr时，<strong>只能保证对引用计数的更新是线程安全的。</strong></p>
<h4 id="shared-ptr的陷阱"><a href="#shared-ptr的陷阱" class="headerlink" title="shared_ptr的陷阱"></a>shared_ptr的陷阱</h4><ol>
<li>使用shared_ptr会导致引用计数无法归零。</li>
</ol>
<blockquote>
<p>书上的一个例子，observer在observable中注册了一个对自己（observer）的shared_ptr, 当observer被析构时，当然也希望observable中的shared_ptr被删除。</p>
<p>一种办法是在在observer中的析构函数中调用observerable的取消注册函数，这本身就是一个悖论，因为只有在引用计数为0才会执行析构函数，而observable中保留着引用，那么引用用于不会归零，也就导致永远都不会调用析构函数。</p>
</blockquote>
<ol start="2">
<li><p>可以使用const &amp;来传递shared_ptr, 来减小开销。</p>
</li>
<li><p>RAII handle。为了避免循环引用，对象的所有者应该使用shared_ptr, 而一些不太需要对象的需要使用weak_ptr。</p>
</li>
</ol>
<h4 id="对象池"><a href="#对象池" class="headerlink" title="对象池"></a>对象池</h4><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>四项原则：</p>
<ul>
<li>尽量少共享对象，如果要暴露，先考虑immutable对象，其次才是可以修改的对象，但需要充分的同步措施来保护他。</li>
<li>使用高级的并发编程构件：TaskQueue、Producer-Consumer Queue。</li>
<li>最后不得已才使用底层同步原语，只使用<strong>非递归</strong>的互斥器和条件变量，<strong>慎用读写锁，不用信号量</strong>。</li>
<li>除了使用原子操作，不要使用无锁代码， 不要使用内核级同步原语。</li>
</ul>
<blockquote>
<p>仔细想想，还是1和2方面讷</p>
</blockquote>
<h4 id="互斥器"><a href="#互斥器" class="headerlink" title="互斥器"></a>互斥器</h4><p>互斥器保护了临界区，基本原则：</p>
<ul>
<li>用RAII封装mutex。</li>
<li>只用不可重入的mutex。</li>
<li>使用guard。</li>
<li>每次构造guard对象是，思考一路上已经持有的锁，防止加锁顺序不同而死锁。看调用栈就可以分析用锁的情况。</li>
</ul>
<p>次要原则包括：</p>
<ul>
<li>不使用跨进程的mutex，进程间通信只使用sockets。</li>
<li>必要的时候使用PTHREAD_MUTEX_ERRORCHECK来排错。</li>
</ul>
<h5 id="只使用非递归的mutex"><a href="#只使用非递归的mutex" class="headerlink" title="只使用非递归的mutex"></a>只使用非递归的mutex</h5><p>使用非递归锁可以把程序的逻辑错误暴露出来。</p>
<blockquote>
<p>gdb 使用thread apply all bt打印所有栈的信息</p>
</blockquote>
<h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><h4 id="条件变量（管程）"><a href="#条件变量（管程）" class="headerlink" title="条件变量（管程）"></a>条件变量（管程）</h4><ol>
<li>必须和mutex一起使用</li>
<li>在mutex上锁的时候才能调用wait</li>
<li>把布尔条件和wait放到while循环中</li>
</ol>
<p>条件变量是非常底层的同步原语，很少直接使用，一般使用它实现的高层的同步措施。如BlockingQueue或CountDownLatch。</p>
<h4 id="不要用读写锁和信号量"><a href="#不要用读写锁和信号量" class="headerlink" title="不要用读写锁和信号量"></a>不要用读写锁和信号量</h4><h4 id="封装MutexLock、MutexLockGuard、Condition"><a href="#封装MutexLock、MutexLockGuard、Condition" class="headerlink" title="封装MutexLock、MutexLockGuard、Condition"></a>封装MutexLock、MutexLockGuard、Condition</h4><h4 id="利用shared-ptr实现copy-on-write"><a href="#利用shared-ptr实现copy-on-write" class="headerlink" title="利用shared_ptr实现copy-on-write"></a>利用shared_ptr实现copy-on-write</h4><p>利用shared_ptr替代读写锁，shared_ptr本身包含计数，可以代替信号量的作用，shared_ptr引用为1时，写进程可以进行写，如果引用大于1时，此时其他使用该引用的进程。</p>
<h3 id="多线程服务器"><a href="#多线程服务器" class="headerlink" title="多线程服务器"></a>多线程服务器</h3><h4 id="单线程服务器的编程模型"><a href="#单线程服务器的编程模型" class="headerlink" title="单线程服务器的编程模型"></a>单线程服务器的编程模型</h4><p>常用的模式：non-blocking IO + IO multiplexing模式，即Reactor模式。</p>
<p>程序的结构：事件循环，以事件驱动+事件回调的方式实现业务逻辑。</p>
<p>缺点：回调函数应该是非阻塞的。</p>
<h4 id="多线程服务器编程模型"><a href="#多线程服务器编程模型" class="headerlink" title="多线程服务器编程模型"></a>多线程服务器编程模型</h4><h5 id="one-loop-per-thread"><a href="#one-loop-per-thread" class="headerlink" title="one loop per thread"></a>one loop per thread</h5><h4 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h4><p>首选TCP，主要是可以跨主机，改改host:port就能直接用。</p>
<h4 id="多线程服务器的适用场合"><a href="#多线程服务器的适用场合" class="headerlink" title="多线程服务器的适用场合"></a>多线程服务器的适用场合</h4><h5 id="必须使用（多进程）单线程的场合"><a href="#必须使用（多进程）单线程的场合" class="headerlink" title="必须使用（多进程）单线程的场合"></a>必须使用（多进程）单线程的场合</h5><ul>
<li>程序可能fork的时候，（多线程程序不应该fork，因为fork之后，只有执行fork的哪个线程占据新进程的资源，其他线程会消失，如果遇到锁，会产生大问题）</li>
<li>限制程序的CPU占用率，单线程即使发生busy-wait，CPU利用率也只有12.5%，而如果是多线程，可能导致多个线程跑满核心。</li>
</ul>
<h5 id="适用多线程程序的场景"><a href="#适用多线程程序的场景" class="headerlink" title="适用多线程程序的场景"></a>适用多线程程序的场景</h5><p>无论是IO bound任务还是CPU bound任务，多线程程序都没有什么性能优势。</p>
<ul>
<li>IO bound，任务的执行速度瓶颈在于IO, IO跑满后，cpu仍然没有达到上限。改为多线程程序当然也不会提升性能。</li>
<li>CPU bound，任务的执行速度瓶颈在于CPU。改为多线程程序当然也不会提升性能。</li>
</ul>
<p>使用多线程的场景：提高响应速度，让IO和计算相互重叠，降低latency。<strong>虽然多线程不能提升绝对性能，但能提高平均相对性能。（比如说单线程遇到IO就会陷入系统调用，CPU没有被利用，而多线程则可以利用CPU执行一些其他任务）</strong>大致要满足如下条件：</p>
<ul>
<li>多核</li>
<li>线程间有能修改的共享数据，不能修改的共享数据可以用多进程单线程来实现。</li>
</ul>
<blockquote>
<p>看需不需要共享资源来选择多线程还是多进程，</p>
<p>比如处理IO任务，通常需要从listen线程先worker线程传送文件描述符，传送文件描述符这项操作只能在同进程内操作。所以这个任务适合使用多线程。</p>
<p>比如书上72页的例子，多个任务都需要根据机群的状态来决定处理的措施，这也适合用多线程。</p>
</blockquote>
<p>线程的分类：</p>
<ul>
<li>IO线程，线程主循环时IO multiplexing，阻塞的等在select&#x2F;poll&#x2F;epoll等系统调用上。</li>
<li>计算线程，这类线程的主循环是blocking queue，阻塞的等在condition variable上，这类线程一般位于thread pool上，一般不涉及IO。</li>
<li>第三方库的线程，比如logging，database connection。</li>
</ul>
<h5 id="问答"><a href="#问答" class="headerlink" title="问答"></a>问答</h5><p>BlockingQueue：</p>
<p>通常工作线程需要往磁盘写log，这本身不属于线程的业务范围，为了提升线程的响应速度，可以将写任务通通交给一个日志线程去做。</p>
<p>线程没法减少工作量，通过调配，能让工期提早结束。</p>
<h3 id="C-多线程系统编程"><a href="#C-多线程系统编程" class="headerlink" title="C++多线程系统编程"></a>C++多线程系统编程</h3><p>要注意，程序可能在任何时候中断，在任何时候启动。</p>
<h4 id="基本线程原语的选用"><a href="#基本线程原语的选用" class="headerlink" title="基本线程原语的选用"></a>基本线程原语的选用</h4><p>posix函数中最有用的十几个：</p>
<ul>
<li>线程的创建和等待结束（join)。muduo::Thread</li>
<li>mutex的创建、销毁、加锁、解锁。muduo::MutexLock</li>
<li>条件变量的创建、消耗、等待、通知、广播。muduo::Condition。</li>
</ul>
<h4 id="C-x2F-C-系统库的线程安全性"><a href="#C-x2F-C-系统库的线程安全性" class="headerlink" title="C&#x2F;C++系统库的线程安全性"></a>C&#x2F;C++系统库的线程安全性</h4><p>glibc库函数很多都是线程安全的，但是将多个库函数组合起来就不一定了。（比如先lseek在read，这之间可能被第三者打断）</p>
<p>C++标准库和string都不是线程安全的。</p>
<p>C++标准库大部分泛型算法是线程安全的，因为他们是无状态的。</p>
<p>iostream也不是线程安全的。因为</p>
<figure class="highlight plaintext"><figcaption><span><< "Now is" << time(NULL);```等于如下两个函数调用</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```cout.operator&lt;&lt;(&quot;Now is&quot;).operator(time(NULL));```这之间可能被其他线程打断。</span><br><span class="line"></span><br><span class="line">可以改用printf实现线程安全的输出。</span><br><span class="line"></span><br><span class="line">&gt; tips:</span><br><span class="line">&gt;</span><br><span class="line">&gt; a();b();这两个函数一起执行不是线程安全的，不代表这两个函数都不是线程安全的。一个函数是不是线程安全的需要看其内部是不是对某个全局可写变量进行了非原子的多次操作。（个人看法）</span><br><span class="line"></span><br><span class="line">#### Linux上的线程标识</span><br><span class="line"></span><br><span class="line">* 内核标识——tid，通过syscall(SYS_gettid)访问，用于操作系统内核进行线程调度和管理</span><br><span class="line">* POSIX标识，pthread_t, 在不同的平台代表的意义不一致：指针，结构体之类的。glibc的pthreads把pthread_t作为一个结构体指针，指向一块动态分配的内存，这块内存可能被反复使用，所以不能根据pthread_t的值来判断多个线程是否是同一个线程，需要通过pthread_equal来判断。</span><br><span class="line"></span><br><span class="line">推荐使用gettid系统调用的返回值作为线程id。</span><br><span class="line"></span><br><span class="line">#### 线程的创建和销毁的规则</span><br><span class="line"></span><br><span class="line">创建规则：</span><br><span class="line"></span><br><span class="line">* 应该精心规划线程数量，库不能偷偷的创建背景线程，这样也会导致没法安全的fork。</span><br><span class="line">* 用相同的方式创建线程。</span><br><span class="line">* 进入main之前不启动线程。如果不这样，创建的子线程可能访问到未初始化的全局变量。</span><br><span class="line">* 线程的创建最好能在初始化阶段全部完成。</span><br><span class="line"></span><br><span class="line">线程的销毁形式：</span><br><span class="line"></span><br><span class="line">* 自然死亡——从线程主函数返回</span><br><span class="line">* 非自然死亡——主函数抛出异常或者触发segfault信号等。</span><br><span class="line">* 自杀——线程调用`pthread_exit()`</span><br><span class="line">* 他杀——其他线程调用pthread_cancel来终止某个线程</span><br><span class="line"></span><br><span class="line">**避免他杀**：这会导致锁出现很多bug。</span><br><span class="line"></span><br><span class="line">如果想要强行终止一个耗时很长的任务，可以考虑为该任务创建一个新的进程，这样kill该进程会安全很多，前提是不使用共享内存或者跨进程的互斥器等。</span><br><span class="line"></span><br><span class="line">##### pthred_cancel</span><br><span class="line"></span><br><span class="line">如果程序执行到cancellation point这个位置，其他线程调用了pthread_cancel时，该线程可能被终止，通常先会抛出异常，指向 stack unwind。</span><br><span class="line"></span><br><span class="line">##### exit不是线程安全的</span><br><span class="line"></span><br><span class="line">exit除了终止进程，还会析构全局对象和构造完的静态对象，，这可能产生死锁。</span><br><span class="line"></span><br><span class="line">可以使用_exit()代替，他不会析构全局对象，也不会执行其他清理工作。</span><br><span class="line"></span><br><span class="line">#### 善用__thread关键词（C++11可以用thread_local替代）</span><br><span class="line"></span><br><span class="line">`__thread`是gcc内置的**线程局部存储设施**，可以修饰全局、静态变量，但不能修饰class类型、局部变量等。`__thread`变量的初始化只能用编译期常量。`__thread`是**每一个线程都有一个独立实体**。</span><br><span class="line"></span><br><span class="line">&#123;% asset_img image-20250411103123081.png image-20250411103123081 %&#125;</span><br><span class="line"></span><br><span class="line">#### 多线程&amp;IO</span><br><span class="line"></span><br><span class="line">对于epollfd的修改，可能已经有线程wait在epollfd上，这时某个线程对epollfd进行修改，</span><br><span class="line"></span><br><span class="line">可以把对epollfd的操作都放到同一个线程执行。（epollfd如果被多个线程写、监听，可能导致不一致）</span><br><span class="line"></span><br><span class="line">尽量让单个单个线程独占的读写一个文件描述符。（pread和pwrite可以从指定的偏移量读写， UDP也可以，因为消息是彼此独立的）</span><br><span class="line"></span><br><span class="line">#### 用RAII包装文件描述符</span><br><span class="line"></span><br><span class="line">POSIX要求每次打开文件的时候必须使用最小可用的文件描述符号码。</span><br><span class="line"></span><br><span class="line">避免多线程对单个文件描述符进行操作。比如A线程读fd6，B线程关闭fd6，C线程打开了新的fd6。这样A会读到错误的文件。</span><br><span class="line"></span><br><span class="line">如何解决这个问题：使用RAII，用socket对象包装文件描述符，**所有对文件描述符的操作都通过socket对象进行访问**。（对象在则文件描述符在，对象不在则文件描述符不在）</span><br><span class="line"></span><br><span class="line">服务端程序不应该关闭标准输出和标准错误，而是将stdout和stderr重定向到磁盘文件（最好不要是`/dev/null`）。</span><br><span class="line"></span><br><span class="line">（客户端关闭连接时，TCPConnection对象不应该立刻被关闭，因为这会导致其中的socket对象被关闭。）</span><br><span class="line"></span><br><span class="line">#### RAII和fork</span><br><span class="line"></span><br><span class="line">通常使用对象保存资源，**将资源管理和对象生命周期关联起来**（RAII）;</span><br><span class="line"></span><br><span class="line">&gt; 前面提到：如果一个多线程程序使用了锁，一个锁可能被各种线程持有，假如线程A调用fork，而此时线程B持有锁，那么fork后，其实只fork了调用fork函数的子线程——线程A的代码，子进程将不包含线程B，自然没有办法解锁，导致线程A也没法使用。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 解决方法就是：由调用fork的线程在fork前持有所有锁，然后调用fork后，在父子进程中解开所有锁。（这可以防止锁被其他线程持有，导致解不开锁）。可以利用`pthread_atfork`来实现这个方法。</span><br><span class="line"></span><br><span class="line">但是如果程序会fork，这一假设就被破坏了。对象可能构造单次，析构多次。</span><br><span class="line"></span><br><span class="line">fork之后，子进程会继承地址空间和文件描述符，因此fork后，动态内存和文件描述符可以正常使用。但子进程不会继承：</span><br><span class="line"></span><br><span class="line">* 父进程的内存锁，mlock，mlockall</span><br><span class="line">* 父进程文件锁，fcntl</span><br><span class="line">* 父进程的某些定时器，setitimer，alarm，timer_create</span><br><span class="line"></span><br><span class="line">**在编写程序时，是否允许fork需要慎重考虑。**</span><br><span class="line"></span><br><span class="line">#### 多线程和fork</span><br><span class="line"></span><br><span class="line">多线程程序fork后，子进程就相当于处于**signal handler**中（类似于xv6中的中断一样，中断中可以使用spinlock，但绝对不可以使用sleeplock，但用户空间的锁肯定是sleeplock，**所以所有锁都不应该使用**），将没法调用线程安全的函数（因为其他多半需要加锁，但锁很有可能处于失效状态），只能调用**异步信号安全**的函数。比如不能调用：</span><br><span class="line"></span><br><span class="line">* malloc，访问全局状态时需要加锁</span><br><span class="line">* new、map::insert</span><br><span class="line">* 任何pthread函数</span><br><span class="line">* printf函数</span><br><span class="line"></span><br><span class="line">&gt; write也可以先文件描述符写数据，但与printf不同的是，他是异步信号安全的。</span><br><span class="line"></span><br><span class="line">#### 多线程&amp;signal</span><br><span class="line"></span><br><span class="line">信号处理函数中，只能调用**异步信号安全**的函数。</span><br><span class="line"></span><br><span class="line">signal分为两类：</span><br><span class="line"></span><br><span class="line">* 发送给某一线程，SIGSEGV</span><br><span class="line">* 发送给进程中的任一线程，SIGTERM</span><br><span class="line"></span><br><span class="line">多线程程序中，使用signal的第一原则就是不要使用signal，包括</span><br><span class="line"></span><br><span class="line">* 不要使用signal作为IPC的手段，</span><br><span class="line">* 不要使用基于signal实现的定时函数，包括`alarm/ualarm/setitimer/timer_create/sleep/usleep`等。</span><br><span class="line">* 不主动处理各种异常信号（SIGTERM、SIGINT等），只用默认语义，结束进程。有一个例外，SIGPIPE，服务器程序通常需要忽略该信号。（因为我们可能往一个已经关闭的连接中写数据，如果不关闭，则可能导致程序终止）。</span><br><span class="line">* 如果没有其他的替代方法，比如需要处理SIGCHLD信号，那么可以把异步信号转换为同步的文件描述符事件。</span><br><span class="line">  * 比如在signal handler中往一个特定的pipe写一个字节，在主程序中从pipe读取数据，然后处理。</span><br><span class="line">  * 使用signalfd把信号转换为文件描述符事件，从根本上避免使用signal handler。</span><br><span class="line"></span><br><span class="line">#### Linux新增系统调用的启示</span><br><span class="line"></span><br><span class="line">从Linux内核2.6.27开始，凡是会创建文件描述符的syscall都增加了额外的flags参数，可以直接指定O_NONBLOCK和FD_CLOEXEC。</span><br><span class="line"></span><br><span class="line">比如：accept4、eventfd2、inotify_init1、pipe2、signalfd4、timerfd_create。</span><br><span class="line"></span><br><span class="line">以下新系统调用可以在创建文件描述符时开启FD_CLOEXEC选项：</span><br><span class="line"></span><br><span class="line">dup、epoll_create、socket, 这个标志FD_CLOEXEC可以在程序执行exec时自动关闭这个文件描述符。</span><br><span class="line"></span><br><span class="line">上面的八个函数都支持FD_CLOEXEC参数，就是为了避免fork+exec之间的文件描述符泄露。</span><br><span class="line"></span><br><span class="line">#### tips：</span><br><span class="line"></span><br><span class="line">* 每个线程要有确定的职责，</span><br><span class="line">* 线程之间的交互尽量简单，使用消息队列传递消息，一个线程避免使用两把或更多的锁，</span><br><span class="line"></span><br><span class="line">### 高效的多线程日志</span><br><span class="line"></span><br><span class="line">日志有两个意思：</span><br><span class="line"></span><br><span class="line">* 诊断日志，即log4j、logback等日志库提供的日志功能</span><br><span class="line">* 交易日志，如数据库的write-ahead log，文件系统的journaling等，用于记录状态变更，保证事务的**原子性**。</span><br><span class="line"></span><br><span class="line">本文主要针对第一个日志。在生产环境中需要做到Log Everything All The Time。对于关键进程，日志通常需要记录：</span><br><span class="line"></span><br><span class="line">* 收到的每个内部消息的id（还可以包括关键字段、长度、hash）。</span><br><span class="line">* 收到的每条外部消息的全文。</span><br><span class="line">* 发出的每个消息的全文，每个消息都有全局唯一的`id`。</span><br><span class="line">* 关键内部状态的变更。</span><br><span class="line"></span><br><span class="line">日志库可分为前端（frontend）和后端（backend）两部分，前端是供用户程序使用的接口，并生成日志消息；后端负责将日志写到目的地。</span><br><span class="line"></span><br><span class="line">如何将日志数据从多个前端传输到后端是一个典型的多生产者-但消费者问题。</span><br><span class="line"></span><br><span class="line">* 对生产者而言，要做到低延迟、低CPU开销、无阻塞</span><br><span class="line">* 对消费者而言，要做到足够大的吞吐量，并占用较少资源。</span><br><span class="line"></span><br><span class="line">C++的日志库前端大致有两种API风格：</span><br><span class="line"></span><br><span class="line">* C/Java的printf(fmt, ...)风格，例如`log_info(&quot;Received %d bytes from %s.&quot; len, getClientName().c_str())`;</span><br><span class="line">* C++的stream&lt;&lt;风格，例如`LOG_INFO &lt;&lt; &quot;Received&quot; &lt;&lt; len &lt;&lt; &quot;bytes from&quot; &lt;&lt; getClientName();`</span><br><span class="line"></span><br><span class="line">muduo日志库是C++ stream风格，这样用起来更自然，不用考虑保持格式字符串与参数类型的一致性。</span><br><span class="line"></span><br><span class="line">#### 功能需求</span><br><span class="line"></span><br><span class="line">级别：在测试环境使用DEBUG级别的日志，生产环境使用INFO级别的日志。</span><br><span class="line"></span><br><span class="line">对于分布式系统的进程而言，日志的目的地只有一个：本地文件。应该避免向网络文件系统写日志，避免故障扩散已经加速带宽消耗。</span><br><span class="line"></span><br><span class="line">日志文件可以根据文件大小以及时间进行滚动。</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line"></span><br><span class="line">`logfile_test.20250411-191150.hostname.3605.log`</span><br><span class="line"></span><br><span class="line">* logfile_test，是进程名字，通常是main函数argv[0]的basename。</span><br><span class="line">* 时间，可以使用通配符`*.20250411-19*`来选择一段时间的日志。</span><br><span class="line">* 机器的主机名</span><br><span class="line">* 进程id</span><br><span class="line">* 统一后缀</span><br><span class="line"></span><br><span class="line">日志文件压缩和归档不是日志库应有的功能，应该交给专门的脚本去做，</span><br><span class="line"></span><br><span class="line">日志存在一个问题，程序崩溃前，最后几条日志很可能丢失，解决方法：</span><br><span class="line"></span><br><span class="line">* 定期（3秒）将缓冲区的日志消息flush到硬盘</span><br><span class="line">* 每条内存中的日志消息都带有cokkie，其值为某个函数的地址，可以在core dump文件查找cokkie来找到尚未写入磁盘的消息。</span><br><span class="line"></span><br><span class="line">日志的默认格式：</span><br><span class="line"></span><br><span class="line">&#123;% asset_img image-20250412114806297.png image-20250412114806297 %&#125;</span><br><span class="line"></span><br><span class="line">* 每个日志占一行——便于使用awk、sed、grep等工具分析日志，比如`grep -o &quot;2025-03-24T14:22:..&quot; .test.log | sort | uniq -c`</span><br><span class="line"></span><br><span class="line">* 时间戳精确到微秒，每个消息都通过gettimeofday来获取当前时间，该函数不涉及系统调用。</span><br><span class="line"></span><br><span class="line">* 使用GMT时区，（GMT是本初子午线上的标准时间——唯一，UTC时间以附近的经线确定时间，每15度是一个不同的时区差一个小时，正午确定为12点。比如北京是UTC+8, 东京是UTC+9, 所以北京10点时，东京是11点）</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">#### 性能需求</span><br><span class="line"></span><br><span class="line">写的速度应该足够快，这样占用工作线程时间才足够短。</span><br><span class="line"></span><br><span class="line">优化措施：</span><br><span class="line"></span><br><span class="line">* 一秒之内的多条日志只初始化微妙部分</span><br><span class="line">* 前四个字段定长，可以避免运行期求字符串长度。</span><br><span class="line">* 线程id预先格式化为字符串</span><br><span class="line">* 每行消息的源文件名使用编译器计算得来的basename。</span><br><span class="line"></span><br><span class="line">#### 多线程异步日志</span><br><span class="line"></span><br><span class="line">异步日志：一个background负责收集日志，写入日志文件，其他业务线程负责往这个日志线程发送日志消息。</span><br><span class="line"></span><br><span class="line">可以使用BlockingQueue，但不用每次产生一条消息都通知接收方。</span><br><span class="line"></span><br><span class="line">muduo日志库使用双缓冲技术。这可以避免新建日志消息的时候等待磁盘文件操作。（如果是单缓冲区，向BlockingQueue写新消息时，如果日志线程正在往磁盘写数据，需要等待写完磁盘）前端将日志消息拼成一个大的buffer发给后端，避免了每次有消息就唤醒。即使buffer未满，日志库每3秒也会执行一次上述操作。</span><br><span class="line"></span><br><span class="line">AsyncLog基本思路：</span><br><span class="line"></span><br><span class="line">前端有两个buffer，可以直接使用，不够时会从系统申请新的buffer，所有写完的buffer都放到队列buffers_中。</span><br><span class="line"></span><br><span class="line">后端在获得锁之后，会将前端的两个buffer换为空的buffer，buffers_队列也使用一个新的队列代替，释放锁，再来慢慢的从buffer往文件写数据。</span><br><span class="line"></span><br><span class="line">**整个临界区中，对锁的访问是非常快的，基本不涉及任何内存分配任务。**</span><br><span class="line"></span><br><span class="line">##### 关键代码</span><br><span class="line"></span><br><span class="line">前端速度超过后端：</span><br><span class="line"></span><br><span class="line">对于同步IO，会导致前端速度减慢。</span><br><span class="line"></span><br><span class="line">对于异步IO，会导致内存堆叠大量数据引发性能问题，可以直接丢弃。</span><br><span class="line"></span><br><span class="line">**第二部分**</span><br><span class="line"></span><br><span class="line">### muduo网络库</span><br><span class="line"></span><br><span class="line">* 基于对象——支持使用对象的编程范式，但不支持继承、多态等特性。</span><br><span class="line">* 面对对象——完整的编程范式——封装、继承、多态。</span><br><span class="line"></span><br><span class="line">&gt; 多态</span><br><span class="line">&gt;</span><br><span class="line">&gt; * 编译时多态，实现方式：函数重载，运算符重载，模板</span><br><span class="line">&gt; * 运行时多态，实现方式：虚函数，也可以使用回调函数来模拟。</span><br><span class="line"></span><br><span class="line">#### 常见的并发网络程序设计方案</span><br><span class="line"></span><br><span class="line">##### 单线程Reactor（方案五）</span><br><span class="line"></span><br><span class="line">事件循环所在的线程称为IO线程。（避免在事件循环中执行耗时的操作）</span><br><span class="line"></span><br><span class="line">书中给出的`server_basic.cc`程序，网络库负责数据收发，程序只关注业务逻辑。</span><br><span class="line"></span><br><span class="line">##### Reactor+线程池（方案八）</span><br><span class="line"></span><br><span class="line">&gt; linux高性能服务器认为IO线程不需要从socket读写数据。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 而本书以及一些blog认为IO线程不仅需要检测数据是否到达，还需要读取数据打包给工作线程。</span><br><span class="line"></span><br><span class="line">可以将耗时任务交给工作线程处理，避免IO线程阻塞。</span><br><span class="line"></span><br><span class="line">&#123;% asset_img image-20250608162719685.png image-20250608162719685 %&#125;</span><br><span class="line"></span><br><span class="line">##### Reactor in threads（方案九）</span><br><span class="line"></span><br><span class="line">&gt; muduo 内置的多线程方案，没有使用线程池，而是使用Reactor 池。</span><br><span class="line"></span><br><span class="line">有一个 main Reactor 负责accept连接，然后将连接挂在某个sub Reactor 中，然后由sub Reactor 负责检测该连接数据是否到达，以及读写数据（这里都靠sub Reactor完成数据读写而不是线程池中的线程）。</span><br><span class="line"></span><br><span class="line">&#123;% asset_img image-20250608162731698.png image-20250608162731698 %&#125;</span><br><span class="line"></span><br><span class="line">&gt; 使用多个event loop可以处理不同优先级的连接。使用单个event loop可能导致高优先级的连接不能及时得到处理。</span><br><span class="line"></span><br><span class="line">### muduo编程示例</span><br><span class="line"></span><br><span class="line">#### 5个简单的TCP示例</span><br><span class="line"></span><br><span class="line">echo，discard，chargen，daytime，time</span><br><span class="line"></span><br><span class="line">&gt; 关于字符串数组的退化，在传参数时，如果形参为char*，字符串数组自动退化为字符串指针，为了避免这种情况，形参可以参考下面的getCharArray，这样，利用模板自动匹配字符数组，还可以直接获取字符串数组的长度。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>#include<iostream><br>#include<vector><br>using namespace std;<br>template<int n><br>void getCharArray(const char (&amp;arr)[N]){<br> std::cout&lt;&lt;”[ztj]:”&lt;&lt;arr&lt;&lt;endl&lt;&lt;N;<br>}<br>int main(){<br> int N &#x3D; 3;<br> std::cout &lt;&lt; <strong>FILE</strong> &lt;&lt; endl;<br> const char * src1 &#x3D; “hello world!”;<br> &#x2F;&#x2F;getCharArray(src1);<br> getCharArray(“hello world!”);<br> return 0;<br>};</int></vector></iostream></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">shared_from_this():</span><br><span class="line"></span><br><span class="line">该函数是std::enable_shared_from_this&lt;T&gt;类提供的一个成员函数，可以通过继承获得。[深入理解](https://blog.csdn.net/qq_21438461/article/details/142532830)</span><br><span class="line"></span><br><span class="line">非阻塞网络编程使用应用层缓冲区的**一个原因**：数据可以随时到达，到达一部分后，如果剩下的部分没有到达，则可以放任数据留在应用层缓冲区中。</span><br><span class="line"></span><br><span class="line">#### 文件传输</span><br><span class="line"></span><br><span class="line">fopen与open，fopen是对open的封装，可以提供缓冲（通过setbuffer开闭）。当需要读取的数据量很大时，可以考虑增大缓冲区，减少调用open系统调用的次数。（因为采用fopen默认缓冲区大小的话，可能导致多次read）</span><br><span class="line"></span><br><span class="line">fread原理：每次 `fread` 都会尝试从这个用户缓冲区中读取数据，只有当缓冲区为空时，才会进行底层的系统调用read来填充缓冲区。</span><br><span class="line"></span><br><span class="line">TCP连接是双工的，某一端只能主动关闭自己的写端，读端要等到read返回0才关闭。</span><br><span class="line"></span><br><span class="line">#### Boost.Asio的聊天服务器</span><br><span class="line"></span><br><span class="line">##### TCP分包</span><br><span class="line"></span><br><span class="line">即如何让接收方从字节流中识别出一个个消息。</span><br><span class="line"></span><br><span class="line">针对短连接而言，read返回0则代表消息的结尾。</span><br><span class="line"></span><br><span class="line">针对长连接而言，分包有如下方法：</span><br><span class="line"></span><br><span class="line">* 固定的消息长度，比如muduo的roundtrip使用了固定的16字节消息。</span><br><span class="line">* 使用特殊的字符或者字符串作为消息的边界，比如HTTP的协议的headers以`\r\n`为字段的分隔符。</span><br><span class="line">* 在每条消息的头部加上一个长度字段——常见的作法。</span><br><span class="line">* 利用消息本身的格式来分包，比如XML格式中&lt;root&gt;...&lt;/root&gt;的配对。（感觉和方法而很像，都是利用预定的符号来判断结尾 ）</span><br><span class="line"></span><br><span class="line">文中提到了，新旧两个进程可以使用同一个连接，导致出错的事情，但这个事情不是已经被TCP层的timewait解决了吗。</span><br><span class="line"></span><br><span class="line">##### 消息格式</span><br><span class="line"></span><br><span class="line">针对多线程服务器，可能有多个线程都会访问CharServer的onconnection函数以及onstringmessage函数，为了保持一致，文中给出了几种方案：（p203）</span><br><span class="line"></span><br><span class="line">* server_threaded版本，使用mutex保存ConnectionList列表，但需要读写该列表时，都需要先加互斥锁</span><br><span class="line">* server_threaded_efficient版本，创建一个ConnectionListPtr类型的shared_ptr指向上面的列表，这样，使用时，都使用这个智能指针，这里也需要使用mutex，但这里的mutex只保护智能指针，不需要保护指针指向的列表（虽然也可以保护，但会降低一点并发性）。当需要访问列表时，先申请互斥锁，但需要改变指针指向的列表时，发现指针引用不为1，则直接使用shared_ptr.reset来改变指针的指向（mutex正是保护这个的），否则直接修改列表。（copy-on-write手法）</span><br><span class="line">* server_threaded_highperformance版本，使用ThreadLocalSingleton创建一个每个线程独有的connection列表，通过 distributeMessage 将消息分发到各个线程的 EventLoop 中，再由每个线程分发给自己的connection。</span><br><span class="line"></span><br><span class="line">第二种方法已经被广泛应用了。shared_ptr + mutex + cow写时复制，对于多读少写的场景非常高效，而对于高写场景，cow会被频繁复制，代价较高。</span><br><span class="line"></span><br><span class="line">如果目标是高并发写，则可以考虑写操作不共享内存，每个线程写各自的vector，感觉和方案三很像。有个缺陷是但需要全局寻找connection时，很低效。</span><br><span class="line"></span><br><span class="line">#### muduo Buffer类</span><br><span class="line"></span><br><span class="line">Linux上的典型的五种**IO模型**，阻塞IO，非阻塞IO，IO多路复用，信号驱动，异步。</span><br><span class="line"></span><br><span class="line">**多核时代，如何选择线程模型呢：one loop per thread总是一个好的模型。使用one loop per thread的话，多线程服务器编程的问题就简化为如何设计一个高效的event loop ，然后每一个线程run一个就行了。event loop是 non-blocking网络编程的核心，non-blocking 几乎总是和IO multiplexing一起使用。**</span><br><span class="line"></span><br><span class="line">##### 为什么非阻塞网络编程中的应用层buffer是必要的</span><br><span class="line"></span><br><span class="line">非阻塞 `IO`的核心思想是避免阻塞在`read`和`write`或其他`IO`系统调用上.`IO`线程只能阻塞在`IO`复用函数上，如`select/poll/epoll_wait`。这样一来，应用层的缓冲区是必须的，每个`TCP ``socket`都要有 `stateful` 的`input buffer`。</span><br><span class="line"></span><br><span class="line">**TCP conn要有输出buffer**：比如当对方滑动窗口已满时，（socket层的buffer也已满时），多余的数据会暂存在应用层buffer中。当socket变得可写时，就应该立刻发送数据。（反正应用层不需要关注这些事情，它可以保证conn send立刻返回）。当调用conn::send后，缓冲区的数据没有发送完毕时，又调用了conn::shutdown时，不会直接关闭TCP连接，而是要等数据发送完毕。</span><br><span class="line"></span><br><span class="line">**TCP conn要有输入buffer**：接收数据时，长度为n字节的数据分块到达的可能性有`2**n`种，当socket可读时，应该一次性从系统buffer搬到应用层buffer，否则会不断触发POLLIN事件（水平触发）或者不触发POLLIN事件（边沿触发）。</span><br><span class="line"></span><br><span class="line">##### buffer的功能需求</span><br><span class="line"></span><br><span class="line">* 对外表现为连续的内存</span><br><span class="line">* 大小可以自动增长</span><br><span class="line">* 内部以`vector&lt;char&gt;`保存数据</span><br><span class="line"></span><br><span class="line">就像一个queue一样。buffer的大小需要慎重考虑，buffer太小，遇到大的数据时需要频繁分配内存（产生系统调用），buffer太小，资源浪费太大。muduo的做法是利用一个64KB的栈上extrabuf，当数据太大时，会将多余的数据读到该预期，然后写到buffer中。</span><br><span class="line"></span><br><span class="line">**线程安全吗**：非线程安全的，</span><br><span class="line"></span><br><span class="line">* 对于input buffer，**onMessage回调也应该发生在TCP conn所属的那个IO线程**，应用程序也应该在onMessage中完成对input buffer的操作。这样就不会导致多个线程访问同一个conn的资源。（每个连接的buffer只能被同一个线程访问）</span><br><span class="line">* 对于output buffer，应用程序只是调用send来发送。</span><br><span class="line"></span><br><span class="line">在代码中，使用asserInloopThread来保证在相同线程中访问。</span><br><span class="line"></span><br><span class="line">##### Buffer的数据结构</span><br><span class="line"></span><br><span class="line">其内部结构是vector，导致其有个机制是capacity，可以减少分配的次数。</span><br><span class="line"></span><br><span class="line">内部腾挪：当readIndex移到了靠后的位置时，可以将已有的数据移到前面去。</span><br><span class="line"></span><br><span class="line">优化方法：可以考虑使用不连续的内存，提升性能。</span><br><span class="line"></span><br><span class="line">##### 性能不是问题</span><br><span class="line"></span><br><span class="line">与其优化这点性能，不如优化数据库查询。</span><br><span class="line"></span><br><span class="line">如果发现项目中，带宽仍然是瓶颈，那么说明该应用太critical，应该考虑把数据复制放到Linux kernel中去，才能实现 zero copy。或者尝试写新的kernel，或者使用FPGA操作。</span><br><span class="line"></span><br><span class="line">#### 一种自动反射消息类型的Protobuf网络传输方案</span><br><span class="line"></span><br><span class="line">反射机制：在不知道类的具体结构时，可以通过统一的接口动态的访问和操作消息中的字段。</span><br><span class="line"></span><br><span class="line">##### 使用protobuf的先决条件</span><br><span class="line"></span><br><span class="line">长度如何处理——在消息前面加上长度信息或者终结符。</span><br><span class="line"></span><br><span class="line">类型——protobuf打包的数据没有类型信息，需要由发送方把类型信息传给接收方，接收方创建具体的Message对象，再做反序列化。还有另一种解决方式，传输数据时，加上一个typename，接收方根据这个typename来找对应的Message对象。</span><br><span class="line"></span><br><span class="line">其实portobuf已经提供了解决方案。</span><br><span class="line"></span><br><span class="line">##### 根据type name 反射自动创建Message对象</span><br><span class="line"></span><br><span class="line">protobuf具有很强的反射功能，可以根据type name 创建具体类型的message。</span><br><span class="line"></span><br><span class="line">protocal： 协议；</span><br><span class="line"></span><br><span class="line">prototype：原型模式，用已有对象作为原型，通过克隆生成新对象（适合不知道具体类型的场景）。</span><br><span class="line"></span><br><span class="line">cmake几种查看库文件的机制：（而bazel不会使用系统路径中的库文件，而是自己维护着所有的头文件库文件，保证一致性。也就是说系统路径中的库文件只对cmake等工具编译的文件有影响）</span><br><span class="line"></span><br><span class="line">* find_package，优先查找`&lt;PackageName&gt;Config.cmake`脚本或者`Find&lt;PackageName&gt;.cmake`，查找路径是什么呢，分为几种查找方式：</span><br><span class="line">  * 显示指定，比如`find_package(Foo Paths /opt/foo /usr/local/foo）`</span><br><span class="line">  * 通过CMAKE_PREFIX_PATH查找**</span><br><span class="line">  * 通过CMAKE_INSTALL_PREFIX查找（优先级：命令行&gt;文件内&gt;CMakeCache&gt;默认值，注意cmake不会使用环境变量中的CMAKE_INSTALL_PREFIX）</span><br><span class="line">  * 通过系统路径查找</span><br><span class="line">* pkg-config，一些老旧小项目会提供`.pc`文件</span><br><span class="line">  * 通过环境变量 `PKG_CONFIG_PATH`查找</span><br><span class="line">  * 默认路径</span><br><span class="line"></span><br><span class="line">cmake的两种构建流程：</span><br><span class="line"></span><br><span class="line">之前都习惯使用简单的方式`cmake ..;make;make install`但是这样不现代化，会污染目录。推荐用下面的方式：</span><br><span class="line"></span><br><span class="line">`cmake -S . -B build -Dxxx=xxx;cmake --build build;cmake --install build --prefix /path`</span><br><span class="line"></span><br><span class="line">`-S`指定源码目录，`-B`指定构建目录，实现源码与构建分离，cmake --build，即执行并发编译，平台无关；cmake --install执行安装。（一些bugs可以参看[bug记录](https://tjzhang-src.github.io/.github.io/2023/04/11/bug记录/)）</span><br><span class="line"></span><br><span class="line">感觉使用bazel比cmake方便，不用手动管理很多库，而且cmake还无法处理依赖的依赖，，当前也可能是absl没法自动加载。</span><br><span class="line"></span><br><span class="line">&#123;% asset_img 664c73683b8d2455380258a7.jpeg img %&#125;</span><br><span class="line"></span><br><span class="line">根据typename自动创建Message，使用了单例模式，来访问一个类的唯一一个对象，比如DescriptorPool（获取描述符），MessageFactory对象（获取Message对象）。然后通过获得到的这个Messsage单例对象内部函数创建新对象（原型模式）。（整体看下来，除了往pool中注册对象时需要使用Message的名字，其他时候都不需要使用该名字）</span><br><span class="line"></span><br><span class="line">##### 传输格式</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>struct{<br>    int32 len;<br>    int32 namelen;<br>    char typename[namelen];<br>    char protobufData[len-namelen-8];<br>    int32 checkSum;<br>}</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 在muduo实现protobuf编解码器和分发器</span><br><span class="line"></span><br><span class="line">为什么protobuf不需要再文件中包含消息的长度和类型。因为很多情况下都不需要在数据内部存储数据的类型和大小，比如当把这个消息以UDP方式发给对方时，根据端口类型可以知道类型，根据udp packet可以知道长度。（以长连接TCP发送时，可能不知道长度，因为没办法把多个数据分开，其他很多情况下都不需要保存类型和大小，以节约资源）把数据分开需要使用分发器dispatcher。</span><br><span class="line"></span><br><span class="line">##### 编解码器（codec）</span><br><span class="line"></span><br><span class="line">&gt; non-trivial——重要的</span><br><span class="line"></span><br><span class="line">这里tcpconnection收到的消息会交给protobufcodec进行解析，收到完整的消息在传给server。</span><br><span class="line"></span><br><span class="line">&#123;% asset_img image-20250625204734247.png image-20250625204734247 %&#125;</span><br><span class="line"></span><br><span class="line">##### 实现protobufcodec</span><br><span class="line"></span><br><span class="line">见`examples/protobuf/codec/codec.cc`,主要实现对从tcpconnection收到的数据的一个编解码，然后以messagePtr的形式传递给server使用。但是server还必须要根据消息类型来决定如何处理，如果在protobufcodec层有一个消息分发器就好了。</span><br><span class="line"></span><br><span class="line">##### 消息分发器的作用</span><br><span class="line"></span><br><span class="line">作为protobufcodec和server的中间部分，分发message到不同的回调函数中去。</span><br><span class="line"></span><br><span class="line">&#123;% asset_img image-20250625212936380.png image-20250625212936380 %&#125;</span><br><span class="line"></span><br><span class="line">&gt; C++11关键字：static_assert（bool常量表达式，字符串字面量），失败时会显示字面量。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 类型萃取工具：is_base_of(Base, Derived), 判断A是否是B的基类。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 当访问一个含有模板参数的模板类中的某个类型时，需要在前面加上typename，因为编译器没法获取该类型的内部信息。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 模板编译时的两阶段查找：</span><br><span class="line">&gt;</span><br><span class="line">&gt; * 先检查与模板参数无关的成员</span><br><span class="line">&gt; * 在实例化模板时，对非独立的成员进行检查。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 可以参考如下的例子：在一阶段时，还不会实例化模板，即不会产生A\&lt;T\&gt;的具体定义，那么B就不知道会从基类中继承什么，将a变为this-&gt;a,就能够让a变为非独立的成员，从而在二阶段进行检查。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>#include<iostream><br>using namespace std;<br>template <class t><br>class A {<br>protected:<br>    int a;<br>};<br>template <class t><br>class B : public A<T> {<br>public:<br>    void foo() {<br>        a &#x3D; 0;&#x2F;&#x2F;error: ‘a’ was not declared in this scope<br>    }<br>};<br>int main() {<br>    B<int> b;<br>    b.foo();<br>    return 0;<br>}</int></T></class></class></iostream></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在 Debug 模式你使用dynamic_cast,能立刻发现类型错了，但 Release 模式你可以使用static_cast, 信任程序不会错、直接跑更快。</span><br><span class="line"></span><br><span class="line">类型擦除：把不同类型的对象包装成一个统一的基类接口，以便于在不知道具体类型的情况下进行处理，在运行时再复原类型并调用正确逻辑。</span><br><span class="line"></span><br><span class="line">- `CallbackT&lt;T&gt;` 擦除了类型 `T`，以统一形式存入 `std::map&lt;Descriptor*, Callback*&gt;`。</span><br><span class="line">- 然后在 `onMessage` 中通过 `down_pointer_cast&lt;T&gt;` 恢复类型。</span><br><span class="line"></span><br><span class="line">#### 限制服务器的并发连接数</span><br><span class="line"></span><br><span class="line">##### 为什么要限制并发连接数</span><br><span class="line"></span><br><span class="line">现在代码中很多都是对TCP层进行操作的，服务端建立好TCP连接后让其放入全连接队列，等待accept的读取，socket内核对象是在三次握手完成的时候就建立了，accept会将这个对象取出来，为其分配一个新的文件描述符给用户态使用（内核应该不用文件描述符，可以直接访问）。客户端通过connect连接TCP连接，建立后返回。</span><br><span class="line"></span><br><span class="line">如果进程文件描述符达到上限，那么accept不会从listenfd对应的队列中移除已成功建立的连接，导致一直触发可读事件。</span><br><span class="line"></span><br><span class="line">如何限制文件描述符数量：</span><br><span class="line"></span><br><span class="line">* 提高数据、死等、退出程序、关闭listen fd。</span><br><span class="line">* 使用edge trigger，漏掉一次后就不会产生该信号了。</span><br><span class="line">* 准备一个空的文件描述符，先关闭这个空闲文件，然后用这个空的文件描述符建立连接后，立刻断开连接。（muduo使用的方式）</span><br><span class="line">* 如果系统的limit是1024那么就建立一个soft limit，超过1000就关闭连接。（感觉这个很优秀呢）</span><br><span class="line"></span><br><span class="line">死等和edge trigger都在TCP层面建立了连接，而客户端不知道也不需要知道服务器端是否能够处理该连接（因为服务器程序没有拿到文件描述符）。</span><br><span class="line"></span><br><span class="line">##### 在muduo中限制并发连接数</span><br><span class="line"></span><br><span class="line">在server中加上一个int或者Atomicint成员，超过一定计数则终止连接。</span><br><span class="line"></span><br><span class="line">i++在编译器看来会执行`mov xxx [i], add xxx, 1, move [i],xxx`三条指令，这中间随时可能被中断。</span><br><span class="line"></span><br><span class="line">L1 Cache通常是每个核心私有的，通过虚拟地址进行访问。其他两个Cache通过地址转换后，通过物理地址进行访问。</span><br><span class="line"></span><br><span class="line">#### 定时器</span><br><span class="line"></span><br><span class="line">与时间相关的任务：</span><br><span class="line"></span><br><span class="line">* 获取当前时间，计算时间间隔。</span><br><span class="line">* 时区转换与时期计算。</span><br><span class="line">* 定时操作。</span><br><span class="line"></span><br><span class="line">##### 时间函数</span><br><span class="line"></span><br><span class="line">数据对各种时间函数进行了取舍，</span><br><span class="line"></span><br><span class="line">* 计时使用gettimeofday（当使用glibc库时，会通过VDSO机制避免陷入内核态）其他方法要么开销大要么精度低。（微秒定时）</span><br><span class="line">* 定时使用timerfd_*系列函数来处理定时任务。</span><br><span class="line"> * 避免使用sleep/alarm/usleep函数，他们可能使用了SIGALRM信号，而很多信号是针对进程的，一个进程中的所有线程都可以接收某个信号。要避免在多线程程序使用信号。</span><br><span class="line"> * nanosleep和clock_nanosleep是线程安全的，但会让当前线程挂起，但在非阻塞网络编程中，不应该出现这种会让线程等一段时间的行为，所有函数都应该立刻返回，可以考虑使用使用回调函数来实现。</span><br><span class="line"> * 传统的reactor利用epoll实现的定时，精度只有毫秒。</span><br><span class="line"></span><br><span class="line">eventloop有三个回调函数：runAt，runAfter，runEvery来执行对应的回调函数。</span><br><span class="line"></span><br><span class="line">##### Boost.Asio 定时器的实现</span><br><span class="line"></span><br><span class="line">通过在python中通过subprocess调用bash脚本，在bash脚本中将输出重定向到一个文件中，可能发现文件中的内容出现的很慢，可以考虑在命令前加上`stdbuf -oL`来关闭缓冲区，</span><br><span class="line"></span><br><span class="line">ntp协议：校准本机的时间，使其接近时间服务器的时间。两个重要的计算公式：</span><br><span class="line"></span><br><span class="line">* delay=(T4−T3)+(T2−1)，计算的是包在网络中传输花费的时间。</span><br><span class="line">* offset=((T2+T3-T1−T4))/2，这里使用**时间服务器的时间**减去客户端的时间，如果包在网络中收发的时间是相等的，可以通过这个式子计算出两者之间的时间差。（比如T1=100，T2=201， T3=202，T4= 103，假设包在发送和接收的时间都是一致的，都是1，这里可以计算出客户端与时间服务器的时间差为100）</span><br><span class="line"></span><br><span class="line">nagle是TCP网络中为了提高网络吞吐量并减小小数据包从而设计的算法。</span><br><span class="line"></span><br><span class="line">### Time 踢掉空闲连接</span><br><span class="line"></span><br><span class="line">如何踢掉空闲连接(比如说8秒无消息的连接立刻断开):</span><br><span class="line"></span><br><span class="line">* 可以每隔一秒，对**所有的连接**进行一次检查，断开8秒都没有收发消息的。（缺点是遍历的成本太高了）</span><br><span class="line">* 为每个连接设置一个定时器，超时为8s，超时则断开。（缺点是对定时器的需求大）</span><br><span class="line"></span><br><span class="line">可以使用timing wheel来解决：一共有8个集合，分别装着将要在1，2，3直到8秒过期的连接，这样只需要8个定时器，也可以避免遍历大量的Conn连接。</span><br><span class="line"></span><br><span class="line">这里面使用了大量的weakptr和sharedptr来处理问题。</span><br><span class="line"></span><br><span class="line">* 首先将一个conn连接用一个Entry来表示，Entry使用一个指向Conn的虚指针来初始化（避免使用shared_ptr,这会导致Conn引用计数无法归零无法析构），Entry析构时，会导致Conn连接关闭。</span><br><span class="line">* 在Server类中，使用若干个bucket来保存不同时间的Entry的shared_ptr。（为什么需要使用shared_ptr, 因为这里确实**需要强引用来计数**，因为可能出现一个conn的entry被插入到多次）在loop注册一个每秒的定时器，来删除最旧的bucket，进而删除其中的shared_ptr,导致其指向对象的计数减一，归零则导致conn被关闭。</span><br><span class="line">* 其实conn的内部变量也保存了指向对应的Entry的weak指针。(注意：使用share_ptr相互引用是绝对不允许的，因为这影响了两者的生命周期，当weakptr可以，他对两者的**生命周期没有任何影响**)</span><br><span class="line"></span><br><span class="line">splice: 把某些元素从一个 `list` 中“剪切”下来，**不拷贝，不构造，不析构**，然后“粘贴”到另一个位置。</span><br><span class="line"></span><br><span class="line">##### 消息广播服务</span><br><span class="line"></span><br><span class="line">snapshot &amp; delta, 通常出现在谈论**数据同步**中，snapshot是某一时刻完整的数据副本，delta只保存自上一状态以来的变化部分。（这么看来使用snapshot要稍微可靠一点）</span><br><span class="line"></span><br><span class="line">如何实现高效广播：比如服务器要发消息给一千个订阅者，单线程只能一个一个的发，可以使用多线程，当要考虑如何避免全局锁的使用。还可以参考`server_threaded_highperformance.cc`的做法，创建thread_local变量，将某个订阅者交给某个线程单独管理。</span><br><span class="line"></span><br><span class="line">为什么有些函数需要使用const &amp;来进行传递：</span><br><span class="line"></span><br><span class="line">* 普通函数不包含资源，无需使用这种方式。</span><br><span class="line">* 函数对象以及有捕获的lambda表达式包含资源，使用const &amp;可以节省复制开销。</span><br><span class="line"></span><br><span class="line">实现了hub，sub，pub后，如果服务器有多个客户端连接，可以考虑使用多个线程提高性能，为了避免锁把多线程变成单线程，可以考虑使用线程局部变量。</span><br><span class="line"></span><br><span class="line">shared_ptr实现cow：(有两个对象需要保护，第一个时shared_ptr对象，第二个是shared_ptr指向的对象，shared_ptr可能被多个线程读写，比如一个线程reset shared_ptr后，另一个线程访问shared_ptr会出现问题。shared_ptr依靠锁来保护自己——只针对需要读写shared_ptr的多个线程——访问shared_ptr变量时需要先加锁。shared_ptr指向的对象可以依靠引用计数)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>#include <memory><br>#include <vector><br>#include <mutex><br>&#x2F;&#x2F; 共享资源<br>std::shared_ptr&lt;std::vector<int>&gt; g_vptr;<br>&#x2F;&#x2F; 该互斥锁只用来保证访问shared_ptr时的线程安全<br>&#x2F;&#x2F; 读写std::vector<int>的线程安全通过shared_ptr的引用计数保证<br>std::mutex g_mutex;<br>void read(){<br> std::shared_ptr&lt;std::vector<int>&gt; vptr;<br> {<br>     std::lock_guard<a href="std::mutex">std::mutex</a> g(g_mutex);<br>     vptr &#x3D; g_vptr;<br> }<br> for(auto i : *vptr){<br>     &#x2F;&#x2F; read<br> }<br>}<br>void write(int data)<br>{<br> std::lock_guard<a href="std::mutex">std::mutex</a> g(g_mutex);<br> if(!g_vptr.unique())<br> {<br>     g_vptr.reset(new std::vector<int>(*g_vptr));<br> }<br> g_vptr-&gt;push_back(data);<br>}</int></int></int></int></mutex></vector></memory></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### 串并转换（多路复用）服务器</span><br><span class="line"></span><br><span class="line">与系统级别的复用方式比如poll和epoll不同，这个Multiplexer 是针对应用层的一个复用方式。</span><br><span class="line"></span><br><span class="line">##### 与其他库集成</span><br><span class="line"></span><br><span class="line">channel：</span><br><span class="line"></span><br><span class="line">### 网络库设计以及实现</span><br><span class="line"></span><br><span class="line">利用`#pragma once`来让头文件只被包含一次。</span><br><span class="line"></span><br><span class="line">#### Reactor的事件分发机制</span><br><span class="line"></span><br><span class="line">将IO multiplexing拿到的IO事件分发给各个文件描述符的处理函数。</span><br><span class="line"></span><br><span class="line">##### channel class</span><br><span class="line"></span><br><span class="line">每个channel对象只负责一个文件描述符的IO事件分发，一个channel对象只属于一个IO线程。</span><br><span class="line"></span><br><span class="line">关于channel和tcpconn的生命周期，tcpconn拥有channel的unique指针。问题是，channel收到消息后，会调用tcpconn的回调函数，可能导致tcpconn关闭，可能导致channel也被关闭，所以channel中保存了tcpconn的shared_ptr防止tcpconn先die。</span><br><span class="line"></span><br><span class="line">##### Poller class</span><br><span class="line"></span><br><span class="line">Eventloop中包含成员poller，Eventloop拥有Channel（有他的unique指针），poller不拥有channel（只有channel的原始指针）。</span><br><span class="line"></span><br><span class="line">#### TimerQueue 定时器</span><br><span class="line"></span><br><span class="line">可以利用select和poll的等待时间来进行定时。也可以利用linux中的timerfd进行定时。这种方式可以更好的融入到eventloop中。</span><br><span class="line"></span><br><span class="line">如何组织当前未到期的Timer：</span><br><span class="line"></span><br><span class="line">* 按照到期时间排好序的线性表，复杂度O(N)</span><br><span class="line">* 用堆来组织（make_heap）,复杂度O(logN),缺点是没法高效的删除其中的某个元素</span><br><span class="line">* 二叉搜索树(set, map), 操作的复杂度时O(logN), 相比于堆来说内存局部性更差。</span><br><span class="line"></span><br><span class="line">第一次看，怎么muduo的定时器这么畸形。</span><br><span class="line"></span><br><span class="line">* Timer类中包含了关于定时的所有信息，</span><br><span class="line">* TimerId包含了指向Timer的指针以及一个序列号，</span><br><span class="line">* TimerQueue中的Timers包含了所有按照过期时间排序的timers，格式为&lt;Timestamp, Timer*&gt;, 当定时器的文件描述符收到数据时，可以很快的找到前n个过期的定时器。</span><br><span class="line">* TimerQueue中的activeTimers_包含了&lt;Timer*, int64_t&gt;，第二个模板参数是序列号，</span><br><span class="line"></span><br><span class="line">#### runinloop函数</span><br><span class="line"></span><br><span class="line">在IO线程中，平时都等待在poll调用中，为了让IO线程能够立刻指向用户回调，需要唤醒该线程。比较传统的方法是使用pipe，让IO线程持续监视此管道的readable事件，现在可以使用Linux的eventfd文件描述符（不必管理缓冲区，从而实现高效的唤醒）。</span><br><span class="line"></span><br><span class="line">#### 实现TCP网络库</span><br><span class="line"></span><br><span class="line">通过`Acceptor`的构造函数以及`Acceptor::listen`函数来执行创建TCP服务器的传统步骤，即调用socket、bind、listen，这其中如果遇到任何错误都一样终止程序。（很多情况下都是因为端口被占用）</span><br><span class="line"></span><br><span class="line">SO_REUSEADDR可以解决端口复用问题。</span><br><span class="line"></span><br><span class="line">SO_REUSEPORT让多个**socket服务**绑定到同一个端口，比如ssh服务与xrdp服务都绑定到80端口。</span><br><span class="line"></span><br><span class="line">代码中使用`idleFd_(::open(&quot;/dev/null&quot;, O_RDONLY | O_CLOEXEC))`来创建一个无用的文件描述符，这样，当文件描述符用完时，可以关闭该无用的描述符，然后关闭新连接。</span><br><span class="line"></span><br><span class="line">TCP 三次握手由**内核自动完成**，并在 `accept()` 之前就完成了。`accept()` 做的事情是：**从内核中“取出”已完成握手的连接，返回一个新的文件描述符**，交给用户态处理。(文件描述符只是给进程使用的，内核不需要文件描述符)</span><br><span class="line"></span><br><span class="line">在accept之后，可以立刻通过非阻塞的poll进行一次检测，如果连接有问题则立刻断开连接。</span><br><span class="line"></span><br><span class="line">前向声明不需要`#include`对应的头文件，前向声明只是告诉编译器：这个类型存在，但现在我不需要知道它的全部定义</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">/**</span><br><span class="line">* @details要保证在执行这个函数期间，这个channel对象不能被销毁，一旦出了这个函数，</span><br><span class="line">* 就无所谓了</span><br><span class="line">*/</span><br><span class="line">void Channel::handleEvent(Timestamp receiveTime)&#123;</span><br><span class="line"> std::shared_ptr&lt;void&gt; guard;</span><br><span class="line"> if (tied_)&#123;</span><br><span class="line">   //这里主要是因为可能在上层的函数中关闭conn，而关闭channel后，会导致</span><br><span class="line">   //channel也被关闭，这里利用guard来保证conn在此函数作用域内不会被释放。</span><br><span class="line">   guard = tie_.lock();</span><br><span class="line">   if (guard)&#123;</span><br><span class="line">     handleEventWithGuard(receiveTime);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> else&#123;</span><br><span class="line">   handleEventWithGuard(receiveTime);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>删除vector中的元素时，如果其中没有顺序关系，可以将要删除的元素和结尾的元素swap一下，然后pop_back。</p>
</blockquote>
<blockquote>
<p>不知道会收到多少数据，但希望尽可能读取完数据，可以使用buffer+栈内存两块缓冲区通过readv一起读取（栈内存分配快）。</p>
</blockquote>
<blockquote>
<p>高效的唤醒一个线程的思路：</p>
<ul>
<li>利用条件变量，</li>
<li>使用eventfd，（epollfd友好）</li>
<li>futex，必要时才进内核</li>
</ul>
</blockquote>
<h4 id="完善Tcpconnection"><a href="#完善Tcpconnection" class="headerlink" title="完善Tcpconnection"></a>完善Tcpconnection</h4><h5 id="sigpipe"><a href="#sigpipe" class="headerlink" title="sigpipe"></a>sigpipe</h5><p>这个信号的默认操作会kill掉当前进程，应该忽视他。</p>
<h5 id="tcp-no-delay和tcp-keepalive"><a href="#tcp-no-delay和tcp-keepalive" class="headerlink" title="tcp no delay和tcp keepalive"></a>tcp no delay和tcp keepalive</h5><p>前者是禁用Nagle算法，避免发包出现延迟，后者会定期探查TCP连接是否存在。</p>
<p>写buffer数据过多时，可以设计一个高水位回调，用来进行一些优化。</p>
<h4 id="多线程TcpServer"><a href="#多线程TcpServer" class="headerlink" title="多线程TcpServer"></a>多线程TcpServer</h4><p>多线程的情况下，TcpServer和TcpConnection的代码都只处理单线程的情况，（虽然一个线程很可能在其中一个对象中访问到另一个对象，造成冲突），这里利用<code>EventLoop::runinloop</code>来避免这个问题。并且线程切换，ioLoop和loop_之间的切换都只会发生在连接建立关闭的时候。</p>
<h3 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h3><p>单机vs分布式：</p>
<ul>
<li>单机的总线默认是非常可靠的，根据能否使用就能知道某个进程、部分发生了故障。</li>
<li>分布式的网络传输默认是不可靠的，我们无法区分是网络问题还是对方机器故障。</li>
</ul>
<h5 id="分布式系统是个险恶的问题"><a href="#分布式系统是个险恶的问题" class="headerlink" title="分布式系统是个险恶的问题"></a>分布式系统是个险恶的问题</h5><h6 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h6><p>如何判断服务器的负载——根据反应时间，这样可以很大程度上的简化设计。哪怕是多个Web Server，也能做到均衡的负载均衡。</p>
<h6 id="时间和事件违反直觉"><a href="#时间和事件违反直觉" class="headerlink" title="时间和事件违反直觉"></a>时间和事件违反直觉</h6><p>每个观察者有自己的时钟，而且消息传递的延迟是不固定的。</p>
<h4 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h4><p>Tmtbf: 平均无故障运行时间，<br>$$<br>Reliability &#x3D; exp(-t&#x2F;tMTBF)<br>$$<br>平均无故障运行时间不是用来估计<strong>单个部件</strong>什么时候坏的，而是用来估计需要准备多少备用部件。（预测的是一个宏观概率，比如厂家说1000小时有50%的可能出现故障，那么一个部件使用1000小时和1000个部件使用1个小时，都有50%的概率出现故障）</p>
<p>可靠性：数据不丢失的概率。</p>
<p>可用性：可随时使用数据的概率。</p>
<p><code>可用性 = tMTBF/(tMTBF + tMTTR)</code>(tMTTR代表平均修复时间)</p>
<p>这上面讲了很多硬件故障，他和软件故障同时存在，软件的可靠性只需要略高于硬件及操作系统即可。（比如硬件错误一年10次，那么一年出现2次软件错误也无伤大雅）</p>
<p>高可用的关键不是不停机，而是出现故障停机后能立刻恢复。</p>
<h5 id="能随时重启进程作为程序设计目标"><a href="#能随时重启进程作为程序设计目标" class="headerlink" title="能随时重启进程作为程序设计目标"></a>能随时重启进程作为程序设计目标</h5><p>由于可能发生各种故障，导致进程被关闭，所以进程应该具备快速重启的能力。</p>
<p>要能够实现可重启，程序应该使用操作系统能自动回收的IPC，不能使用跨进程的mutex，semaphore，pipe等。</p>
<p>协议设计时应该让客户端在TCP断连后自动重连，（也可能需要检测服务端心跳，并自动failover到备用地址，ps.这么复杂么）。</p>
<p>如何重启：</p>
<ul>
<li>先主动停止一个服务进程心跳<ul>
<li>对于短连接，关闭listen port</li>
<li>对于长连接，客户会自动failover到其他服务端</li>
</ul>
</li>
<li>等一段时间，直到该服务进程没有请求</li>
<li>kill并重启进程</li>
<li>检测新进程的服务是否正常</li>
<li>依次重启服务端剩余进程</li>
</ul>
<blockquote>
<p>这里既要求客户端正确处理心跳以及TCP重连，还要客户端同时兼容新旧版本的协议。</p>
</blockquote>
<h4 id="分布式系统的心跳协议"><a href="#分布式系统的心跳协议" class="headerlink" title="分布式系统的心跳协议"></a>分布式系统的心跳协议</h4><p>Fin报文不能作为对端能否工作的充要条件，需要利用心跳探查对端能否正常工作，TCP的keepalive也有不足，例如对端进程阻塞，但是操作系统仍然能够处理TCP的keepalive。</p>
<p>心跳由服务提供者发送给服务使用者，收到心跳代表服务正常，没收到代表服务错误。</p>
<blockquote>
<p>使用心跳 vs. 被动故障发现</p>
<p>使用心跳的情况：系统要求高可用、低延迟切换。</p>
<p>可以不用心跳：系统对延迟容忍度高。</p>
</blockquote>
<p><strong>NTP:</strong></p>
<img src="/.github.io/2025/04/08/muduo/383528-20240329214251309-1285508408.png" class title="image">

<p>T1，T2，T3，T4：假设消息来回的时间相等，来回总延迟即为<code>Delay = [(T4 - T1) - (T3 – T2)]/2</code>, 本地计算机与服务器的时间偏差即为<code>T3 + Delay - T4也即为[(T2 - T1) + (T3 – T4)]/2</code>, </p>
<p>心跳可以让对方知道自己当前的状态，包括网络上的拥挤程度。所以：</p>
<ul>
<li>要在工作线程发送心跳，<strong>不要单独使用心跳线程</strong>。（如果使用了，无法反应当前工作线程的拥挤程度）</li>
<li>与业务消息使用同一个连接，<strong>不要单独使用心跳连接</strong>。（如果使用了，无法反应当前连接的拥挤程度，比如说：心跳的连接一直活跃不会被防火墙kill，但是业务连接不活跃，被防火墙kill）</li>
</ul>
<blockquote>
<p>要避免在工作线程中使用TCP, 而在心跳中使用UDP。</p>
</blockquote>
<h4 id="分布式系统中的进程标识"><a href="#分布式系统中的进程标识" class="headerlink" title="分布式系统中的进程标识"></a>分布式系统中的进程标识</h4><p>如何标识一个进程？如果该进程是无状态的，可以直接用<code>ip:port</code>来标识，如果服务是有状态的，只是用ipport是不行的。</p>
<p>能否使用pid，即<code>ip:pid</code>,也是不行的，这两者无法标识一个唯一的进程。（因为同一个pid编号可能被重复使用，绝不能出现两个标识相同但进程不同的情况）</p>
<h5 id="正确做法"><a href="#正确做法" class="headerlink" title="正确做法"></a>正确做法</h5><p><code>ip:port:start_time:pid</code>来标识，这基本上能保证每个进程的唯一性：</p>
<ul>
<li>如果进程在极短时间内重启，即使start_time相同，但是因为pid是顺序使用的，必然不可能用完一圈再回到当前pid</li>
<li>如果重启时间很长，虽然pid可能重复，但是start_time差别很大</li>
</ul>
<p>一般分布式系统中每个会与其他机器打交道的进程都需要维护一个管理接口。</p>
<blockquote>
<p>其实TCP为了避免相同地址旧连接的干扰，使用序列号来避免这个问题，很类似这里的start_time以及pid的结合体。</p>
</blockquote>
<h4 id="构建易于维护的分布式程序"><a href="#构建易于维护的分布式程序" class="headerlink" title="构建易于维护的分布式程序"></a>构建易于维护的分布式程序</h4><blockquote>
<p>维护针对于维护人员说的，管理起来很方便，而不是针对代码开发人员说的</p>
</blockquote>
<p>为什么为长期进程提供一个管理接口很重要：</p>
<ul>
<li>必要性</li>
<li>便利性，利用HTTP使用HttpServer程序。</li>
</ul>
<h4 id="为系统演化（升级）做准备"><a href="#为系统演化（升级）做准备" class="headerlink" title="为系统演化（升级）做准备"></a>为系统演化（升级）做准备</h4><h5 id="（跨语言的）可拓展消息格式"><a href="#（跨语言的）可拓展消息格式" class="headerlink" title="（跨语言的）可拓展消息格式"></a>（跨语言的）可拓展消息格式</h5><ul>
<li>服务端升级时，不应该靠消息中的版本号来分发消息——这很容易产生一大堆垃圾消息</li>
<li>设计消息头时，避免通过TCP连接发送C struct或者bit fields格式的内容，这有很多缺点包括：非C&#x2F;C++语言很难处理这种情况，很难升级。<strong>解决办法</strong>：使用中间语言来描述消息格式，<ul>
<li>如果使用文本格式，使用JSON 或 XML。使用文本格式时，需要考虑针对不可用字符的转义字符。</li>
<li>如果使用二进制格式，使用GOOGLE protocol Buffers。要注意的两点：<ul>
<li>不能改变已经存在字段的标签号（应该指的是顺序吧）</li>
<li>不能添加或删除<strong>必填字段</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="分布式程序的自动化回归测试"><a href="#分布式程序的自动化回归测试" class="headerlink" title="分布式程序的自动化回归测试"></a>分布式程序的自动化回归测试</h4><p>自动化测试与被测程序是一种互补关系，对于维护系统的稳定性很重要。</p>
<h5 id="单元测试的能与不能"><a href="#单元测试的能与不能" class="headerlink" title="单元测试的能与不能"></a>单元测试的能与不能</h5><blockquote>
<p>一些机制：</p>
<ul>
<li><p>RTTI：通过<strong>运行时类型识别</strong>，程序能够使用<strong>基类的指针或引用</strong>来检查着这些指针或引用所指的对象的<strong>实际派生类型</strong>。<a target="_blank" rel="noopener" href="https://www.cnblogs.com/tgycoder/p/5427303.html">C++中的RTTI机制解析</a></p>
</li>
<li><p>反射机制：反射让程序在<strong>运行时</strong>获取和操作类的信息（而不是在编译时写死）。比如说访问Class.newInstance()来创建对象就利用了反射机制。<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/669358870">反射教程</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(&quot;com.example.MyService&quot;);</span><br><span class="line">Object obj = clazz.getDeclaredConstructor().newInstance();</span><br></pre></td></tr></table></figure>
</li>
<li><p>依赖注入：一种设计模式，去除Java类之间的依赖关系，实现松耦合。（感觉使用依赖注入后，类中的<strong>局部对象</strong>就是通过参数传入的，而不是在类的构造函数中写死的）依赖关系为A类依赖B的父类B0类，在A类与B0类的依赖关系下，A类可使用B0类的任意子类。这里用到了多态机制，当需要动态创建实例时，需要利用到反射机制。<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/67032669">理解依赖注入</a></p>
</li>
</ul>
</blockquote>
<p>单元测试的一些缺点：</p>
<ul>
<li>单元测试本质是白盒测试，测试代码需要调用被测代码，必须明确写出被测代码的包、方法、参数、返回列表才能调用成功。一旦后期改变了被测代码的参数，带来了很大的工作量变化。</li>
<li>为了方便测试而施行依赖注入，破坏代码的整体性。</li>
</ul>
<p>反正作者觉得class或者function级别的单元测试对分布式系统的帮助不大。作者认为要测试这些<strong>进程之间的交互</strong>。（其实当初对blender渲染任务做负载均衡时，也使用了一个模拟的客户端来检测服务端是否正常）</p>
<blockquote>
<p>mock：模拟对象，用于在测试中模拟真实对象</p>
<p>回归测试：用于检测修改代码后，有没有引入新错误（防止质量倒退）</p>
</blockquote>
<p>这种测试也具有一定的局限性：</p>
<p>如果测试过程中还涉及到一些其他的IO, 比如通过TCP连接数据库，这是比较难模仿的，要么就只能部署测试数据库。</p>
<h4 id="分布式系统部署、监控和进程管理的境界"><a href="#分布式系统部署、监控和进程管理的境界" class="headerlink" title="分布式系统部署、监控和进程管理的境界"></a>分布式系统部署、监控和进程管理的境界</h4><p>境界一：高校水平</p>
<p>手工管理各个服务器程序，ip，port啥的。</p>
<p>境界二：零散的自动化脚本以及第三方组件</p>
<p>境界三：高效自动化的控制</p>
<p>举例：Master&#x2F;Slave&#x2F;Client结构：Master节点作备份，Slave进程包含多个执行任务的子进程，可以通过sigchld及时指导进程的启停。</p>
<blockquote>
<p>naming service: <strong>命名服务</strong>，即提供<strong>名字（name）到资源地址（如 IP 或 host:port）之间的映射服务</strong>。</p>
</blockquote>
<p>境界四：机群管理以及naming service的结合</p>
<p>zurg的一个缺陷是无法自动化的failover。（出现错误时应该立刻切换系统）</p>
<p>实现快速的failover:利用naming service 代替DNS即可。（DNS使用超时轮询，慢，而且不支持端口）</p>
<p>可以实现自己的名字服务：将service_name解析成<code>list of ip:port</code>, 名字服务可以将新的地址信息推送给客户端。</p>
<p>naming service是系统正常运行的关键，多台服务器保证可用性，Paxos算法保证一致性。</p>
<blockquote>
<p>一致性算法：</p>
<p>paxos<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/31727291">Paxos、Raft分布式一致性算法</a></p>
</blockquote>
<h3 id="C-编译链接模型"><a href="#C-编译链接模型" class="headerlink" title="C++编译链接模型"></a>C++编译链接模型</h3><p>C++20才有模块机制，可以直接使用其他文件提供的接口。之前都是只能通过引入头文件来使用的，缺点很多：</p>
<ul>
<li>一方面效率很低</li>
<li>一方面可能出现冲突（比如写QT时，slot被覆盖了，需要更换两个头文件的顺序才行），</li>
<li>一方面很带可能来<strong>隐患</strong>，头文件时编译时使用的，库文件时运行时使用的，如果两者的版本不一致会导致很多问题。</li>
</ul>
<blockquote>
<p>c的出现受制于当时的硬件条件，单遍编译、先定义再使用、局部变量必须在开头定义、对于外部变量只需要指导类型和名字，不需要知道地址，这些都是为了在低资源硬件环境下编译c程序做的规定，由于cpp想要兼容c，导致他也接受了这些糟粕。</p>
</blockquote>
<p><strong>关于为什么c会分为头文件和源文件</strong>，其实即使是现代的C编译器，头文件也不是必须的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//cat alpha.c;cat beta.c</span><br><span class="line">int main() &#123;</span><br><span class="line">    print_hello();</span><br><span class="line">&#125;</span><br><span class="line">void print_hello() &#123;</span><br><span class="line">    puts(&quot;hello&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//gcc alpha.c beta.c -o app;</span><br><span class="line">//./app</span><br><span class="line">hello</span><br></pre></td></tr></table></figure>

<p>对于<strong>C语言</strong>而言，遇到未知符号，则将其作为外部符号等待链接就行了。</p>
<ul>
<li>这种写法基本上能work，是因为当时的数据类型比较简单，就只有int。</li>
<li>而且这么做可以很方便的<strong>将从不同语言编译到的目标文件链接到一起。</strong>（gcc在编译期间就已经丢弃了类的元数据）</li>
</ul>
<p>随着结构体的引入，问题变得更加复杂，函数调用需要提前声明，这就是头文件出现的缘由。有个问题是为什么不能直接去查找对应的源文件呢，因为<code>C</code>假设对方可能不是<code>C</code>编写的代码（比如可能是<code>Fortran</code>、汇编），所以每个源文件都只包含最基本的机器代码（没必要包含类的元数据）。所以为了访问C语言编写的其他函数或者其他语言（比如<strong>汇编</strong>）编写的其他函数，都需要为其创建一个匹配的头文件，然后供需要的源文件使用。</p>
<blockquote>
<p>虽然<code>C</code>编译可以直接产生目标文件，从而很方便的与其他语言链接，不过常用的语言貌似就只有汇编。如果能和其他功能更强大的语言链接，可能C还会更常用。可以“直接产生目标文件”的这个特点也带来了很大的缺点，比如目标文件不包含元数据，导致C&#x2F;C++很难实现一些java中的特性，反射啥的。</p>
</blockquote>
<h4 id="C-的编译模型"><a href="#C-的编译模型" class="headerlink" title="C++的编译模型"></a>C++的编译模型</h4><h5 id="单遍编译"><a href="#单遍编译" class="headerlink" title="单遍编译"></a>单遍编译</h5><p>编译器只能根据当前看到的代码做决策。这特别影响了名字查找（name lookup）和函数重载决议。</p>
<h6 id="名字查找："><a href="#名字查找：" class="headerlink" title="名字查找："></a><strong>名字查找：</strong></h6><p>C++中的名字包括类型名、函数名、变量名、typdef名、template名，比如<code>Foo&lt;T&gt; a;</code>如果不知道这三个名字是什么，那么可以有很多种<strong>合理的解释</strong>：</p>
<ul>
<li>Foo是个<code>template&lt;typename X&gt; class Foo;</code>，T是<strong>类型参数</strong>。</li>
<li>Foo是个<code>template&lt;int X&gt; class Foo;</code>， T是一个非类型参数。</li>
<li>Foo，T，a都是int变量，这里只是对三者比较大小。</li>
<li>而且<code>&lt;</code>还有可能被重载</li>
</ul>
<p>还有一个经典的例子，AA BB()是声明函数，而非定义变量。一个更有迷惑性的是<code>MyClass obj(MyClass())</code>,他是声明一个函数obj，他接收一个函数作为参数，这个函数返回MyClass类型的对象，不接受参数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;MyClass constructor\n&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">say</span><span class="params">()</span> <span class="type">const</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Hello\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 这行到底是函数声明还是对象定义？</span></span><br><span class="line"><span class="function">MyClass <span class="title">obj</span><span class="params">(MyClass())</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    obj.<span class="built_in">say</span>();  <span class="comment">// ❌ 如果是函数声明，这里编译会报错</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">####################[测试]####################</span><br><span class="line">MyClass.cpp:<span class="number">12</span>:<span class="number">9</span>: error: request <span class="keyword">for</span> member ‘say’ in ‘obj’, which is of non-<span class="keyword">class</span> <span class="title class_">type</span> ‘<span class="built_in">MyClass</span>(<span class="built_in">MyClass</span> (*)())’</span><br><span class="line">   <span class="number">12</span> |     obj.<span class="built_in">say</span>();  <span class="comment">// ❌ 如果是函数声明，这里编译会报错</span></span><br><span class="line">      |         ^~~</span><br></pre></td></tr></table></figure>

<p>由此可见，cpp理解名字有着很大的误差。主要原因是因为cpp只能根据解析源码来了解名字的含义，需要将文件从头到问解析一遍。而其它语言可能通过直接读取目标代码的元数据来获取所需信息。（比如java会将元数据编译进.class文件，运行时的反射机制也是通过这种元数据实现的；cpp不会保留每个class的元数据，也没法实现反射）</p>
<p>为此作者提出使用 <code>-Wshadow</code>选项来对同名变量的遮挡情况发出警告。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-Wall：启用所有常见警告。</span><br><span class="line">-Wextra：启用更多额外的警告。</span><br><span class="line">-Werror：将所有警告视为错误。</span><br><span class="line">-Wconversion：警告隐式类型转换，这可能会改变值。</span><br><span class="line">-Wshadow：警告变量遮蔽（即在内层作用域声明一个与外层作用域同名的变量）。</span><br></pre></td></tr></table></figure>

<h6 id="函数重载决议"><a href="#函数重载决议" class="headerlink" title="函数重载决议"></a>函数重载决议</h6><p>当编译器读到一个函数调用语句时，他只能从<strong>当前已经看到的同名</strong>函数中选择最佳函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void foo(int)&#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;foo(int)&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void foo(char)&#123;</span><br><span class="line">        cout &lt;&lt; &quot;foo(char)&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bar()&#123;</span><br><span class="line">        foo(&#x27;a&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">void foo(char)&#123;</span><br><span class="line">        cout &lt;&lt; &quot;foo(char)&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line">int main()&#123;</span><br><span class="line">        bar();</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br><span class="line">####这里交换顺序后，结果是不同的</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其实由于C++’新增了不少语言特性，C++编译器并不能真正像C那样进行过眼即忘的单遍编译。但是C++必须兼容C的语意，因此编译器不得不装得好像是单遍编译(准确地说是单遍parse)一样，哪怕它内部是multiple pass的。</p>
</blockquote>
<h5 id="前向声明"><a href="#前向声明" class="headerlink" title="前向声明"></a>前向声明</h5><p>利用前向声明来较少编译期依赖，</p>
<p>函数声明与定义：通常能够查出参数列表不同，但不一定能查出返回类型不同。原型<strong>声明的变量名是无效的</strong>，以定义时为准，</p>
<p>有时候，只使用前向声明就已经足够了：</p>
<ul>
<li>定义或声明<code>Foo*</code>和<code>Foo&amp;</code>,用于函数参数，返回类型等等。</li>
<li><strong>声明一个</strong>以Foo为参数会返回类型的<strong>函数</strong>。（只在声明语句中使用就没事）</li>
</ul>
<p>不能重载<code>&amp;&amp; || , operator&amp;</code>这四个运算符。</p>
<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p>两个重要的问题：</p>
<ul>
<li>函数重载，名字改编（生成独一无二的符号名）。利用extern “C”来和C程序库集成。</li>
<li>vague linkage（模糊链接），C要求一个符号在一个程序只能有一个定义；而对于有模糊链接属性的C++对象，每个定义是弱定义，最终会有链接器去选择一个定义。</li>
</ul>
<h5 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h5><p>为了实现重载，需要先利用名字改变来为重载函数生成独一无二的名字，生成的名字像下面的样子：<code>_Z3foob</code>, </p>
<ul>
<li>这也是为什么不建议变量用下划线开头的原因。</li>
<li>这也是为什么函数名、参数数量、参数类型、参数顺序会影响重载的原因（会导致修饰后的名称不一致）；而参数名和返回值类型不影响。</li>
</ul>
<blockquote>
<p>这也导致一个bug，可能使用的函数原型的返回值是错的，但是可以链接没有报错。</p>
</blockquote>
<h5 id="inline函数"><a href="#inline函数" class="headerlink" title="inline函数"></a>inline函数</h5><p>如何在头文件定义函数，可以使用inline函数来避免重复定义。</p>
<h5 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h5><p>当模板在不同的文件具现化模板后，相同的模板的函数在不同的目标文件中定义，为了避免重复定义问题，模板的成员函数具有若定义的属性。这样可以避免报错。（类似的，inline函数也具有弱定义的属性，<strong>当inline失败时</strong>，为了避免多个文件同时定义该函数，利用弱定义）</p>
<ul>
<li>通常在编译期就会实例化模板，需要给出对应类型的定义，这要求我们必须将模板的定义放到头文件中。</li>
<li>但其实，如果编译期不给出模板的定义，只给出模板的声明，在<strong>编译期不会报错</strong>，然后在连接阶段会报<strong>找不到定义的错误</strong>。为了解决这个问题，可以在任何一个能访问到模板定义的地方实现实例化<strong>需要用到</strong>的类型。（可以利用这种方式来<strong>限制用户只能使用某几个特殊的模板类型</strong>）</li>
</ul>
<blockquote>
<p>当写一个库foo时，如果他依赖一个模板bar，则可以将模板bar的定义放到源文件中，bar的声明放到头文件，然后再源文件实例化几个需要的类型。这样可以避免用户的代码访问到模板，提高编译速度。</p>
</blockquote>
<p>C++可以使用<code>extern template</code>特性，可以手动实例化，从而避免每个使用模板的文件都进行实例化，提高编译速度。</p>
<h5 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h5><p>每个定义或者继承了虚函数的类都有一个<code>vtable</code>。而该类的每个对象都有一个指向该表<code>vtable</code>的指针，即<code>vptr</code>。</p>
<h4 id="头文件的使用规则"><a href="#头文件的使用规则" class="headerlink" title="头文件的使用规则"></a>头文件的使用规则</h4><h5 id="头文件的害处"><a href="#头文件的害处" class="headerlink" title="头文件的害处"></a>头文件的害处</h5><ul>
<li>传递性，头文件可以导入其他头文件，导致代码膨胀；任何一个头文件改动都会重新编译所有依赖于它的源文件。</li>
<li>顺序性，一个头文件可以包含多个头文件，这些头文件之间可能有顺序区分。</li>
<li>差异性<ul>
<li>内容差异，两个源文件编译时，如果编译选项不一致，会导致二进制代码不兼容，所有源文件都应该使用相同的编译选项。（如果需要使用其他人的库，除了拿到头文件和库文件，还需要知道这个库的编译选项。）</li>
<li>时间差异，头文件与库文件的内容不一致。</li>
</ul>
</li>
</ul>
<p>反观现代的编程语言，模块化做得更好：</p>
<ul>
<li>对于解释性语言，import的时候直接将对应模块的源文件解析一遍。</li>
<li>对于编译性语言，编译出来的目标文件包含了足够的元数据，import的时候可以直接读目标文件的内容。</li>
</ul>
<p>这两种方式都可以避免声明定义不一致的问题。</p>
<h5 id="头文件的使用规则-1"><a href="#头文件的使用规则-1" class="headerlink" title="头文件的使用规则"></a>头文件的使用规则</h5><p>常见的观点：</p>
<ul>
<li>将文件的编译依赖降至最小</li>
<li>将定义式之间的依赖关系降低至最小，避免循环依赖</li>
<li>让class名字、头文件名字、源文件名字直接相关</li>
<li><code>#include once</code>用的名字应该包含文件的路径的全名</li>
</ul>
<p>tips: 如何知道某一个类&#x2F;函数是通过哪个头文件被引入当前源文件的？比如要知道程序是通过哪个文件引入string这个类的，可以在当前目录创建一个包含<code>#error error</code>的名字为<code>string</code>的文件，然后在编译时使用<code>-I .</code>选项将当前目录纳入头文件搜索路径。（有个问题是如何通过一个类名判断它所在的头文件是哪个，可以通过一些标准网站来查找，比如string类对应的头文件可以在这里面找到<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/string/basic_string.html">std::basic_string - cppreference.com</a>）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rtlab<span class="number">-3090</span>:~/cpp/laji/string$ g++ test.cpp -I . -o ooo</span><br><span class="line">In file included from /usr/include/c++/<span class="number">11</span>/bits/locale_classes.h:<span class="number">40</span>,</span><br><span class="line">                 from /usr/include/c++/<span class="number">11</span>/bits/ios_base.h:<span class="number">41</span>,</span><br><span class="line">                 from /usr/include/c++/<span class="number">11</span>/ios:<span class="number">42</span>,</span><br><span class="line">                 from /usr/include/c++/<span class="number">11</span>/ostream:<span class="number">38</span>,</span><br><span class="line">                 from /usr/include/c++/<span class="number">11</span>/iostream:<span class="number">39</span>,</span><br><span class="line">                 from test.cpp:<span class="number">1</span>:</span><br><span class="line">./string:<span class="number">1</span>:<span class="number">2</span>: error: <span class="meta">#<span class="keyword">error</span> <span class="keyword">error</span></span></span><br><span class="line">    <span class="number">1</span> | <span class="meta">#<span class="keyword">error</span> <span class="keyword">error</span></span></span><br><span class="line">      |  ^~~~~</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这种找头文件的方式与通过<code>IDE</code>的<code>ctrl+click</code>跳转还是有一点区别的，假如有如下几个文件：</p>
<ul>
<li>locale_classes.h 该文件中包含了<code>&lt;string&gt;</code>，意味着所有引用locale_classes文件的文件都会包含string，</li>
<li>basic_string.h， 在string文件中，引用了basic_string文件，然后在basic_string文件中，有着string的定义，</li>
</ul>
<p>当通过IDE的<code>ctrl+click</code>跳转时，会直接进入basic_string文件，找到string定义的地方。</p>
<p>通过前往所述的方法，利用显示从当前文件到locale_classes之间的整个调用路径，它能找到的最深的文件路径是<strong>直接引用string</strong>的那一个文件。</p>
</blockquote>
<h4 id="工程项目中库文件的组织原则"><a href="#工程项目中库文件的组织原则" class="headerlink" title="工程项目中库文件的组织原则"></a>工程项目中库文件的组织原则</h4><p>改动程序或者它依赖的库都应该重新测试。</p>
<p>像java，python，需要检查库、解释器、jvm等的版本。</p>
<blockquote>
<p>库API(头文件)：人类可读的接口，比如函数签名，参数</p>
<p>编译器ABI：编译器如和将代码翻译为二进制，比如函数调用规则，对齐，名字修饰等。</p>
<p>库ABI: 包含了库API以及编译器ABI。</p>
<p>操作系统ABI：规定了系统调用和底层服务的二进制接口，比如如何触发系统调用，<code>int 80</code>等。</p>
</blockquote>
<p>编译器版本与标准库版本直接相关。</p>
<p>C++库的发布方式：</p>
<table>
<thead>
<tr>
<th></th>
<th>动态库</th>
<th>静态库</th>
<th>源码库</th>
</tr>
</thead>
<tbody><tr>
<td>发布方式</td>
<td>头文件+<code>.so</code>文件</td>
<td>头文件+<code>.a</code>文件</td>
<td>头文件+<code>.cc</code>文件</td>
</tr>
<tr>
<td>查询依赖关系</td>
<td>通过ldd可以查询一个可执行文件的依赖</td>
<td>编译期信息（还有cmake啥的吧）</td>
<td>编译期信息（还有cmake啥的吧）</td>
</tr>
</tbody></table>
<p>要保证应用程序之间的独立性，要让多个动态库的多个版本能够共存。</p>
<h5 id="动态库的危害"><a href="#动态库的危害" class="headerlink" title="动态库的危害"></a>动态库的危害</h5><p>虽然通过更新动态库，可以随时增加新特性，但是更新动态库的版本后，程序的行为变得<strong>不可预期</strong>。（能不能正常运行都是一个问题）</p>
<h5 id="静态库的危害"><a href="#静态库的危害" class="headerlink" title="静态库的危害"></a>静态库的危害</h5><p>优点：</p>
<ul>
<li>依赖关系在编译期确定</li>
<li>发布速度更快，比较没有<code>PIT</code>表（Procedure Import Table）</li>
<li>只需要发布单个可执行文件</li>
</ul>
<blockquote>
<p>向后兼容：</p>
<ul>
<li>对代码而言，指的是新版本的代码&#x2F;软件，能够兼容旧版本的数据格式、<strong>接口</strong>或功能。</li>
<li>对编译器而言，指的是新版编译器仍能正确编译、运行旧版本语法或代码风格写的程序。</li>
</ul>
<p><strong>依赖冲突</strong>（钻石依赖）：当前应用程序间接依赖于某个库的多个版本，可能导致符号冲突，不可预判的行为。</p>
</blockquote>
<p>静态链接在针对这种依赖冲突的问题，虽然可能将报错从运行期提前到编译期，但解决问题依然很麻烦，以下几种可能遇到的问题：</p>
<ul>
<li>一个依赖于库A的库突然依赖更高版本的库A时，导致其他依赖于库A的库都需要升级高版本。</li>
<li>重复链接，应用程序依赖于某个库的多个版本</li>
</ul>
<p>更新系统时，新系统的系统<code>ABI</code>可能与旧系统不兼容，理论上需要重新编译库文件。更新编译器时，编译器<code>ABI</code>（比如为C++11修改了ABI）可能发生变化，理论上需要重新编译库文件。</p>
<p>如何解决源码库吗？</p>
<h5 id="源码编译"><a href="#源码编译" class="headerlink" title="源码编译"></a>源码编译</h5><p>可以确保所有源文件在相同的条件下编译的，不用为库的版本操心。</p>
<p>由于<code>C++</code>的头文件与源文件分离，并且编译产生的目标文件<code>.o</code>没有包含足够的元数据，如果要在项目中使用一个库，还必须提供对应的头文件。因为同时需要这两个东西，就会导致这<strong>两者不匹配的情况。</strong>（c++编译的目标文件就只是二进制代码，并不包含任何如何使用该类的信息，比如函数声明，类结构）</p>
<blockquote>
<p>from gpt:</p>
<h2 id="C-有必要用库吗？"><a href="#C-有必要用库吗？" class="headerlink" title="C++ 有必要用库吗？"></a>C++ 有必要用库吗？</h2><p><strong>必须的。</strong>因为 C++ 本身没有电池齐全（batteries included）：</p>
<ul>
<li>C++ 标准库太“基础”了（比如没网络库、图形库、并发框架、解析库等）</li>
<li>高质量第三方库是构建现代 C++ 项目的核心<br> 例如：<ul>
<li>并发网络：<code>Boost.Asio</code>, <code>libuv</code>, <code>gRPC</code></li>
<li>序列化：<code>protobuf</code>, <code>msgpack</code>, <code>flatbuffers</code></li>
<li>UI：<code>Qt</code>, <code>FTXUI</code></li>
<li>日志：<code>spdlog</code>, <code>glog</code></li>
<li>单元测试：<code>GoogleTest</code>, <code>Catch2</code></li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="C-面向对象与虚函数"><a href="#C-面向对象与虚函数" class="headerlink" title="C++面向对象与虚函数"></a>C++面向对象与虚函数</h3><blockquote>
<p>虽然 C++ 支持面向对象编程（如类、继承、多态等），但它的语法和机制在设计上并不如 Java、C# 等“原生支持”面向对象的语言来得自然和系统化。它是一种通过对 C 语言的扩展实现的 OO。</p>
</blockquote>
<p>C++ class 是值语义，而非对象语义。这带来的影响很多：</p>
<ul>
<li>直接赋值时，会发生拷贝构造，而非引用复制。</li>
<li>如果想使用深拷贝，需要显示编码</li>
</ul>
<h4 id="朴实的C-设计"><a href="#朴实的C-设计" class="headerlink" title="朴实的C++设计"></a>朴实的<code>C++</code>设计</h4><p>C++复杂，但<strong>不代表要使用复杂的方式来使用它</strong>。（作者不建议大规模使用面对对象、继承、多态）</p>
<p>利用接口类&#x2F;实现类的一个好处就是可以实现依赖注入。（将对象从类的外部传入）</p>
<h4 id="程序库的二进制兼容性"><a href="#程序库的二进制兼容性" class="headerlink" title="程序库的二进制兼容性"></a>程序库的二进制兼容性</h4><p>比如一个图形库，支持<code>1920*1200</code>像素，很多项目用到了该库。后来为了支持<code>2560*1600</code>像素，可以有两种解决方式：</p>
<ul>
<li>发布一个新的图形库，让使用了该图像库的其他项目重新编译。这会导致其他项目重新发布一个版本。</li>
<li>更新现有的库文件，但是新库和旧项目可能出现不兼容的问题。</li>
</ul>
<p>本章的二进制兼容性主要是指库文件单独升级，现有可执行文件是否受影响，<strong>主要是动态链接库</strong>的 ABI（怎么感觉应该是API呢）, 至于编译器以及操作系统的ABI 见上一章。</p>
<h5 id="二进制兼容性"><a href="#二进制兼容性" class="headerlink" title="二进制兼容性"></a>二进制兼容性</h5><p>使用动态库的方式提供函数库，那么头文件和库文件不应该被轻易修改。</p>
<p>希望在升级库文件（或者Linux Kernel）时，不必重新编译使用了这个库的可执行文件。（在可执行文件仍然使用旧的头文件时，仍然可使用新的库文件。这意味着我们的可执行文件不用重新编译，不用发布新版本，想一下，如果依赖的每个库更新时，我们都需要重新编译以及发布，那么带来的工作量有多大）</p>
<blockquote>
<p>源代码兼容性：老代码使用新头文件，能编译通过。（感觉二进制兼容比源代码兼容要求要高）</p>
<p>向后兼容性：（兼容过去的版本，不同的软件版本，给使用者留下了一个使用接口，最新的软件仍然提供老版本的使用接口，则是兼容）在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E8%85%A6">计算机</a>中指在一个<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E8%85%A6%E7%A8%8B%E5%BC%8F">程序</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%BA%93_(%E8%AE%A1%E7%AE%97%E6%9C%BA)">库</a>或<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%94%B5%E8%84%91%E7%A1%AC%E4%BB%B6">硬件</a>更新到较新<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%89%88%E6%9C%AC">版本</a>后，用旧版本程序创建的文档或系统仍能被正常操作或使用，在旧版本库的基础上开发的程序仍能正常<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BC%96%E8%AF%91">编译</a>运行。</p>
</blockquote>
<blockquote>
<p>当多个应用或库依赖不同版本的同一个 DLL，但系统无法正确加载对应版本时，就会出现“DLL Hell”。</p>
</blockquote>
<h5 id="什么情况会破坏库的-ABI"><a href="#什么情况会破坏库的-ABI" class="headerlink" title="什么情况会破坏库的 ABI"></a>什么情况会破坏库的 <code>ABI</code></h5><p>这取决于C++的实现方式，比如Visual C++， G++。</p>
<p>C++编译器 ABI 的主要内容包括以下几个方面：</p>
<ul>
<li>函数参数传递的方式</li>
<li>虚函数的调用方式，通常是vptr&#x2F;vtbl</li>
<li>struct 和 class 的内存布局</li>
<li>name mangling</li>
<li>RTTI 和 异常处理</li>
</ul>
<p>C&#x2F;C++是通过<strong>头文件</strong>来暴露出动态库的使用方法（函数调用以及对象布局）。通过判断这个头文件的<strong>使用方法</strong>是否与新版本库的<strong>实际使用方法</strong>相匹配，就知道这个改动是否是二进制兼容。</p>
<p>比如：</p>
<ul>
<li>动态库中有 <code>non-virtual</code>函数<code>void foo(int)</code>，新版本的库变为了<code>void foo(double)</code>，这会导致两个函数的名字修饰不一致，进而找不到符号。</li>
<li>对于上面的情况，将<code>non-virtual</code>函数变为<code>virtual</code>函数。虚函数不是通过签名（符号）来找对应的实现的，<strong>而是通过索引</strong>。在编译时，就会将 foo 函数转变为内部 vtable 中某个索引（即函数指针）的调用（索引顺序是声明顺序）。当库被修改后，对应索引的函数指针变化了，如果还是按照旧版本的头文件使用索引，虽然编译不会报错，但在运行时会遇到未定义的行为。（一种可能的做法是在foo函数后面新增新的函数，这样生成的vtable只会在后面新增索引，<strong>也许能保证向后兼容</strong>，<strong>还得考虑当前类是否被继承。</strong>）</li>
</ul>
<p>源代码兼容但二进制不兼容的例子：</p>
<ul>
<li>给函数增加默认参数（默认参数是通过在编译时在调用函数时手动加上该参数来实现的，默认参数只存在于函数声明处，无需出现在定义处，<strong>定义不知道也不关心有没有默认参数</strong>）</li>
<li>增加虚函数，会导致vtbl的排列变化，要考虑当前类是否被继承。</li>
<li>增加默认模板参数类型<code>Foo&lt;T&gt;</code>变为 <code>Foo&lt;T, Alloc=alloc&lt;T&gt;&gt;</code>，</li>
<li>改变 enum 的值</li>
</ul>
<p>考虑如下的情况：给<code>class Bar</code> 新增数据成员，导致 <code>sizeof(Bar)</code> 变大以及内部结构变化，这通常不安全，也有例外：</p>
<ul>
<li>如果客户代码中使用了<code>new Bar</code>，这是不安全的（因为会调用malloc，会根据头文件中的数据类型来确定类的大小，这和源文件中类的大小不一致；然后会调用源文件中的构造函数，这很可能会导致用来未分配的内存）。<strong>可以通过<code>factory</code>返回<code>Bar*</code>或者<code>shared_ptr&lt;Bar&gt;</code>。</strong></li>
<li>避免直接访问类中的变量，而是通过成员函数访问。</li>
<li>避免调用<code>inline</code>修饰的成员函数。而是使用<code>outline function</code>。</li>
</ul>
<h5 id="哪些做法可能是二进制兼容的"><a href="#哪些做法可能是二进制兼容的" class="headerlink" title="哪些做法可能是二进制兼容的"></a>哪些做法可能是二进制兼容的</h5><ul>
<li>增加新的 <code>class</code></li>
<li>增加 <code>non-virtual</code>成员函数或<code>static</code>成员函数</li>
<li>修改数据成员的名称，二进制代码是通过偏移量访问数据成员的。</li>
<li>个人测试：修改只虚函数名字，并保证参数返回值，虚函数声明顺序不变，貌似也可以实现二进制兼容。见<a target="_blank" rel="noopener" href="https://github.com/tjzhang-src/cpp/tree/master/muduo/chapter11/virtual">cpp&#x2F;muduo&#x2F;chapter11&#x2F;virtual</a></li>
</ul>
<h5 id="为了避免二进制不兼容"><a href="#为了避免二进制不兼容" class="headerlink" title="为了避免二进制不兼容"></a>为了避免二进制不兼容</h5><p>有如下的做法：</p>
<ul>
<li>使用静态链接</li>
<li>仔细管理动态库的版本，详见<a href="https://tjzhang-src.github.io/.github.io/2023/03/19/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-%E7%AC%AC%E5%85%AB%E7%AB%A0/#%E5%85%B1%E4%BA%AB%E5%BA%93%E5%91%BD%E5%90%8D%E6%96%B9%E5%BC%8F">共享库命名方式</a></li>
<li>pimpl技法，多一层间接性</li>
</ul>
<h4 id="避免使用虚函数作为库的接口"><a href="#避免使用虚函数作为库的接口" class="headerlink" title="避免使用虚函数作为库的接口"></a>避免使用虚函数作为库的接口</h4><p>如果打算写一个库，需要考虑：</p>
<ul>
<li>动态库 <code>or</code> 静态库</li>
<li>以什么方式暴露库的接口：全局函数、类的<code>non-virtual</code>成员函数、类的<code>virtual</code>函数。</li>
</ul>
<p>有两个基本假设：</p>
<ul>
<li>代码有<code>bug</code>，会发布<code>bug fixes</code></li>
<li>代码会有新功能，要升级</li>
</ul>
<p>针对第一个假设：</p>
<ul>
<li>如果要热修复，则只能使用动态库；</li>
<li>否则使用静态库更容易部署。</li>
</ul>
<p>针对第二个假设：</p>
<ul>
<li>如果第一步用的是使用动态库<ul>
<li>如果只是 修 bug，那么二进制库文件应该达到二进制兼容</li>
<li>如果要新增功能，应该对用户代码友好</li>
</ul>
</li>
<li>如果第一步用的静态库，那么不会遇到上面的问题。</li>
</ul>
<h5 id="虚函数作为库的接口的两大用途"><a href="#虚函数作为库的接口的两大用途" class="headerlink" title="虚函数作为库的接口的两大用途"></a>虚函数作为库的接口的两大用途</h5><ul>
<li>调用，库提供某个功能，以虚函数为接口暴露给客户端代码。</li>
<li>回调，事件通知，重写虚函数作为回调时使用的函数。（该方法已过时，可以利用<code>bind</code>这种做法）</li>
</ul>
<h5 id="虚函数作为接口的弊端"><a href="#虚函数作为接口的弊端" class="headerlink" title="虚函数作为接口的弊端"></a>虚函数作为接口的弊端</h5><p><strong>要实现二进制兼容性十分困难</strong>，一旦发布，不能修改，只能重写编译。</p>
<p>比如如果要新增几个接口（虚函数），为了保证二进制兼容性，只能将新函数放到 <code>interface</code>的接口，这么做既丑陋又危险（一旦被继承）。</p>
<h4 id="动态库接口的推荐做法"><a href="#动态库接口的推荐做法" class="headerlink" title="动态库接口的推荐做法"></a>动态库接口的推荐做法</h4><blockquote>
<p>（思路，看不到库中头文件的具体实现更容易实现二进制兼容性，具体来说是避免看见头文件类中的数据成员，知道数据成员了就知道类的大小，将来增加数据成员后使用sizeof会出错，虽然）</p>
<p>Pimpl方法：类中包含一个指向某个具体类型的指针。实现定义在该具体类型的<strong>源文件</strong>中。（代码见<a target="_blank" rel="noopener" href="https://github.com/tjzhang-src/cpp/tree/master/muduo/chapter11/pimpl">cpp&#x2F;muduo&#x2F;chapter11&#x2F;pimpl</a>），这样可以隐藏Impl类，任何类都看不到该类，</p>
<ul>
<li>当修改Impl类时，不会导致其依赖于Impl的类重新编译（Person除外，毕竟Impl就定义在Person文件里面的）</li>
<li>减少了编译依赖，</li>
</ul>
</blockquote>
<ul>
<li>动态库的使用范围有限，做好版本管理即可。（头文件和类分为用户可见部分和不可见部分，针对用户可见部分，需要注意二进制兼容性）</li>
<li>使用 pimpl 方法，多使用 non-member non-friend函数来作为接口。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://tjzhang-src.github.io/.github.io">John Doe</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://tjzhang-src.github.io/.github.io/2025/04/08/muduo/">https://tjzhang-src.github.io/.github.io/2025/04/08/muduo/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://tjzhang-src.github.io/.github.io" target="_blank">Welcome</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/.github.io/tags/c/">c++</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/.github.io/2025/08/02/muduo-part2/" title="muduo_part2"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">muduo_part2</div></div></a></div><div class="next-post pull-right"><a href="/.github.io/2025/02/22/xv6/" title="xv6"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">xv6</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/.github.io/2024/09/17/cplusplusprimer/" title="cplusplusprimer"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-17</div><div class="title">cplusplusprimer</div></div></a></div><div><a href="/.github.io/2023/02/28/c-%E5%9F%BA%E7%A1%801/" title="c++基础1"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-28</div><div class="title">c++基础1</div></div></a></div><div><a href="/.github.io/2024/09/17/effective-cplusplus/" title="effective_cplusplus"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-17</div><div class="title">effective_cplusplus</div></div></a></div><div><a href="/.github.io/2025/08/02/muduo-part2/" title="muduo_part2"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-02</div><div class="title">muduo_part2</div></div></a></div><div><a href="/.github.io/2024/09/17/more-effective-cpulsplus/" title="more_effective_cpulsplus"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-17</div><div class="title">more_effective_cpulsplus</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Waline</span><span class="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/.github.io/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">John Doe</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/.github.io/archives/"><div class="headline">文章</div><div class="length-num">46</div></a><a href="/.github.io/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/.github.io/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/tjzhang-src"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">线程安全的对象生命周期管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0-amp-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">析构函数&amp;多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">1.1.1.</span> <span class="toc-text">线程安全</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0-amp-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">1.2.</span> <span class="toc-text">对象构造&amp;线程安全</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E9%94%80%E6%AF%81-amp-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">1.3.</span> <span class="toc-text">对象销毁&amp;线程安全</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#shared-ptr"><span class="toc-number">1.4.</span> <span class="toc-text">shared_ptr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#shared-ptr%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">1.5.</span> <span class="toc-text">shared_ptr的线程安全</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#shared-ptr%E7%9A%84%E9%99%B7%E9%98%B1"><span class="toc-number">1.6.</span> <span class="toc-text">shared_ptr的陷阱</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%B1%A0"><span class="toc-number">1.7.</span> <span class="toc-text">对象池</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">2.</span> <span class="toc-text">线程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E5%99%A8"><span class="toc-number">2.1.</span> <span class="toc-text">互斥器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AA%E4%BD%BF%E7%94%A8%E9%9D%9E%E9%80%92%E5%BD%92%E7%9A%84mutex"><span class="toc-number">2.1.1.</span> <span class="toc-text">只使用非递归的mutex</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">2.1.2.</span> <span class="toc-text">死锁</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%EF%BC%88%E7%AE%A1%E7%A8%8B%EF%BC%89"><span class="toc-number">2.2.</span> <span class="toc-text">条件变量（管程）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E8%A6%81%E7%94%A8%E8%AF%BB%E5%86%99%E9%94%81%E5%92%8C%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">2.3.</span> <span class="toc-text">不要用读写锁和信号量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%81%E8%A3%85MutexLock%E3%80%81MutexLockGuard%E3%80%81Condition"><span class="toc-number">2.4.</span> <span class="toc-text">封装MutexLock、MutexLockGuard、Condition</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8shared-ptr%E5%AE%9E%E7%8E%B0copy-on-write"><span class="toc-number">2.5.</span> <span class="toc-text">利用shared_ptr实现copy-on-write</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">3.</span> <span class="toc-text">多线程服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.1.</span> <span class="toc-text">单线程服务器的编程模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.2.</span> <span class="toc-text">多线程服务器编程模型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#one-loop-per-thread"><span class="toc-number">3.2.1.</span> <span class="toc-text">one loop per thread</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-number">3.3.</span> <span class="toc-text">进程间通信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%80%82%E7%94%A8%E5%9C%BA%E5%90%88"><span class="toc-number">3.4.</span> <span class="toc-text">多线程服务器的适用场合</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BF%85%E9%A1%BB%E4%BD%BF%E7%94%A8%EF%BC%88%E5%A4%9A%E8%BF%9B%E7%A8%8B%EF%BC%89%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9C%BA%E5%90%88"><span class="toc-number">3.4.1.</span> <span class="toc-text">必须使用（多进程）单线程的场合</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-number">3.4.2.</span> <span class="toc-text">适用多线程程序的场景</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AE%E7%AD%94"><span class="toc-number">3.4.3.</span> <span class="toc-text">问答</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">C++多线程系统编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%BA%BF%E7%A8%8B%E5%8E%9F%E8%AF%AD%E7%9A%84%E9%80%89%E7%94%A8"><span class="toc-number">4.1.</span> <span class="toc-text">基本线程原语的选用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-x2F-C-%E7%B3%BB%E7%BB%9F%E5%BA%93%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">4.2.</span> <span class="toc-text">C&#x2F;C++系统库的线程安全性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E5%96%84Tcpconnection"><span class="toc-number">4.3.</span> <span class="toc-text">完善Tcpconnection</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#sigpipe"><span class="toc-number">4.3.1.</span> <span class="toc-text">sigpipe</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#tcp-no-delay%E5%92%8Ctcp-keepalive"><span class="toc-number">4.3.2.</span> <span class="toc-text">tcp no delay和tcp keepalive</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8BTcpServer"><span class="toc-number">4.4.</span> <span class="toc-text">多线程TcpServer</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F"><span class="toc-number">5.</span> <span class="toc-text">分布式系统</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%98%AF%E4%B8%AA%E9%99%A9%E6%81%B6%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">5.0.1.</span> <span class="toc-text">分布式系统是个险恶的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">5.0.1.1.</span> <span class="toc-text">负载均衡</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%92%8C%E4%BA%8B%E4%BB%B6%E8%BF%9D%E5%8F%8D%E7%9B%B4%E8%A7%89"><span class="toc-number">5.0.1.2.</span> <span class="toc-text">时间和事件违反直觉</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="toc-number">5.1.</span> <span class="toc-text">可靠性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%83%BD%E9%9A%8F%E6%97%B6%E9%87%8D%E5%90%AF%E8%BF%9B%E7%A8%8B%E4%BD%9C%E4%B8%BA%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%9B%AE%E6%A0%87"><span class="toc-number">5.1.1.</span> <span class="toc-text">能随时重启进程作为程序设计目标</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BF%83%E8%B7%B3%E5%8D%8F%E8%AE%AE"><span class="toc-number">5.2.</span> <span class="toc-text">分布式系统的心跳协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E6%A0%87%E8%AF%86"><span class="toc-number">5.3.</span> <span class="toc-text">分布式系统中的进程标识</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A3%E7%A1%AE%E5%81%9A%E6%B3%95"><span class="toc-number">5.3.1.</span> <span class="toc-text">正确做法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E6%98%93%E4%BA%8E%E7%BB%B4%E6%8A%A4%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E7%A8%8B%E5%BA%8F"><span class="toc-number">5.4.</span> <span class="toc-text">构建易于维护的分布式程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E7%B3%BB%E7%BB%9F%E6%BC%94%E5%8C%96%EF%BC%88%E5%8D%87%E7%BA%A7%EF%BC%89%E5%81%9A%E5%87%86%E5%A4%87"><span class="toc-number">5.5.</span> <span class="toc-text">为系统演化（升级）做准备</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%88%E8%B7%A8%E8%AF%AD%E8%A8%80%E7%9A%84%EF%BC%89%E5%8F%AF%E6%8B%93%E5%B1%95%E6%B6%88%E6%81%AF%E6%A0%BC%E5%BC%8F"><span class="toc-number">5.5.1.</span> <span class="toc-text">（跨语言的）可拓展消息格式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E5%9B%9E%E5%BD%92%E6%B5%8B%E8%AF%95"><span class="toc-number">5.6.</span> <span class="toc-text">分布式程序的自动化回归测试</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%9A%84%E8%83%BD%E4%B8%8E%E4%B8%8D%E8%83%BD"><span class="toc-number">5.6.1.</span> <span class="toc-text">单元测试的能与不能</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E9%83%A8%E7%BD%B2%E3%80%81%E7%9B%91%E6%8E%A7%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E7%9A%84%E5%A2%83%E7%95%8C"><span class="toc-number">5.7.</span> <span class="toc-text">分布式系统部署、监控和进程管理的境界</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E6%A8%A1%E5%9E%8B"><span class="toc-number">6.</span> <span class="toc-text">C++编译链接模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E7%9A%84%E7%BC%96%E8%AF%91%E6%A8%A1%E5%9E%8B"><span class="toc-number">6.1.</span> <span class="toc-text">C++的编译模型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E9%81%8D%E7%BC%96%E8%AF%91"><span class="toc-number">6.1.1.</span> <span class="toc-text">单遍编译</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%90%8D%E5%AD%97%E6%9F%A5%E6%89%BE%EF%BC%9A"><span class="toc-number">6.1.1.1.</span> <span class="toc-text">名字查找：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E5%86%B3%E8%AE%AE"><span class="toc-number">6.1.1.2.</span> <span class="toc-text">函数重载决议</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%8D%E5%90%91%E5%A3%B0%E6%98%8E"><span class="toc-number">6.1.2.</span> <span class="toc-text">前向声明</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5"><span class="toc-number">6.2.</span> <span class="toc-text">链接</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">6.2.1.</span> <span class="toc-text">函数重载</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#inline%E5%87%BD%E6%95%B0"><span class="toc-number">6.2.2.</span> <span class="toc-text">inline函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF"><span class="toc-number">6.2.3.</span> <span class="toc-text">模板</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">6.2.4.</span> <span class="toc-text">虚函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99"><span class="toc-number">6.3.</span> <span class="toc-text">头文件的使用规则</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E5%AE%B3%E5%A4%84"><span class="toc-number">6.3.1.</span> <span class="toc-text">头文件的害处</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99-1"><span class="toc-number">6.3.2.</span> <span class="toc-text">头文件的使用规则</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E7%A8%8B%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%BA%93%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%84%E7%BB%87%E5%8E%9F%E5%88%99"><span class="toc-number">6.4.</span> <span class="toc-text">工程项目中库文件的组织原则</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8D%B1%E5%AE%B3"><span class="toc-number">6.4.1.</span> <span class="toc-text">动态库的危害</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E5%8D%B1%E5%AE%B3"><span class="toc-number">6.4.2.</span> <span class="toc-text">静态库的危害</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91"><span class="toc-number">6.4.3.</span> <span class="toc-text">源码编译</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E6%9C%89%E5%BF%85%E8%A6%81%E7%94%A8%E5%BA%93%E5%90%97%EF%BC%9F"><span class="toc-number"></span> <span class="toc-text">C++ 有必要用库吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8E%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">1.</span> <span class="toc-text">C++面向对象与虚函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%B4%E5%AE%9E%E7%9A%84C-%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.1.</span> <span class="toc-text">朴实的C++设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%BA%93%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="toc-number">1.2.</span> <span class="toc-text">程序库的二进制兼容性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="toc-number">1.2.1.</span> <span class="toc-text">二进制兼容性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%BC%9A%E7%A0%B4%E5%9D%8F%E5%BA%93%E7%9A%84-ABI"><span class="toc-number">1.2.2.</span> <span class="toc-text">什么情况会破坏库的 ABI</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E5%81%9A%E6%B3%95%E5%8F%AF%E8%83%BD%E6%98%AF%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%85%BC%E5%AE%B9%E7%9A%84"><span class="toc-number">1.2.3.</span> <span class="toc-text">哪些做法可能是二进制兼容的</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BA%86%E9%81%BF%E5%85%8D%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%8D%E5%85%BC%E5%AE%B9"><span class="toc-number">1.2.4.</span> <span class="toc-text">为了避免二进制不兼容</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E8%99%9A%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%BA%93%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.3.</span> <span class="toc-text">避免使用虚函数作为库的接口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%BA%93%E7%9A%84%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%B8%A4%E5%A4%A7%E7%94%A8%E9%80%94"><span class="toc-number">1.3.1.</span> <span class="toc-text">虚函数作为库的接口的两大用途</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%BC%8A%E7%AB%AF"><span class="toc-number">1.3.2.</span> <span class="toc-text">虚函数作为接口的弊端</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%BA%93%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%8E%A8%E8%8D%90%E5%81%9A%E6%B3%95"><span class="toc-number">1.4.</span> <span class="toc-text">动态库接口的推荐做法</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/.github.io/2025/08/02/muduo-part2/" title="muduo_part2">muduo_part2</a><time datetime="2025-08-02T07:25:23.000Z" title="发表于 2025-08-02 15:25:23">2025-08-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/.github.io/2025/04/08/muduo/" title="muduo">muduo</a><time datetime="2025-04-08T01:30:10.000Z" title="发表于 2025-04-08 09:30:10">2025-04-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/.github.io/2025/02/22/xv6/" title="xv6">xv6</a><time datetime="2025-02-22T13:38:24.000Z" title="发表于 2025-02-22 21:38:24">2025-02-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/.github.io/2024/12/04/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/" title="Linux高性能服务器编程">Linux高性能服务器编程</a><time datetime="2024-12-04T09:01:31.000Z" title="发表于 2024-12-04 17:01:31">2024-12-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/.github.io/2024/12/03/%E5%9B%BE%E8%A7%A3HTTP/" title="图解HTTP">图解HTTP</a><time datetime="2024-12-03T03:35:49.000Z" title="发表于 2024-12-03 11:35:49">2024-12-03</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://s2.loli.net/2023/02/26/9fQnztK2ImqyLwS.webp')"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2025 By John Doe</div><div class="footer_custom_text">Hi, welcome to my <a href="https://tjzhang-src.github.io/.github.io/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/.github.io/js/utils.js"></script><script src="/.github.io/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>function loadWaline () {
  function initWaline () {
    const waline = Waline.init(Object.assign({
      el: '#waline-wrap',
      serverURL: 'https://blog-comment-bfstu88s1-ttj2023.vercel.app/',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      path: window.location.pathname,
      comment: false,
    }, null))
  }

  const walineCSSLoad = document.getElementById('waline-css')

  if (typeof Waline === 'object') {
    walineCSSLoad ? initWaline() : getCSS('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.css','waline-css').then(initWaline)
  }
  else {
    getCSS('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.css','waline-css').then(() => {
      getScript('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.js').then(initWaline)
    })
  }
}

if ('Waline' === 'Waline' || !true) {
  if (true) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
  else setTimeout(loadWaline, 0)
} else {
  function loadOtherComment () {
    loadWaline()
  }
}</script><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'https://tjzhang-src.github.io/.github.io/2025/04/08/muduo/'
    this.page.identifier = '/.github.io/2025/04/08/muduo/'
    this.page.title = 'muduo'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }

  document.getElementById('darkmode').addEventListener('click', () => {
    setTimeout(() => window.disqusReset(), 200)
  })
}

if ('Waline' === 'Disqus' || !true) {
  if (true) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>