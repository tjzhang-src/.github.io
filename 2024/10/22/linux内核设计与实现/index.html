<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>linux内核设计与实现 | Welcome</title><meta name="author" content="John Doe"><meta name="copyright" content="John Doe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="内核简介单内核&amp;微内核单内核：作为一个单独的大过程运行，运行在单独的地址空间上（不就是单个进程吗？），内核之间的通信很方便。 微内核：内核的功能被划分为多个单独的过程，每一个过程叫做一个服务器，某些服务器运行在用户空间，有些运行在内核空间中，所以不同服务器之间的通过消息传递机制通信：系统采用了IPC机制。但是，IPC特别消耗资源，所以现在的微内核的服务器都运行在内核空间上，可以直接进行通信">
<meta property="og:type" content="article">
<meta property="og:title" content="linux内核设计与实现">
<meta property="og:url" content="https://tjzhang-src.github.io/.github.io/2024/10/22/linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/index.html">
<meta property="og:site_name" content="Welcome">
<meta property="og:description" content="内核简介单内核&amp;微内核单内核：作为一个单独的大过程运行，运行在单独的地址空间上（不就是单个进程吗？），内核之间的通信很方便。 微内核：内核的功能被划分为多个单独的过程，每一个过程叫做一个服务器，某些服务器运行在用户空间，有些运行在内核空间中，所以不同服务器之间的通过消息传递机制通信：系统采用了IPC机制。但是，IPC特别消耗资源，所以现在的微内核的服务器都运行在内核空间上，可以直接进行通信">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2024-10-22T02:19:31.000Z">
<meta property="article:modified_time" content="2024-11-30T12:04:48.588Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/.github.io/img/favicon.png"><link rel="canonical" href="https://tjzhang-src.github.io/.github.io/2024/10/22/linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//hm.baidu.com"/><link rel="stylesheet" href="/.github.io/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?4cc6526274b17acfe67a4be7d70e8d1c";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-FF1BJEGK51"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-FF1BJEGK51');
</script><script>const GLOBAL_CONFIG = { 
  root: '/.github.io/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'linux内核设计与实现',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-11-30 20:04:48'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (false) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/.github.io/archives/"><div class="headline">文章</div><div class="length-num">42</div></a><a href="/.github.io/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/.github.io/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/.github.io/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/.github.io/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/.github.io/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/.github.io/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/.github.io/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/.github.io/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/.github.io/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/.github.io/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s2.loli.net/2023/02/26/9fQnztK2ImqyLwS.webp')"><nav id="nav"><span id="blog-info"><a href="/.github.io/" title="Welcome"><span class="site-name">Welcome</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/.github.io/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/.github.io/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/.github.io/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/.github.io/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/.github.io/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/.github.io/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/.github.io/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/.github.io/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">linux内核设计与实现</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-22T02:19:31.000Z" title="发表于 2024-10-22 10:19:31">2024-10-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-30T12:04:48.588Z" title="更新于 2024-11-30 20:04:48">2024-11-30</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>37分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="linux内核设计与实现"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="内核简介"><a href="#内核简介" class="headerlink" title="内核简介"></a>内核简介</h3><h4 id="单内核-amp-微内核"><a href="#单内核-amp-微内核" class="headerlink" title="单内核&amp;微内核"></a>单内核&amp;微内核</h4><p>单内核：作为一个单独的大过程运行，运行在单独的地址空间上（不就是单个进程吗？），内核之间的通信很方便。</p>
<p>微内核：内核的功能被划分为多个单独的过程，每一个过程叫做一个服务器，某些服务器运行在用户空间，有些运行在内核空间中，所以不同服务器之间的通过消息传递机制通信：系统采用了IPC机制。但是，IPC特别消耗资源，所以现在的微内核的服务器都运行在内核空间上，可以直接进行通信。</p>
<h4 id="Linux内核的特点"><a href="#Linux内核的特点" class="headerlink" title="Linux内核的特点"></a>Linux内核的特点</h4><ul>
<li>可以动态加载内核模块</li>
<li>支持SMP机制，</li>
<li>内核可以抢占，在内核的任务优先执行</li>
<li>对线程的支持，内核不区分线程、进程，只是有些共享资源而已</li>
</ul>
<h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><h4 id="进程描述符与任务结构"><a href="#进程描述符与任务结构" class="headerlink" title="进程描述符与任务结构"></a>进程描述符与任务结构</h4><p>内核将进程的列表存放在叫任务队列的双向循环链表中，链表的每一项都是类型为<code>task_struct</code>的进程描述符的东西（ucos的TCB）。他其中包含的内容有：打开的文件、地址空间、挂起的信号等。</p>
<h5 id="分配进程描述符"><a href="#分配进程描述符" class="headerlink" title="分配进程描述符"></a>分配进程描述符</h5><p>在内核栈的尾端会存放任务的thread_info, 他其中会包含指向进程描述符的指针：</p>
<img src="/.github.io/2024/10/22/linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20241022105554144.png" class title="image-20241022105554144">

<h5 id="进程描述符的存放"><a href="#进程描述符的存放" class="headerlink" title="进程描述符的存放"></a>进程描述符的存放</h5><p>进程描述符中的state描述了当前的状态，包含如下五个：</p>
<ul>
<li><p>运行：可执行的；要么正在执行，要么在等待执行（按照一般的逻辑，这里要分成就绪态和运行态，不知道这里为什么没有分开呢）</p>
<blockquote>
<p>GPT:</p>
<p>在 Linux 的进程状态中，<code>TASK_RUNNING</code> 表示进程处于就绪态或运行态，因此没有单独细分出就绪态。这种设计简化了状态管理，因为就绪进程可以立即被调度运行，而系统只需关注运行中的进程。尽管就绪态和运行态是不同的概念，实际操作中将它们统一处理有助于提高效率和简化调度算法。</p>
</blockquote>
</li>
<li><p>可中断：进程正被阻塞，等待某些条件达成,<strong>收到信号后可以提前唤醒准备运行</strong>（这里的信号应该指的是SIGINT、SIGKILL等信号，收到信号就会进入中断，与该任务等待的条件是两个东西）</p>
</li>
<li><p>不可中断：进程正被阻塞，等待某些条件达成，<strong>收到信号也不会唤醒</strong></p>
</li>
<li><p>__TASK_TRACED:被跟踪的进程，如ptrace对程序进行跟踪，</p>
</li>
<li><p>停止：进程被停止执行，比如收到SIGSTOP、SIGTSTP等。</p>
</li>
</ul>
<img src="/.github.io/2024/10/22/linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20241022111151731.png" class title="image-20241022111151731">

<h5 id="设置当前的进程状态"><a href="#设置当前的进程状态" class="headerlink" title="设置当前的进程状态"></a>设置当前的进程状态</h5><p>内核可以通过<code>set_task_state(task, state)</code>来调整进程的状态。</p>
<h5 id="进程上下文"><a href="#进程上下文" class="headerlink" title="进程上下文"></a>进程上下文</h5><p>一般程序在用户空间执行，一个程序执行了系统调用或者出发了异常，就陷入了内核空间，这时，我们说，内核代表进程执行并处于进程上下文中。</p>
<blockquote>
<p>关于进程上下文与中断上下文：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/stemon/p/5148869.html">进程上下文和中断上</a></p>
<p>处理器总处于以下状态中的一种：</p>
<ol>
<li>内核态，运行于进程上下文，内核代表进程运行于内核空间；</li>
<li>内核态，运行于中断上下文，内核代表硬件运行于内核空间；</li>
<li>用户态，运行于用户空间。</li>
</ol>
<p>Linux内核工作在进程上下文或者中断上下文。提供系统调用服务的内核代码代表发起系统调用的应用程序运行在进程上下文；另一方面，中断处理程序，<strong>异步运行</strong>在中断上下文。中断上下文和特定进程无关。</p>
<p>系统调用的详细过程：<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8">系统调用</a></p>
<p>Linux 在x86上的系统调用通过 int 80h 实现，用<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8F%B7&action=edit&redlink=1">系统调用号</a>来区分入口函数。操作系统实现系统调用的基本过程是：（可以看到系统调用函数是处于中断中的）</p>
<ol>
<li>应用程序调用库函数（API）；</li>
<li>API 将系统调用号存入 EAX，然后通过中断调用使系统进入内核态；</li>
<li>内核中的中断处理函数根据系统调用号，调用对应的内核函数（系统调用）；</li>
<li>系统调用完成相应功能，将返回值存入 EAX，返回到中断处理函数；</li>
<li>中断处理函数返回到 API 中；</li>
<li>API 将 EAX 返回给应用程序。</li>
</ol>
<p>应用程序调用系统调用的过程是：</p>
<ol>
<li>把系统调用的编号存入 EAX；</li>
<li>把函数参数存入其它通用寄存器；</li>
<li>触发 0x80 号中断（int 0x80）。</li>
</ol>
</blockquote>
<h5 id="进程家族树"><a href="#进程家族树" class="headerlink" title="进程家族树"></a>进程家族树</h5><p>所有进程都是PID为1的init进程的后代</p>
<p>每个进程描述符会包含指向父进程描述符的指针与子进程链表的指针。</p>
<p>可以通过任何一个进程描述符访问他的父进程，最终达到init进程。</p>
<p>可以通过任务队列访问系统中的所有任务。</p>
<img src="/.github.io/2024/10/22/linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20241022113135899.png" class title="image-20241022113135899">

<h4 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h4><p>常见办法是：先fork在exec组合运行</p>
<h5 id="写时拷贝"><a href="#写时拷贝" class="headerlink" title="写时拷贝"></a>写时拷贝</h5><blockquote>
<p>因为fork后一般要指向exec开启新的进程。如果fork后，立刻进行第一次拷贝，然后exec又会进行第二次拷贝，这样第一次拷贝就是多余的。</p>
</blockquote>
<p>写时拷贝是可以推迟甚至免除拷贝数据的技术，fork时，内核不复制整个地址空间，而是让父子进程共享同一个拷贝。只有在需要写入时，数据才会被复制，在此之前都是以只读形式共享的。（调用exec后，就会建立新的地址空间了）</p>
<h5 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h5><p>LInux中的fork()、vfork()、__clone()等库函数都通过各自需要的参数去调用clone(),然后clone()再去调用do_fork()。</p>
<p>do_fork完成了创建中的大部分工作。他会先调用copy_process函数，然后让进程开始运行。copy_process成功返回后，一般会让子进程先执行（因为如果子进程执行了exec，就可以赶紧处理了）</p>
<p>vfork除了不拷贝父进程的页表项，vfork系统调用与fork的功能都是相同的。</p>
<h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><p>LInux内核没有线程的概念，LInux的线程实际上就是与其他进程共享某些资源（地址空间）的进程，他也有自己的task_struct,看起来就是一个普通的进程。</p>
<blockquote>
<p>这种实现方式与Windows差异很大，这些系统在内核提供了专门支持线程的机制</p>
</blockquote>
<h5 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h5><p>创建过程与进程类似，在调用clone时需要传入额外的参数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>上面的代码共享了地址空间、文件系统资源、文件描述符、信号处理函数。</p>
<h5 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a>内核线程</h5><p>内核为了在后台完成一些任务，定义了一些内核线程–独立运行在<strong>内核空间</strong>的标准线程。内核线程与普通线程的唯一区别在于没有独立的地址空间，他只在内核空间运行。</p>
<h4 id="进程终结"><a href="#进程终结" class="headerlink" title="进程终结"></a>进程终结</h4><p>终结的原因：exit系统调用，主程序的return，不能处理与忽视的信号</p>
<p>终结首先要释放自己的资源，然后通知父进程。终结的工作主要靠do_exit来完成，他会重新设置进程描述符中的标志成员、释放内存、递减文件描述符等、向父进程发信号、给子进程找养父、最后调用schedule切换到新的进程，这是该进程执行的最后一段代码（好伤感）。</p>
<p>到这里，进程的大部分资源都已经被释放，还剩下内核栈、thread_info、task_struct结构还保存着，待父进程查看(waitpid?)后通知内核，这些最后的资源也将被释放。</p>
<h5 id="删除进程描述符"><a href="#删除进程描述符" class="headerlink" title="删除进程描述符"></a>删除进程描述符</h5><p>释放剩下的资源等，</p>
<h5 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h5><p>如果父进程在子进程之前退出，那么必须有机制保证子进程找到一个新的父亲。否则这些孤儿进程在退出时会变成僵死状态，浪费内存。（其实上面的进程终结部分也说了：会给子进程找继父）</p>
<h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><h4 id="多任务"><a href="#多任务" class="headerlink" title="多任务"></a>多任务</h4><p>LInux提供了<strong>抢占式的</strong>多任务模式。（轮转调度是实现抢占式调度的一种方法）</p>
<h4 id="LInux的进程调度"><a href="#LInux的进程调度" class="headerlink" title="LInux的进程调度"></a>LInux的进程调度</h4><p>Linux2.5版本引入了O（1）调度程序，他性能好，但是调度交互进程有些缺点。</p>
<p>LInux2.6版本引入了RSDL算法来提高交互性能，将公平调度的概念引入了Linux调度程序，他最终取代了O（1）调度算法，被称为完全公平调度算法CFS。</p>
<h4 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h4><h5 id="IO消耗型和处理器消耗型进程"><a href="#IO消耗型和处理器消耗型进程" class="headerlink" title="IO消耗型和处理器消耗型进程"></a>IO消耗型和处理器消耗型进程</h5><p>进程可以分为这两类：IO消耗型（键盘输入）和处理器消耗型进程（MATLAB），对于处理器消耗型，应该尽可能减低调度频率，延长运行时间。调度策略需要在两个矛盾的目标间找平衡：进程响应迅速（响应时间：从发出请求到系统开始响应的时间间隔）和系统利用率高。LInux更倾向于优先调度IO消耗型进程。</p>
<h5 id="进程优先级"><a href="#进程优先级" class="headerlink" title="进程优先级"></a>进程优先级</h5><p>根据优先级进行调度。Linux采用了两种不同的优先级范围，</p>
<ul>
<li>第一种是nice值（意味着该进程<strong>受到优待的程度</strong>），范围是-20到19，默认为0，越小优先级越高。在Linux中，优先级高的时间片比例高。</li>
<li>第二种是实时优先级，范围是0到99，值越高越优先，</li>
</ul>
<h5 id="时间片"><a href="#时间片" class="headerlink" title="时间片"></a>时间片</h5><p>不同的时间片造成的影响是不同的，不同类的进程需要不同的时间片。LInux的CFS调度器不直接分配时间片，而是分配处理器的使用比例，这个比例还会受到nice的影响。</p>
<p>Linux使用的CFS调度器，如果新程序消耗的处理器占比比当前任务小，则将新进程离开投入运行，进行抢占。否则，推迟运行。</p>
<h5 id="调度策略的活动"><a href="#调度策略的活动" class="headerlink" title="调度策略的活动"></a>调度策略的活动</h5><p>假设文本编辑器与视频编码器，一种做法是分配给编辑器更高的优先级与更多的时间片。Linux采用了不同的方法，处理器使用比，比如nice设为50%，则他们会平方处理器时间。当文本编辑器被唤醒后，CFS注意到文本编辑器的实际使用时间很少，为了兑现公平的承诺，会立刻抢占视频编码程序。</p>
<h4 id="Linux调度算法"><a href="#Linux调度算法" class="headerlink" title="Linux调度算法"></a>Linux调度算法</h4><h5 id="调度器类"><a href="#调度器类" class="headerlink" title="调度器类"></a>调度器类</h5><p>CFS是真的<strong>普通进程</strong>的调度类，SCHED_NORMAL.(普通进程与实时进程)。</p>
<h5 id="Unix中的进程调度"><a href="#Unix中的进程调度" class="headerlink" title="Unix中的进程调度"></a>Unix中的进程调度</h5><p>如何使用nice值映射到绝对的时间，几个问题：</p>
<ul>
<li>如果将nice值对应到处理器的绝对时间：不合理</li>
<li>相对nice值，nice0和nice1对应100ms和95ms，而nice18和nice19对应10ms和5ms，时间翻倍了，这是不合理的。</li>
<li>定时器节拍，时间片应该是节拍的整数倍（引入CFS的唯一原因）</li>
<li>给刚唤醒的进程提升优先级，</li>
</ul>
<p>这些都是由于分配绝对的时间片造成的，CFS的方法是对时间片分配方式重新设计。</p>
<h5 id="公平调度"><a href="#公平调度" class="headerlink" title="公平调度"></a>公平调度</h5><p>CFS不分配时间片，而是允许每个进程运行一段时间，选择运行最少的进程作为下一个运行进程。假设20ms为一个周期，有二十个相同优先级的任务，每个都分得1ms。为了防止运行时间过短，设置一个时间片底线为1ms。所有进程获得的处理器时间由他自己与其他进程的nice<strong>差值决定</strong>的。</p>
<h4 id="Linux调度的实现"><a href="#Linux调度的实现" class="headerlink" title="Linux调度的实现"></a>Linux调度的实现</h4><p>主要包含四个部分：时间记账、进程选择、调度器入口、睡眠和唤醒</p>
<h5 id="时间记账"><a href="#时间记账" class="headerlink" title="时间记账"></a>时间记账</h5><p>实体结构体是sched_entity, 为task_struct中的se成员。其中的vruntime保存的是给定进程的运行时间。（<strong>vruntime&#x3D;实际运行时间 * （nice为0的权重&#x2F;当前任务nice对应的权重）</strong>）</p>
<h5 id="进程选择"><a href="#进程选择" class="headerlink" title="进程选择"></a>进程选择</h5><p>如果是一个完美的多任务处理器，那么所有进程的vruntime将保持一致。选择下一个算法时，会选择最小vruntime值的进程。</p>
<p>CFS使用红黑树来组织可运行进程队列。</p>
<ul>
<li>挑选下一个任务，即红黑树最左边那个</li>
<li>向树中加入进程，</li>
<li>从树中删除进程（发生在阻塞或终止时）</li>
</ul>
<h5 id="调度器入口"><a href="#调度器入口" class="headerlink" title="调度器入口"></a>调度器入口</h5><p>入口时schedule，找到最高优先级的调度类后，然后问那个是下一个该运行的进程。</p>
<h5 id="休眠与唤醒"><a href="#休眠与唤醒" class="headerlink" title="休眠与唤醒"></a>休眠与唤醒</h5><p>当需要等待一些事件时，比如文件IO,硬件事件，信号量，会将自己标记为休眠态，然后从红黑树中移除，放到等待队列中。（两种休眠态：可中断、不可中断）</p>
<ul>
<li>等待队列，由等待某些事件的进程组成的链表。</li>
</ul>
<p>为了避免虚假唤醒，一般会通过一个while循环来保证。</p>
<h4 id="抢占与上下文"><a href="#抢占与上下文" class="headerlink" title="抢占与上下文"></a>抢占与上下文</h4><p>找出下一个进程后，schedule会调用context_switch函数来切换上下文。</p>
<p>切换进程的内存映射</p>
<p>切换处理器状态，包括栈、寄存器等。</p>
<p>一般来说，返回到用户空间时，需要检查need_resched标志，如果被设置，需要重新进行调度。</p>
<h5 id="用户抢占"><a href="#用户抢占" class="headerlink" title="用户抢占"></a>用户抢占</h5><img src="/.github.io/2024/10/22/linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20241023150744723.png" class title="image-20241023150744723">

<h5 id="内核抢占"><a href="#内核抢占" class="headerlink" title="内核抢占"></a>内核抢占</h5><p>只要重新调度是安全的，就可以在任何时间抢占正在执行的内核任务。从中断返回到内核空间时，内核会检查need_resched和preempt_count（锁的个数）的值来判断能否安全的抢占。如果内核的进程被阻塞了，也会显示的发生内核抢占。</p>
<img src="/.github.io/2024/10/22/linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20241023155012129.png" class title="image-20241023155012129">

<h4 id="实时调度策略"><a href="#实时调度策略" class="headerlink" title="实时调度策略"></a>实时调度策略</h4><ul>
<li>Linux提供了两种实时调度策略：SCHED_FIFO、SCHED_RR。</li>
<li>而普通的非实时的调度策略是SHCED_NORMAL</li>
</ul>
<p>实时策略不被CFS管理。</p>
<ul>
<li>SCHED_FIFO实现了先进先出的调度算法。只要该级别进程处于可执行状态，就会一直执行，直到被阻塞或显示的释放处理器为止。只有更高优先级的实时进程才能抢占该进程，更低级别的实时进程只能一直等待。（所有实时进程会比普通进程先得到调度）</li>
<li>SCHED_RR，与上面基本类似，可以看成带有时间片的SCHED_FIFO。时间片用完时，同一优先级的其他进程被调度。</li>
</ul>
<p>实时进程优先级范围是0-99，普通进程的优先级是100-139（是根据nice值确定的是哪个优先级）</p>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><h4 id="与内核通信"><a href="#与内核通信" class="headerlink" title="与内核通信"></a>与内核通信</h4><p>系统调用的作用有三个（别太在意）：</p>
<ul>
<li>为用户空间提供了硬件的抽象接口，读文件就不用管具体的文件类型</li>
<li>内核可以对部分系统调用进行裁决，保证安全</li>
<li>管理对硬件的访问</li>
</ul>
<h4 id="API、POSIX和C库"><a href="#API、POSIX和C库" class="headerlink" title="API、POSIX和C库"></a>API、POSIX和C库</h4><p>程序通过用户空间的应用编程接口而不是系统调用来编程。</p>
<img src="/.github.io/2024/10/22/linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20241023213008471.png" class title="image-20241023213008471">

<p>C库实现了Unix系统的主要API。</p>
<h4 id="系统调用-1"><a href="#系统调用-1" class="headerlink" title="系统调用"></a>系统调用</h4><p>要访问系统调用，一般是通过C库的函数来进行的。一般会返回一个值，非零代表错误，出错时会把错误码写入errno全局变量，可通过perror翻译。</p>
<h5 id="系统调用号"><a href="#系统调用号" class="headerlink" title="系统调用号"></a>系统调用号</h5><p>每个系统调用都有一个系统调用号。</p>
<h4 id="系统调用处理程序"><a href="#系统调用处理程序" class="headerlink" title="系统调用处理程序"></a>系统调用处理程序</h4><blockquote>
<p>软件中断与软中断<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/360683396">软中断与软件中断 - 知乎</a></p>
<p>软件中断：属于同步中断（CPU内部引发的中断，也叫异常,与硬件中断对应），工作在进程上下文</p>
<p>软中断：其实叫中断下半部，类似硬件中断机制，是异步中断，工作在中断上下文</p>
</blockquote>
<p>用户空间的程序在运行时没法直接执行内核空间的函数。所以，应用程序应该以某种方式告诉系统，自己要执行一个系统调用，让系统切换到内核态，从而可以代表应用程序在内核空间执行。</p>
<p>通知内核的机制是通过软件实现的，通过引发一个异常来促使系统切换到内核态执行中断程序（系统调用处理程序）。软件中断中断号是128，通过int $0x80指令可以触发该中断，这会导致系统切换到内核态并执行128号异常处理程序（即系统调用处理程序）。</p>
<h5 id="指定恰当的系统调用"><a href="#指定恰当的系统调用" class="headerlink" title="指定恰当的系统调用"></a>指定恰当的系统调用</h5><p>其实前面的0x80指的是中断号，为了指定具体的系统调用还需要系统调用的编号，这个是通过<strong>eax寄存器</strong>传给内核的。</p>
<h5 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h5><p>如果需要传递额外的参数，最简单的办法是把这些参数也存放在寄存器里，ebx、ecx、edx、esi、edi按照顺序存放前五个参数。</p>
<img src="/.github.io/2024/10/22/linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20241024190421211.png" class title="image-20241024190421211">

<h4 id="系统调用的实现"><a href="#系统调用的实现" class="headerlink" title="系统调用的实现"></a>系统调用的实现</h4><p>每个系统调用永远都有一个单一并明确的用途。尽量然系统调用更加通用。</p>
<h5 id="参数验证"><a href="#参数验证" class="headerlink" title="参数验证"></a>参数验证</h5><p>系统调用必须检查所有的参数是否合法有效。系统调用在内核空间执行，如果输入了不合法的东西，对于系统的安全有很大影响。（比如检查文件描述符，进程pid是否正确，指针是否有效）</p>
<p>如果参数有指针，内核必须保证：指针指向的内存区域属于用户空间，却不能是内核空间。</p>
<p>内核提供了两个方法来完成必须的检查以及内核空间与用户空间的来回拷贝。copy_to_user和copy_from_user。</p>
<h4 id="系统调用上下文"><a href="#系统调用上下文" class="headerlink" title="系统调用上下文"></a>系统调用上下文</h4><p>内置在执行系统调用的时候处于进程上下文，current指针指向的是当前的任务，即引发系统调用的哪个进程。在进程上下文中，内核可以休眠并且可以被抢占。</p>
<h5 id="绑定一个系统调用的最后步骤"><a href="#绑定一个系统调用的最后步骤" class="headerlink" title="绑定一个系统调用的最后步骤"></a>绑定一个系统调用的最后步骤</h5><p>写完后，需要完成如下三步：</p>
<ul>
<li>在系统调用表增加一个表项</li>
<li>定义系统调用号</li>
<li>将系统调用写进内核映像</li>
</ul>
<h5 id="从用户空间访问系统调用"><a href="#从用户空间访问系统调用" class="headerlink" title="从用户空间访问系统调用"></a>从用户空间访问系统调用</h5><p>一种方式是通过C库访问</p>
<p>另一种方式是通过Linux提供的一组宏访问</p>
<h3 id="中断和中断处理"><a href="#中断和中断处理" class="headerlink" title="中断和中断处理"></a>中断和中断处理</h3><h4 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h4><p>中断本质上是一种电信号，由硬件设备发给处理器。</p>
<p>异常，与中断的差异在于是由软件引起的。异常是由处理器本身产生的同步中断。</p>
<p>可以分成上下两部分，上半部分负责紧急任务的处理，如拷贝网卡中数据包，拷贝完则中断结束，下半部分负责处理和操作数据包。</p>
<h4 id="注册中断"><a href="#注册中断" class="headerlink" title="注册中断"></a>注册中断</h4><p>通过<code>int request_irq(unsigned int irq, irq_hander_t handler, unsigned long flags, const char *name, void *dev)</code>注册一个中断处理程序，第一个参数代表要分配的中断号，第二个参数指的是一个中断处理程序。</p>
<h5 id="中断处理程序标志"><a href="#中断处理程序标志" class="headerlink" title="中断处理程序标志"></a>中断处理程序标志</h5><p>flag可以为0，也可以为：</p>
<ul>
<li><p>IRQF_DISABLED, 设置后，内核在处理中断时，会禁止其他中断</p>
</li>
<li><p>IRQF_SAMPE_RANDOM，表示该中断内核熵池可以有贡献（内核熵池负责从随机事件导出真正的随机数），如果中断是一个以预知的速率触发的，不要设置这个参数。</p>
</li>
<li><p>IRQF_SHARED, 一般来说，每个中断线（不是中断号，应该和STM32中的EXTI_Line很类似，外部设备一般都要连上这种线才能向CPU发中断，不过Linux也需要处理这么底层的事情么？）只能有一个处理程序，开启这个标志后，多个处理程序可以注册在同一个中断线上。</p>
<blockquote>
<p>from gpt</p>
<p>中断号和中断线不一定是一一对应的关系。通常情况下，多个设备可以共享同一条中断线，这种情况称为“共享中断”。在这种情况下，所有共享同一条中断线的设备在发生中断时，CPU接收到的信号只能表示有某个设备请求了中断。</p>
<p>当中断请求发生时，CPU会根据中断线的信号来判断哪个设备需要处理。接着，它会通过其他机制（例如询问设备状态或使用优先级）来确定具体是哪个设备触发了中断，然后根据该设备的类型来分配中断号。</p>
<p>因此，尽管每条中断线通常会有一个或多个中断号与之关联，但它们之间并不一定是一一对应的关系。</p>
</blockquote>
</li>
</ul>
<p>request_irq申请不成功时，返回非零值，常见的错误是<code>-EBUSY</code>,代表中断线已经在使用。</p>
<h4 id="中断上下文"><a href="#中断上下文" class="headerlink" title="中断上下文"></a>中断上下文</h4><h4 id="中断控制"><a href="#中断控制" class="headerlink" title="中断控制"></a>中断控制</h4><p>为了实现同步，需要对中断进行控制，</p>
<ul>
<li>锁，防止其他处理器或者其他进程的并发访问。</li>
<li>禁止中断，防止其他中断处理程序的并发访问</li>
</ul>
<h5 id="禁止和激活中断"><a href="#禁止和激活中断" class="headerlink" title="禁止和激活中断"></a>禁止和激活中断</h5><p>禁用<strong>当前处理器</strong>中断的语句<code>local_irq_disable()</code></p>
<h5 id="禁止中断线"><a href="#禁止中断线" class="headerlink" title="禁止中断线"></a>禁止中断线</h5><p><code>disable_irq()</code></p>
<h3 id="中断下半部"><a href="#中断下半部" class="headerlink" title="中断下半部"></a>中断下半部</h3><h4 id="下半部"><a href="#下半部" class="headerlink" title="下半部"></a>下半部</h4><p>理想情况下，所以工作都应该由下半部去完成，但中断处理程序注定要完成一些工作：对中断进行确认、拷贝数据。剩下的工作由下半部完成。8</p>
<h5 id="下半部的环境"><a href="#下半部的环境" class="headerlink" title="下半部的环境"></a>下半部的环境</h5><p>实现方式：</p>
<ul>
<li>BH（当前已废弃）</li>
<li>任务队列（被工作队列取代）</li>
<li>软中断和tasklet，软中断是一组静态定义的下半部接口，有32个。两个类型相同的软中断也可以在不同处理器同时执行。tasklet是简单易用的软中断。类型相同的tasklet不能在不同的处理器同时执行。向网络这样对性能要求高的就会使用软中断。</li>
</ul>
<h4 id="软中断"><a href="#软中断" class="headerlink" title="软中断"></a>软中断</h4><p>软中断由<code>softirq_action</code>表示，内核定义了一个包含有32个该结构体的数组，最大数目没法变化。只有中断能抢占软中断，其他的（甚至是同类型的）软中断可以在其他处理器上执行。软中断不能动态的注册或注销，是在编译器静态分配的。</p>
<p><strong>执行</strong></p>
<p>中断处理程序返回前会标记软中断，让他在稍后被执行，在什么时候检查软中断：</p>
<ul>
<li>从硬件中断返回时</li>
<li>在ksoftirqd线程</li>
<li>在那些显示检查的代码中</li>
</ul>
<h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p>目前只有网络和SCSI直接使用软中断。内核定时器和tasklete都是建立在软中断之上的。</p>
<ul>
<li>编译时，分配索引</li>
</ul>
<img src="/.github.io/2024/10/22/linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20241113213034728.png" class title="image-20241113213034728">

<ul>
<li>运行时，注册处理程序，第一个参数是前面定义的索引号，第二个是处理函数。为了避免不同处理器运行相同处理程序造成的问题，大部分软中断处理程序使用单处理器数据（无需加锁）。</li>
</ul>
<blockquote>
<p>使用软中断主要原因就是其可以在多个处理器运行相同程序，如果没有这个需求，使用tasklet吧</p>
</blockquote>
<ul>
<li>触发软中断，完成上面两部后，raise_softirq（通常在中断处理函数中执行这个命令）会将一个软中断设置为挂起状态，下次调用do_softirq时，该软中断的处理程序就会立刻执行。</li>
</ul>
<h4 id="tasklet"><a href="#tasklet" class="headerlink" title="tasklet"></a>tasklet</h4><p>一种利用软中断实现的下半部机制。</p>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p>首先在中断处理程序中时，返回前会执行tasklet_schedule, 在其中会</p>
<ul>
<li>将需要调度的tasklet加到每一个处理器的一个tasklet或者tasklet_hi_vec链表上去，</li>
<li>唤醒软中断。</li>
</ul>
<p>在do_softirq时，因为前文唤醒了软中断，所以会指向相应的软中断处理程序：tasklet_action, tasklet_hi_action:</p>
<ul>
<li>遍历tasklet链表，如果是多处理器系统，检测该tasklet是否在其他处理器运行（是则跳到下一个tasklet），不断循环</li>
</ul>
<h5 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h5><p><strong>ksoftirqd</strong></p>
<p>为了避免软中断自己触发自己，一直占用CPU导致用户空间没法使用CPU。会将重复触发的软中断放到优先级最低的内核线程上运行，这能保证过量的软中断终会被处理，也能留给用户程序足够的处理数据。</p>
<h4 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h4><p>工作队列也是一种推迟执行的方法，工作队列允许将任务交给内核进程执行，如果推迟执行的任务需要睡眠，就选择工作队列，否则使用软中断&#x2F;tasklet。（软中断&#x2F;tasklet在中断上下文运行，而任务队列是在任务上下文运行）</p>
<blockquote>
<p>from GPT, 什么是中断上下文：</p>
<p><strong>中断上下文的特点</strong></p>
<ul>
<li><strong>无进程上下文</strong>：<ul>
<li>在中断上下文中，CPU 不再关联具体的用户进程，也没有用户态堆栈。</li>
<li>中断处理代码无法直接访问用户态数据，所有操作基于内核态的资源。</li>
</ul>
</li>
<li><strong>禁止阻塞</strong>：<ul>
<li>不能调用可能引发睡眠的函数（如 <code>schedule()</code>、<code>mutex_lock()</code>）。</li>
<li>因为中断上下文的执行是不可中断的，无法调度到其他任务。</li>
</ul>
</li>
<li><strong>优先级高</strong>：<ul>
<li>中断上下文会抢占普通进程和某些低优先级的内核任务（如软中断和工作队列）。</li>
<li>高优先级的中断甚至可以打断低优先级的中断。</li>
</ul>
</li>
<li><strong>使用独立的中断堆栈</strong>：<ul>
<li>每个 CPU 有一个固定的中断堆栈，用于处理中断上下文的局部变量和调用栈。</li>
</ul>
</li>
</ul>
</blockquote>
<h5 id="工作队列的实现"><a href="#工作队列的实现" class="headerlink" title="工作队列的实现"></a>工作队列的实现</h5><p>工作队列可以创建一个工作者线程，来为其他部分处理需要推后执行的工作。提供了一个缺省的工作者线程名为events&#x2F;n，n为处理器的编号。</p>
<blockquote>
<p>通常内核线程没法访问用户空间，只有在发生系统调用时，内核会代表用户空间的进程运行，此时他才能访问用户空间。</p>
</blockquote>
<img src="/.github.io/2024/10/22/linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20241115201729562.png" class title="image-20241115201729562">

<img src="/.github.io/2024/10/22/linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20241115201748217.png" class title="image-20241115201748217">

<h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><ul>
<li>下半部和进程访问可以相同的数据，那么进程在访问数据前，需要禁下半部的处理并加锁（因为下半部是在中断上下文，不能被阻塞，所以只能在进程中提前做好处理；应该是谁低级，谁做处理）</li>
<li>下半部和中断访问可以相同的数据，那么下半部在访问数据前，需要禁中断并加锁</li>
</ul>
<h3 id="内核同步"><a href="#内核同步" class="headerlink" title="内核同步"></a>内核同步</h3><p>要对共享数据进行保护。</p>
<ul>
<li><p>没有对称多处理器时，并发访问数据的方法很容易识别，要么是发生了中断，要么是内核代码明确请求调度。（把这两种方法禁了就能保护共享数据）</p>
</li>
<li><p>支持对称多处理器时，内核可以运行在不同的处理器上。Linux2.6就支持抢占式内核，意味着内核线程能被调度程序抢占。（<strong>同一段内核代码可以运行在不同的处理器上，但同一个线程只能运行在一个处理器上</strong>）</p>
</li>
</ul>
<h4 id="临界区和竞争条件"><a href="#临界区和竞争条件" class="headerlink" title="临界区和竞争条件"></a>临界区和竞争条件</h4><p>临界区是访问共享数据的代码段。临界区不能被多个线程访问，临界区不能被打断。<strong>避免并发（协调进程的执行顺序）称为同步。</strong></p>
<h5 id="为什么要保护"><a href="#为什么要保护" class="headerlink" title="为什么要保护"></a>为什么要保护</h5><p>举例，两人用同一个银行账户取钱。</p>
<h5 id="单个变量"><a href="#单个变量" class="headerlink" title="单个变量"></a>单个变量</h5><p>处理器提供了指令来原子的读、写、增加变量。</p>
<p>内核也提供了实现原子操作的接口</p>
<h4 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h4><ul>
<li>有些指令体系提供了专门的指令来对<strong>某些值</strong>进行计算和比较。</li>
<li>如果要对不定长度的临界区进行保护，需要使用锁，</li>
</ul>
<p>锁有不同形式：</p>
<ul>
<li>当锁被其他线程持有时，会进行循环并检测是否获得锁，忙等待</li>
<li>当锁被其他线程持有时，会进行睡眠</li>
</ul>
<p>锁的作用就是把<strong>临界区缩小到加锁和开锁之间的代码</strong>（为了保证整段代码的原子性，需要保证开锁和加锁两个代码的原子性），而锁是由原子操作实现的，很多处理器都实现了测试指令，比如x86的compare和exchange。</p>
<h5 id="造成并发执行的原因"><a href="#造成并发执行的原因" class="headerlink" title="造成并发执行的原因"></a>造成并发执行的原因</h5><p>并发和并行都会导致竞争条件。</p>
<p><strong>内核中的代码</strong>也有类似的可能导致并发执行的原因。</p>
<ul>
<li>中断——可以随时打断当前正在执行的代码</li>
<li>软中断和tasklet——内核可以在任何时刻唤醒这两者，打断正在执行的代码</li>
<li>内核抢占——内核任务也能被其他任务抢占</li>
<li>睡眠</li>
<li>对称多处理</li>
</ul>
<p>比较常见的错误：</p>
<ul>
<li>一段内核在操作某<strong>一个资源</strong>时，产生了一个中断，该中断也会访问<strong>该资源</strong>（其实按理说，临界区不应该产生中断，毕竟只要操作系统掌握了CPU，他就可以进行调度）</li>
<li>一段内核在操作某<strong>一个资源</strong>时，可以被抢占</li>
<li>一段内核在临界区睡眠</li>
</ul>
<p>真正困难的是找到潜在并发执行的可能（重点是<strong>共享的数据和相应的临界区</strong>），并防止并发。</p>
<p><strong>中断安全代码</strong>——中断处理程序中能避免并发访问的代码</p>
<p><strong>SMP安全代码</strong>——SMP中能避免并发访问的代码</p>
<p><strong>抢占安全代码</strong>——内核抢占时能避免安全访问的代码</p>
<h5 id="要保护什么"><a href="#要保护什么" class="headerlink" title="要保护什么"></a>要保护什么</h5><p>可能被并发访问的代码都需要保护。先看看哪些资源不用被保护：</p>
<ul>
<li>线程的局部数据，（这些数据只会被该线程访问，不可能被并发访问）</li>
</ul>
<p>大多数内核数据结构需要加锁，如果其他线程可以访问这些数据，就需要加锁。</p>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>一些避免的简单规则：</p>
<ul>
<li>按顺序加锁（记得在代码中对锁的使用加上注释），最好按照申请的相反顺序释放锁</li>
</ul>
<h4 id="争用和拓展性"><a href="#争用和拓展性" class="headerlink" title="争用和拓展性"></a>争用和拓展性</h4><p>如果锁处于高度争用状态，就是指有多个线程等待获得该锁，锁的作用就是让进程以串行方式访问资源，所以锁会降低系统的性能。被高度争用的锁会成为系统的瓶颈。</p>
<p>在Linux2.6的内核中，内核加的锁是非常细的粒度（最开始，粒度很大，同一时刻只允许一个任务在内核运行）。</p>
<p>当多处理器出现时，如果维护一个全局的运行队列，供所有CPU访问，那么非常低效，如果为每个处理器维护一个运行队列，效率会变高，锁变得更精细化了。这提升了系统的可拓展性。（可拓展性意味着当加入更多处理器、内存时，系统仍然运行的很好）</p>
<p>提高可拓展性是件好事，这让Linux在更大型的、处理能力更强的系统上的性能，但这会导致Linux在小型SMP和UP机器上的性能降低。（因为他们用不到这么精细化的锁）（比如说一开始，一个链表是共享资源，那么给链表加一个锁就行了，但是随着处理器数目增加，如果多个处理器都要访问这个链表，那么效率很低，所以就只给每一个节点加锁，这样加锁粒度变细。但如果多个处理器同时访问某个节点，还是会发生争用。还有没有必要在更细的粒度上加锁呢，比如每个元素，没有必要，过细的粒度会导致系统在低数量处理器上的表现太差，加大系统开销）。</p>
<p>初期加锁应该尽量简单，加锁不要太粗和太细。</p>
<h3 id="内核同步方法（这些操作一般用于内核，可能没法在用户空间使用）"><a href="#内核同步方法（这些操作一般用于内核，可能没法在用户空间使用）" class="headerlink" title="内核同步方法（这些操作一般用于内核，可能没法在用户空间使用）"></a>内核同步方法（这些操作一般用于内核，可能没法在用户空间使用）</h3><p>Linux提供了一组同步方法，来使内核开发者们编写高效而自由竞争的代码。</p>
<h4 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h4><p>内核提供了两组原子操作接口。</p>
<h5 id="原子整数操作"><a href="#原子整数操作" class="headerlink" title="原子整数操作"></a>原子整数操作</h5><p>针对整数的原子操作只能对atomic_t类型的数据进行操作。</p>
<blockquote>
<p><strong>原子性和顺序性</strong>：</p>
<p>原子性：指令不可拆分，要么执行完，要么没有执行完，比如：<code>atomic_t i = ATOMOC_INIT(0)</code>, 然后两个线程执行<code>i++</code>,，那么被<code>atomic_inc(&amp;i)</code>执行后，i的结果只能是2， 而如果被普通的i++指令执行后，结果也可能为1，它不具有原子性。</p>
<p>顺序性：我们的代码通常有比原子性更高的要求，比如要求读在特定的写前执行。顺序性需要通过<strong>屏障指令</strong>来实施。</p>
</blockquote>
<p>原子操作与复杂的同步方法相比，开销非常小。</p>
<h5 id="原子位操作"><a href="#原子位操作" class="headerlink" title="原子位操作"></a>原子位操作</h5><p>原子位操作是用来对普通的内存地址进行操作的。</p>
<p>常见的参数是给定一个变量地址，然后给定一个位号，然后就对这个位号进行读写。</p>
<blockquote>
<p>原子操作保证该函数内部指令一一执行，如果要连续执行多个原子操作，很可能出现问题，即原子操作没法保证外部的顺序</p>
<p><strong>现代处理器通常通过硬件指令（如 x86 的 <code>LOCK</code> 前缀或 <code>compare-and-swap</code> 指令）实现原子性。这些指令在执行时会锁定必要的内存地址或总线，防止其他处理器对该内存区域进行并发访问。</strong>比如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdatomic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">atomic_int</span> counter = <span class="number">0</span>;</span><br><span class="line">    atomic_fetch_add(&amp;counter, <span class="number">1</span>);  <span class="comment">// 原子递增</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Final counter value: %d\n&quot;</span>, counter);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译后反汇编</span></span><br><span class="line">    <span class="number">1184</span>:       c7 <span class="number">45</span> f0 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    movl   $<span class="number">0x0</span>,<span class="number">-0x10</span>(%rbp)</span><br><span class="line">    <span class="number">118b</span>:       f0 <span class="number">83</span> <span class="number">45</span> f0 <span class="number">01</span>          lock addl $<span class="number">0x1</span>,<span class="number">-0x10</span>(%rbp) <span class="comment">//可以发现，使用了lock前缀防止并发</span></span><br></pre></td></tr></table></figure>


</blockquote>
<h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>原子操作没办法处理一些复杂操作：比如从一个数据结构读取数据，处理后添加到另一个数据结构上，这需要更复杂的同步方法——<strong>锁</strong>。</p>
<p>Linux最常见的锁是自旋锁。</p>
<p>如果要申请的锁已经被其他线程持有，那么当前线程会一直忙等待（不会阻塞，其实中断也可以用自旋锁，但是不符合中断快进快出的特点）。</p>
<ul>
<li>自旋锁，等待是忙等待，会浪费处理器的等待时间</li>
<li>信号量，等待是让线程睡眠，会浪费两次上下文切换的时间</li>
</ul>
<p>所以要让<strong>持有自旋锁的时间尽可能短</strong>，短于上下文切换的时间。</p>
<h5 id="自旋锁方法"><a href="#自旋锁方法" class="headerlink" title="自旋锁方法"></a>自旋锁方法</h5><p><strong>自旋锁不能递归。一个线程不能连续加两次锁。</strong></p>
<blockquote>
<p>在中断中可以使用自旋锁，那么在申请一个自旋锁时就需要注意了，为了防止申请一个自旋锁之后突然被一个中断打断，进而出现再次申请锁的情况，需要<strong>先禁（当前处理器的）中断，然后申请锁。</strong>只用禁当前处理器的中断就行了，因为即使中断处理在一个锁上自旋，也不妨碍其他处理器释放锁。</p>
</blockquote>
<p><code>spin_lock_irqsave(&amp;mr_lock, flags)</code>, 会保存本地中断的状态，并禁止中断，然后获取锁。</p>
<p><code>spin_unlock_irqrestore(&amp;mr_lock, flags)</code></p>
<blockquote>
<p>锁什么，<strong>锁的是数据而非代码</strong>，所以每个锁是跟数据关联起来的，比如数据loo，可以用loo_lock加锁。</p>
</blockquote>
<h5 id="自旋锁与下半部"><a href="#自旋锁与下半部" class="headerlink" title="自旋锁与下半部"></a>自旋锁与下半部</h5><h4 id="读写自旋锁"><a href="#读写自旋锁" class="headerlink" title="读写自旋锁"></a>读写自旋锁</h4><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>计数信号量和二值信号量（又名互斥信号量）</p>
<p>更多的看看操作系统那篇吧。</p>
<h4 id="读写信号量"><a href="#读写信号量" class="headerlink" title="读写信号量"></a>读写信号量</h4><p>读者无限，写者唯一。</p>
<h4 id="互斥体"><a href="#互斥体" class="headerlink" title="互斥体"></a>互斥体</h4><ul>
<li>mutex的使用计数永远是1</li>
<li>mutex不能在中断或者下半部使用</li>
<li>mutex可以通过特殊的调试模式，通过内核来检查一些错误行为。内核配置有CONFIG_DEBUG_MUTEXES。</li>
</ul>
<img src="/.github.io/2024/10/22/linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20241116164035714.png" class title="image-20241116164035714">

<h4 id="禁止抢占"><a href="#禁止抢占" class="headerlink" title="禁止抢占"></a>禁止抢占</h4><p>现在Linux内核是运行内核抢占的，但是如果某一段区域，线程持有了自旋锁，那么内核在该段区域是不能被抢占的，</p>
<h4 id="顺序与屏障"><a href="#顺序与屏障" class="headerlink" title="顺序与屏障"></a>顺序与屏障</h4><p>rmb()提供读屏障，wmb()提供写屏障。</p>
<p>又白看了</p>
<img src="/.github.io/2024/10/22/linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20241116165448218.png" class title="image-20241116165448218">

<img src="/.github.io/2024/10/22/linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20241116165545781.png" class title="image-20241116165545781">

<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><h4 id="页"><a href="#页" class="headerlink" title="页"></a>页</h4><p>内核用struct page来表示每个<strong>物理页</strong>，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct page&#123;</span><br><span class="line">	unsigned long flags;</span><br><span class="line">	atomic_t _count;</span><br><span class="line">	atomic_t _mapcount;</span><br><span class="line">	unsigned long private;</span><br><span class="line">	struct address_space *mapping;</span><br><span class="line">	pgoff_t index;</span><br><span class="line">	struct list_head lru;</span><br><span class="line">	void *virtual;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>flag的每一位表示一种状态，比如该页是不是脏的，是不是锁定在内存中</li>
<li>_count存放该页的引用计数，如果值为-1说明没有进程需要该物理页</li>
<li>virtual代表该页的虚拟地址，</li>
</ul>
<p>这个page结构只与物理结构相关，所以该结构对页的描述是短暂的，当物理页需要加载新的程序时，该结构的值就会随之改变。</p>
<h4 id="区"><a href="#区" class="headerlink" title="区"></a>区</h4><p>对于不同的物理内存，不能一视同仁：</p>
<ul>
<li>一些硬件只能用特定的内存地址进行DMA</li>
<li>一些体系的物理地址比虚拟地址大</li>
</ul>
<p>为此，Linux使用了如下的几种区：</p>
<ul>
<li><p>ZONE_DMA, 该区只能执行DMA操作</p>
</li>
<li><p>ZONE_DMA32</p>
</li>
<li><p>ZONE_NORMAL，该区可以正常映射</p>
</li>
<li><p>ZONE_HIGHEM，这个区包含高端内存，其中的页不能永久的映射到地址空间 </p>
<img src="/.github.io/2024/10/22/linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/75fb5e32d9913a1b1ff649511bf7095c.jpeg" class title="75fb5e32d9913a1b1ff649511bf7095c">

<img src="/.github.io/2024/10/22/linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/2012082909265791.jpg" class width="2012082909265791">

<blockquote>
<p>from:<a target="_blank" rel="noopener" href="https://armsword.com/2013/08/25/linux-memory-and-manage/">linux内存空间分配和内存管理</a></p>
<p>在kernel image下面有16M的内核空间用于DMA操作。位于内核空间高端的128M地址主要由3部分组成，分别为vmalloc area，persistent kernel mapping(持久化内核映射区)，tempoary kernel mapping(临时内核映射区)。</p>
<p>由于ZONE_NORMAL和内核线性空间存在直接映射关系，所以内核会将频繁使用的数据如kernel代码、GDT、IDT、PGD、mem_map数组等放在ZONE_NORMAL里。而将用户数据、页表(PT)等不常用数据放在ZONE_ HIGHMEM里，只在要访问这些数据时才建立映射关系(kmap())。比如，当内核要访问I&#x2F;O设备存储空间时，就使用ioremap()将位于物理地址高端的mmio区内存映射到内核空间的vmalloc area中，在使用完之后便断开映射关系。</p>
<p>由于开启了分页机制，内核想要访问物理地址空间的话，必须先建立映射关系，然后通过虚拟地址来访问。为了能够访问所有的物理地址空间，就要将全部物理地址空间映射到1G的内核线性空间中，这显然不可能。于是，内核将0~896M的物理地址空间一对一映射到自己的线性地址空间中，这样它便可以随时访问ZONE_DMA和ZONE_NORMAL里的物理页面；此时内核剩下的128M线性地址空间不足以完全映射所有的ZONE_HIGHMEM，Linux采取了动态映射的方法，即按需的将ZONE_HIGHMEM里的物理页面映射到kernel space的最后128M线性地址空间里，使用完之后释放映射关系，以供其它物理页面映射。虽然这样存在效率的问题，但是内核毕竟可以正常的访问所有的物理地址空间了。</p>
</blockquote>
</li>
</ul>
<img src="/.github.io/2024/10/22/linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20241116204250238.png" class title="image-20241116204250238">

<blockquote>
<p>x86_64系统中，虚拟地址空间可以映射所有的64位的地址，所以没有ZONE_HIGHMEM区。</p>
</blockquote>
<h5 id="获得页（这些操作都是提供给内核开发者的，普通的用户程序不应该使用这些函数）"><a href="#获得页（这些操作都是提供给内核开发者的，普通的用户程序不应该使用这些函数）" class="headerlink" title="获得页（这些操作都是提供给内核开发者的，普通的用户程序不应该使用这些函数）"></a>获得页（这些操作都是提供给内核开发者的，普通的用户程序不应该使用这些函数）</h5><p><code>struct page * alloc_pages(gfp_t gfp_mask, unsigned int order)</code>，</p>
<p>如果只是要分配若干字节，可以使用kmalloc</p>
<h4 id="kmalloc"><a href="#kmalloc" class="headerlink" title="kmalloc"></a>kmalloc</h4><img src="/.github.io/2024/10/22/linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20241116210009837.png" class title="image-20241116210009837">

<h4 id="slab层"><a href="#slab层" class="headerlink" title="slab层"></a>slab层</h4><p>很多操作都需要分配和释放数据结构，为了避免频繁的申请和释放，会利用到空闲链表。当代码需要一个数据结构实例时，就从空闲链表中拿一个，不需要时，就将它放回空闲链表而不是释放它。（空闲链表就相当于对象高速缓存，感觉和线程池也很类似的）</p>
<p>空闲链表有个缺点，内核内存紧张时，没办法通知空闲链表，让他释放一点内存。为了弥补这一缺陷，Linux提供了slab层。</p>
<h5 id="slab层的设计"><a href="#slab层的设计" class="headerlink" title="slab层的设计"></a>slab层的设计</h5><p>slab层把不同的对象分为高速缓存组。<strong>每个高速缓存组存放不同的对象</strong>。比如，一个高速缓存存放进程标识符task_struct, 一个高速缓存存放索引节点对象inode。kmalloc接口也建立在slab层之上。</p>
<p>每个高速缓存又被划分为slab。slab由一个或多个页组成。程序申请一个数据结构时，</p>
<ul>
<li>先从部分满的slab分配资源，</li>
<li>没有部分 满的slab时，从空slab分配资源</li>
<li>没有空slab时，新建slab</li>
</ul>
<p>这可以减少内存碎片。</p>
<img src="/.github.io/2024/10/22/linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20241116212505828.png" class title="image-20241116212505828">

<p>举个例子，inode结构，它是由inode_cachep高速缓存来分配的。</p>
<h4 id="在栈上的静态分配"><a href="#在栈上的静态分配" class="headerlink" title="在栈上的静态分配"></a>在栈上的静态分配</h4><p>内核栈需要存储的是内核模式下的上下文信息，这包括CPU寄存器状态、内核函数调用的参数和返回地址等。这是为了与用户空间隔离，才建立的内核栈。</p>
<p>进程在内核有一个内核栈，中断程序也可以获得一个栈。</p>
<h5 id="在栈上工作"><a href="#在栈上工作" class="headerlink" title="在栈上工作"></a>在栈上工作</h5><p>一旦栈溢出了，就会覆盖掉临近栈末端的数据。进行动态分配是一种明智的选择。</p>
<h4 id="高端内存的映射"><a href="#高端内存的映射" class="headerlink" title="高端内存的映射"></a>高端内存的映射</h4><p>将高端物理地址内存映射到内核空间上。</p>
<h3 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h3><p>VFS虚拟系统，是一个抽象层。<strong>既然是一层</strong>，<strong>就必然会使用相关信息，给上层提供一个接口</strong>。他的接口主要是位于VFS对象的结构体中，之后要讲。</p>
<h4 id="文件系统抽象层"><a href="#文件系统抽象层" class="headerlink" title="文件系统抽象层"></a>文件系统抽象层</h4><p>内核底层提供了抽象层，使得Linux支持各种文件系统。（如果是FAT或NFTS等非Unix风格的文件系统，也必须在内存提供索引节点结构体，这会带来很大的开销）</p>
<img src="/.github.io/2024/10/22/linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20241120143725632.png" class title="image-20241120143725632">

<blockquote>
<p><strong>每一层都需要提供一个接口，供上层使用。</strong></p>
<p>上图中文件系统部分，它可以是ext4、NFTS、FAT等文件格式，每种文件格式都提供了向物理磁盘读写数据的接口。这些接口会供上层使用。</p>
<p>操作系统提供给用户的是write系统调用。</p>
</blockquote>
<h4 id="Unix文件系统"><a href="#Unix文件系统" class="headerlink" title="Unix文件系统"></a>Unix文件系统</h4><p>四种抽象概念：</p>
<ul>
<li>文件，</li>
<li>目录项，目录的名字。目录也是普通文件，他的文件内容包含该目录的所有文件，VFS把目录当作文件对待，可以对目录执行与文件相同的操作。</li>
<li>索引节点，inode。索引节点是一个独立于文件本身的数据结构，它存储文件的相关信息，如权限，大小（文件的元数据）。</li>
<li>安装点</li>
</ul>
<p>文件系统的控制信息是存储在超级块中。</p>
<h4 id="VFS对象及其数据结构"><a href="#VFS对象及其数据结构" class="headerlink" title="VFS对象及其数据结构"></a>VFS对象及其数据结构</h4><ul>
<li>超级块对象，代表一个具体的已安装文件系统</li>
<li>索引节点对象，代表一个具体文件</li>
<li>目标项对象，代表一个目录项，是路径的一个组成部分（不是目录对象，目录项对象是文件系统中的一个文件或目录的名称）</li>
<li>文件对象，代表由进程打开的文件</li>
</ul>
<p>每个主要对象结构体（比如上面的四个对象）都包含了一个操作对象结构体，这些操作对象结构体包含了一些函数指针，描述了针对该对象可以使用的方法。对于很多方法来说，可以直接使用VFS提供的通用函数，也可以替换为实际文件系统对应的独有方法。</p>
<img src="/.github.io/2024/10/22/linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20241120150545290.png" class title="image-20241120150545290">





<h4 id="超级块对象"><a href="#超级块对象" class="headerlink" title="超级块对象"></a>超级块对象</h4><p>该对象由<code>super_block</code>结构体表示，在安装操作系统时，会从磁盘读取文件系统超级块，并把其信息填充到内存中的超级块对象中。</p>
<h4 id="超级块操作"><a href="#超级块操作" class="headerlink" title="超级块操作"></a>超级块操作</h4><p>上面的超级块对象中包含一个成员<code>s_op</code>，它是之前讲过的包含了函数指针的结构体。这个结构体的每一项都是指向<strong>超级块操作函数</strong>的指针，这个超级块操作函数执行文件系统和索引节点的低级操作。</p>
<img src="/.github.io/2024/10/22/linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20241120151737705.png" class title="image-20241120151737705">

<p>常见的几种操作：</p>
<img src="/.github.io/2024/10/22/linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20241120152648112.png" class title="image-20241120152648112">

<h4 id="索引节点对象"><a href="#索引节点对象" class="headerlink" title="索引节点对象"></a>索引节点对象</h4><p>索引节点对象包含了内核在操作<strong>文件或目录</strong>需要的全部信息。</p>
<p>索引节点需要从磁盘读入内存。分为两种情况</p>
<ul>
<li>是Unix风格的文件系统，那么索引节点直接从磁盘索引节点读入</li>
<li>不是Unix风格的文件系统，那么物理文件系统没有索引节点，所以会将文件的相关信息和文件的内容都作为文件的一部分来存放。这会导致没有将控制信息和数据分开。</li>
</ul>
<p>不管哪种方式，索引节点对象都需要在内存中创建。</p>
<p>索引节点对象由inode结构体表示。一个索引节点（当要访问某个文件时，才在内存中创建）代表文件系统中的一个文件。这个文件也可以是设备或管道这样的特殊文件。在结构体中会有一些和特殊文件相关的项，比如i_pipe、i_bdev。</p>
<img src="/.github.io/2024/10/22/linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20241120155029854.png" class title="image-20241120155029854">

<h4 id="索引节点操作"><a href="#索引节点操作" class="headerlink" title="索引节点操作"></a>索引节点操作</h4><p><code>inode</code>结构体也包含了一个<code>inode_operations</code>项，它描述了VFS用来操作该索引节点的所有方法。</p>
<blockquote>
<p><code>dentry</code> 结构代表了目录项，即文件系统中的一个文件或目录的名称。下面是一些结构体中包含的函数指针。</p>
</blockquote>
<img src="/.github.io/2024/10/22/linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20241120165534954.png" class title="image-20241120165534954">

<img src="/.github.io/2024/10/22/linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20241120165545267.png" class title="image-20241120165545267">

<h4 id="目录项对象"><a href="#目录项对象" class="headerlink" title="目录项对象"></a>目录项对象</h4><p>VFS把目录和文件都看成是相同的。路径的每个组成部分都由一个索引节点表示，比如inode可以表示一个文件，也可以表示一个目录。</p>
<p>VFS需要执行目录相关的操作，<strong>为了方便查找，引入了目录项的概念</strong>。路径的每个部分都是一个目录项对象，比如<code>/bin/vi</code>, <code>/、bin、vi</code>都是目录项对象。</p>
<p><strong>目录项对象没有对应的磁盘数据结构，VFS会根据字符形式的路径名现场创建它。</strong></p>
<h5 id="目录项状态"><a href="#目录项状态" class="headerlink" title="目录项状态"></a>目录项状态</h5><p>三种有效状态：</p>
<ul>
<li>被使用，一个被使用的目录项对应一个有效的索引节点，并且该对象有一个或多个使用者(即d_count为正值), 这意味着它正被VFS使用，因此不能被丢弃</li>
<li>未被使用，一个被使用的目录项对应一个有效的索引节点，并且该对象没有被VFS使用。该目录项对象仍然指向一个有效对象，而且被保留在缓存中，之后需要时可以迅速的使用。</li>
<li>负状态，没有对应的索引节点，因为索引节点已经被删除了。</li>
</ul>
<h5 id="目录项缓存"><a href="#目录项缓存" class="headerlink" title="目录项缓存"></a>目录项缓存</h5><p>如果VFS按层解析路径名中所有的元素，这非常费时间，所以内核会把目录项对象缓存在<strong>目录项缓存（dcache）</strong>中。</p>
<p>目录项缓存包括三个部分：</p>
<ul>
<li>“被使用的”目录项链表，</li>
<li>“最近被使用的”双向链表，未被使用的和负状态的链表都在该链表中</li>
<li>散列表和散列函数用来快速的将<strong>路径</strong>解析为相关的<strong>目录项对象</strong>。</li>
</ul>
<img src="/.github.io/2024/10/22/linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20241121165125202.png" class title="image-20241121165125202">



<h4 id="文件对象"><a href="#文件对象" class="headerlink" title="文件对象"></a>文件对象</h4><p>文件对象是已打开的文件<strong>在内存中的表示</strong>，文件对象只在进程观点上代表已打开文件，（文件对象指向目录项，目录项指向索引节点，索引节点指向每一个文件的实际位置）</p>
<h4 id="和进程有关的数据结构"><a href="#和进程有关的数据结构" class="headerlink" title="和进程有关的数据结构"></a>和进程有关的数据结构</h4><p>每个进程都有一组打开的文件，如根文件系统、<strong>当前工作目录</strong>、安装点等。</p>
<p>有三个数据结构将VFS层与系统的进程联系在一起。</p>
<ul>
<li>files_struct, 进程task_struct中的files目录项指向这个结构体。file_struct中的fd_array数组包含了指向文件对象的指针。</li>
<li>fs_stuct，进程task_struct中的fs项指向这个结构体。它包含文件系统和进程相关的信息。其中会包含root路径和当前工作目录路径。</li>
<li>namespace结构体</li>
</ul>
<img src="/.github.io/2024/10/22/linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/20210119180835191.png" class title="进程与超级块、文件、索引结点、目录项的关系">

<h3 id="进程地址空间"><a href="#进程地址空间" class="headerlink" title="进程地址空间"></a>进程地址空间</h3><h4 id="内存描述符"><a href="#内存描述符" class="headerlink" title="内存描述符"></a>内存描述符</h4><p>内核使用内存描述符结构体来标识进程的地址空间，用<code>mm_struct</code>表示，它有两个成员，<code>mmap</code>与<code>mm_rb</code>都描述该地址空间的全部内存区域，前者以链表存放，后者以二叉树存放。</p>
<h5 id="分配内存描述符"><a href="#分配内存描述符" class="headerlink" title="分配内存描述符"></a>分配内存描述符</h5><p>进程描述符中的mm域指向了该进程使用的内存描述符。</p>
<p>进程可以通过allocate_mm从slab缓存中得到mm_struct结构体。</p>
<p>也可以将mm域指向父进程的内存描述符，这样该进程就是线程了。</p>
<h5 id="mm-struct与内核线程"><a href="#mm-struct与内核线程" class="headerlink" title="mm_struct与内核线程"></a>mm_struct与内核线程</h5><p>内核线程没有进程地址空间，没有内存描述符，mm域为空——他们没有用户上下文。</p>
<p>但是内核线程还是需要访问内核内存，为了避免向内核线程分配内存描述符，内核线程会直接使用前一个进程的内存描述符，但仅仅使用与内核内存相关的内存。</p>
<h4 id="虚拟内存区域"><a href="#虚拟内存区域" class="headerlink" title="虚拟内存区域"></a>虚拟内存区域</h4><p>内存区域用vm_area_struct结构体表示。内存区域描述了指定地址空间内<strong>连续区域上</strong>的一个独立内存范围。每个内存区域都有一致的属性，比如访问权限等。</p>
<h5 id="实际的内存区域"><a href="#实际的内存区域" class="headerlink" title="实际的内存区域"></a>实际的内存区域</h5><p>如果一段区域是不可写的或共享的，那么内核只需要在内存为文件保留一份映射。</p>
<h4 id="mmap和do-mmap：创建内存区域"><a href="#mmap和do-mmap：创建内存区域" class="headerlink" title="mmap和do_mmap：创建内存区域"></a>mmap和do_mmap：创建内存区域</h4></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://tjzhang-src.github.io/.github.io">John Doe</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://tjzhang-src.github.io/.github.io/2024/10/22/linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/">https://tjzhang-src.github.io/.github.io/2024/10/22/linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://tjzhang-src.github.io/.github.io" target="_blank">Welcome</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/.github.io/tags/linux/">linux</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/.github.io/2024/11/11/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/" title="虚拟内存"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">虚拟内存</div></div></a></div><div class="next-post pull-right"><a href="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/" title="操作系统-精髓与设计原理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">操作系统-精髓与设计原理</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/.github.io/2023/03/29/imx6ull%E4%BD%BF%E7%94%A8/" title="imx6ull使用"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">imx6ull使用</div></div></a></div><div><a href="/.github.io/2023/03/10/linux%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/" title="linux小知识点"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-10</div><div class="title">linux小知识点</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Waline</span><span class="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/.github.io/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">John Doe</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/.github.io/archives/"><div class="headline">文章</div><div class="length-num">42</div></a><a href="/.github.io/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/.github.io/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/tjzhang-src"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">内核简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E5%86%85%E6%A0%B8-amp-%E5%BE%AE%E5%86%85%E6%A0%B8"><span class="toc-number">1.1.</span> <span class="toc-text">单内核&amp;微内核</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Linux%E5%86%85%E6%A0%B8%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.2.</span> <span class="toc-text">Linux内核的特点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">进程管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E4%BB%BB%E5%8A%A1%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.</span> <span class="toc-text">进程描述符与任务结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">2.1.1.</span> <span class="toc-text">分配进程描述符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%9A%84%E5%AD%98%E6%94%BE"><span class="toc-number">2.1.2.</span> <span class="toc-text">进程描述符的存放</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%BD%93%E5%89%8D%E7%9A%84%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-number">2.1.3.</span> <span class="toc-text">设置当前的进程状态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">2.1.4.</span> <span class="toc-text">进程上下文</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%AE%B6%E6%97%8F%E6%A0%91"><span class="toc-number">2.1.5.</span> <span class="toc-text">进程家族树</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="toc-number">2.2.</span> <span class="toc-text">进程创建</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%99%E6%97%B6%E6%8B%B7%E8%B4%9D"><span class="toc-number">2.2.1.</span> <span class="toc-text">写时拷贝</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#fork"><span class="toc-number">2.2.2.</span> <span class="toc-text">fork</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.3.</span> <span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.3.1.</span> <span class="toc-text">创建线程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.3.2.</span> <span class="toc-text">内核线程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%88%E7%BB%93"><span class="toc-number">2.4.</span> <span class="toc-text">进程终结</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">2.4.1.</span> <span class="toc-text">删除进程描述符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.4.2.</span> <span class="toc-text">孤儿进程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-number">3.</span> <span class="toc-text">进程调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E4%BB%BB%E5%8A%A1"><span class="toc-number">3.1.</span> <span class="toc-text">多任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LInux%E7%9A%84%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-number">3.2.</span> <span class="toc-text">LInux的进程调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%96%E7%95%A5"><span class="toc-number">3.3.</span> <span class="toc-text">策略</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#IO%E6%B6%88%E8%80%97%E5%9E%8B%E5%92%8C%E5%A4%84%E7%90%86%E5%99%A8%E6%B6%88%E8%80%97%E5%9E%8B%E8%BF%9B%E7%A8%8B"><span class="toc-number">3.3.1.</span> <span class="toc-text">IO消耗型和处理器消耗型进程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">3.3.2.</span> <span class="toc-text">进程优先级</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E7%89%87"><span class="toc-number">3.3.3.</span> <span class="toc-text">时间片</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5%E7%9A%84%E6%B4%BB%E5%8A%A8"><span class="toc-number">3.3.4.</span> <span class="toc-text">调度策略的活动</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Linux%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">3.4.</span> <span class="toc-text">Linux调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E5%99%A8%E7%B1%BB"><span class="toc-number">3.4.1.</span> <span class="toc-text">调度器类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Unix%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-number">3.4.2.</span> <span class="toc-text">Unix中的进程调度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E8%B0%83%E5%BA%A6"><span class="toc-number">3.4.3.</span> <span class="toc-text">公平调度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Linux%E8%B0%83%E5%BA%A6%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.5.</span> <span class="toc-text">Linux调度的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E8%AE%B0%E8%B4%A6"><span class="toc-number">3.5.1.</span> <span class="toc-text">时间记账</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%89%E6%8B%A9"><span class="toc-number">3.5.2.</span> <span class="toc-text">进程选择</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E5%99%A8%E5%85%A5%E5%8F%A3"><span class="toc-number">3.5.3.</span> <span class="toc-text">调度器入口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%91%E7%9C%A0%E4%B8%8E%E5%94%A4%E9%86%92"><span class="toc-number">3.5.4.</span> <span class="toc-text">休眠与唤醒</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%A2%E5%8D%A0%E4%B8%8E%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">3.6.</span> <span class="toc-text">抢占与上下文</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%8A%A2%E5%8D%A0"><span class="toc-number">3.6.1.</span> <span class="toc-text">用户抢占</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E6%8A%A2%E5%8D%A0"><span class="toc-number">3.6.2.</span> <span class="toc-text">内核抢占</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5"><span class="toc-number">3.7.</span> <span class="toc-text">实时调度策略</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">4.</span> <span class="toc-text">系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8E%E5%86%85%E6%A0%B8%E9%80%9A%E4%BF%A1"><span class="toc-number">4.1.</span> <span class="toc-text">与内核通信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#API%E3%80%81POSIX%E5%92%8CC%E5%BA%93"><span class="toc-number">4.2.</span> <span class="toc-text">API、POSIX和C库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-1"><span class="toc-number">4.3.</span> <span class="toc-text">系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8F%B7"><span class="toc-number">4.3.1.</span> <span class="toc-text">系统调用号</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="toc-number">4.4.</span> <span class="toc-text">系统调用处理程序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E6%81%B0%E5%BD%93%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">4.4.1.</span> <span class="toc-text">指定恰当的系统调用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-number">4.4.2.</span> <span class="toc-text">参数传递</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.5.</span> <span class="toc-text">系统调用的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E9%AA%8C%E8%AF%81"><span class="toc-number">4.5.1.</span> <span class="toc-text">参数验证</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">4.6.</span> <span class="toc-text">系统调用上下文</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%91%E5%AE%9A%E4%B8%80%E4%B8%AA%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E6%9C%80%E5%90%8E%E6%AD%A5%E9%AA%A4"><span class="toc-number">4.6.1.</span> <span class="toc-text">绑定一个系统调用的最后步骤</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8E%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E8%AE%BF%E9%97%AE%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">4.6.2.</span> <span class="toc-text">从用户空间访问系统调用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%92%8C%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86"><span class="toc-number">5.</span> <span class="toc-text">中断和中断处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD"><span class="toc-number">5.1.</span> <span class="toc-text">中断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E4%B8%AD%E6%96%AD"><span class="toc-number">5.2.</span> <span class="toc-text">注册中断</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E6%A0%87%E5%BF%97"><span class="toc-number">5.2.1.</span> <span class="toc-text">中断处理程序标志</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">5.3.</span> <span class="toc-text">中断上下文</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6"><span class="toc-number">5.4.</span> <span class="toc-text">中断控制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A6%81%E6%AD%A2%E5%92%8C%E6%BF%80%E6%B4%BB%E4%B8%AD%E6%96%AD"><span class="toc-number">5.4.1.</span> <span class="toc-text">禁止和激活中断</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A6%81%E6%AD%A2%E4%B8%AD%E6%96%AD%E7%BA%BF"><span class="toc-number">5.4.2.</span> <span class="toc-text">禁止中断线</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8"><span class="toc-number">6.</span> <span class="toc-text">中断下半部</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8B%E5%8D%8A%E9%83%A8"><span class="toc-number">6.1.</span> <span class="toc-text">下半部</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8B%E5%8D%8A%E9%83%A8%E7%9A%84%E7%8E%AF%E5%A2%83"><span class="toc-number">6.1.1.</span> <span class="toc-text">下半部的环境</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%B8%AD%E6%96%AD"><span class="toc-number">6.2.</span> <span class="toc-text">软中断</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">6.2.1.</span> <span class="toc-text">使用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tasklet"><span class="toc-number">6.3.</span> <span class="toc-text">tasklet</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.3.1.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-1"><span class="toc-number">6.3.2.</span> <span class="toc-text">使用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97"><span class="toc-number">6.4.</span> <span class="toc-text">工作队列</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.4.1.</span> <span class="toc-text">工作队列的实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81"><span class="toc-number">6.5.</span> <span class="toc-text">锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5"><span class="toc-number">7.</span> <span class="toc-text">内核同步</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B4%E7%95%8C%E5%8C%BA%E5%92%8C%E7%AB%9E%E4%BA%89%E6%9D%A1%E4%BB%B6"><span class="toc-number">7.1.</span> <span class="toc-text">临界区和竞争条件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BF%9D%E6%8A%A4"><span class="toc-number">7.1.1.</span> <span class="toc-text">为什么要保护</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E4%B8%AA%E5%8F%98%E9%87%8F"><span class="toc-number">7.1.2.</span> <span class="toc-text">单个变量</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E9%94%81"><span class="toc-number">7.2.</span> <span class="toc-text">加锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%A0%E6%88%90%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">7.2.1.</span> <span class="toc-text">造成并发执行的原因</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A6%81%E4%BF%9D%E6%8A%A4%E4%BB%80%E4%B9%88"><span class="toc-number">7.2.2.</span> <span class="toc-text">要保护什么</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">7.3.</span> <span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%89%E7%94%A8%E5%92%8C%E6%8B%93%E5%B1%95%E6%80%A7"><span class="toc-number">7.4.</span> <span class="toc-text">争用和拓展性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%EF%BC%88%E8%BF%99%E4%BA%9B%E6%93%8D%E4%BD%9C%E4%B8%80%E8%88%AC%E7%94%A8%E4%BA%8E%E5%86%85%E6%A0%B8%EF%BC%8C%E5%8F%AF%E8%83%BD%E6%B2%A1%E6%B3%95%E5%9C%A8%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E4%BD%BF%E7%94%A8%EF%BC%89"><span class="toc-number">8.</span> <span class="toc-text">内核同步方法（这些操作一般用于内核，可能没法在用户空间使用）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="toc-number">8.1.</span> <span class="toc-text">原子操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%95%B4%E6%95%B0%E6%93%8D%E4%BD%9C"><span class="toc-number">8.1.1.</span> <span class="toc-text">原子整数操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E4%BD%8D%E6%93%8D%E4%BD%9C"><span class="toc-number">8.1.2.</span> <span class="toc-text">原子位操作</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-number">8.2.</span> <span class="toc-text">自旋锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81%E6%96%B9%E6%B3%95"><span class="toc-number">8.2.1.</span> <span class="toc-text">自旋锁方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81%E4%B8%8E%E4%B8%8B%E5%8D%8A%E9%83%A8"><span class="toc-number">8.2.2.</span> <span class="toc-text">自旋锁与下半部</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-number">8.3.</span> <span class="toc-text">读写自旋锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">8.4.</span> <span class="toc-text">信号量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">8.5.</span> <span class="toc-text">读写信号量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E4%BD%93"><span class="toc-number">8.6.</span> <span class="toc-text">互斥体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A6%81%E6%AD%A2%E6%8A%A2%E5%8D%A0"><span class="toc-number">8.7.</span> <span class="toc-text">禁止抢占</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E4%B8%8E%E5%B1%8F%E9%9A%9C"><span class="toc-number">8.8.</span> <span class="toc-text">顺序与屏障</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">9.</span> <span class="toc-text">内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5"><span class="toc-number">9.1.</span> <span class="toc-text">页</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA"><span class="toc-number">9.2.</span> <span class="toc-text">区</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8E%B7%E5%BE%97%E9%A1%B5%EF%BC%88%E8%BF%99%E4%BA%9B%E6%93%8D%E4%BD%9C%E9%83%BD%E6%98%AF%E6%8F%90%E4%BE%9B%E7%BB%99%E5%86%85%E6%A0%B8%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84%EF%BC%8C%E6%99%AE%E9%80%9A%E7%9A%84%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E4%B8%8D%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8%E8%BF%99%E4%BA%9B%E5%87%BD%E6%95%B0%EF%BC%89"><span class="toc-number">9.2.1.</span> <span class="toc-text">获得页（这些操作都是提供给内核开发者的，普通的用户程序不应该使用这些函数）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#kmalloc"><span class="toc-number">9.3.</span> <span class="toc-text">kmalloc</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#slab%E5%B1%82"><span class="toc-number">9.4.</span> <span class="toc-text">slab层</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#slab%E5%B1%82%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">9.4.1.</span> <span class="toc-text">slab层的设计</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E6%A0%88%E4%B8%8A%E7%9A%84%E9%9D%99%E6%80%81%E5%88%86%E9%85%8D"><span class="toc-number">9.5.</span> <span class="toc-text">在栈上的静态分配</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%A8%E6%A0%88%E4%B8%8A%E5%B7%A5%E4%BD%9C"><span class="toc-number">9.5.1.</span> <span class="toc-text">在栈上工作</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E7%AB%AF%E5%86%85%E5%AD%98%E7%9A%84%E6%98%A0%E5%B0%84"><span class="toc-number">9.6.</span> <span class="toc-text">高端内存的映射</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">10.</span> <span class="toc-text">虚拟文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8A%BD%E8%B1%A1%E5%B1%82"><span class="toc-number">10.1.</span> <span class="toc-text">文件系统抽象层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Unix%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">10.2.</span> <span class="toc-text">Unix文件系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#VFS%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">10.3.</span> <span class="toc-text">VFS对象及其数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B6%85%E7%BA%A7%E5%9D%97%E5%AF%B9%E8%B1%A1"><span class="toc-number">10.4.</span> <span class="toc-text">超级块对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B6%85%E7%BA%A7%E5%9D%97%E6%93%8D%E4%BD%9C"><span class="toc-number">10.5.</span> <span class="toc-text">超级块操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9%E5%AF%B9%E8%B1%A1"><span class="toc-number">10.6.</span> <span class="toc-text">索引节点对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C"><span class="toc-number">10.7.</span> <span class="toc-text">索引节点操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E9%A1%B9%E5%AF%B9%E8%B1%A1"><span class="toc-number">10.8.</span> <span class="toc-text">目录项对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E9%A1%B9%E7%8A%B6%E6%80%81"><span class="toc-number">10.8.1.</span> <span class="toc-text">目录项状态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E9%A1%B9%E7%BC%93%E5%AD%98"><span class="toc-number">10.8.2.</span> <span class="toc-text">目录项缓存</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%AF%B9%E8%B1%A1"><span class="toc-number">10.9.</span> <span class="toc-text">文件对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%92%8C%E8%BF%9B%E7%A8%8B%E6%9C%89%E5%85%B3%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">10.10.</span> <span class="toc-text">和进程有关的数据结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-number">11.</span> <span class="toc-text">进程地址空间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">11.1.</span> <span class="toc-text">内存描述符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">11.1.1.</span> <span class="toc-text">分配内存描述符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#mm-struct%E4%B8%8E%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B"><span class="toc-number">11.1.2.</span> <span class="toc-text">mm_struct与内核线程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F"><span class="toc-number">11.2.</span> <span class="toc-text">虚拟内存区域</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E7%9A%84%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F"><span class="toc-number">11.2.1.</span> <span class="toc-text">实际的内存区域</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mmap%E5%92%8Cdo-mmap%EF%BC%9A%E5%88%9B%E5%BB%BA%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F"><span class="toc-number">11.3.</span> <span class="toc-text">mmap和do_mmap：创建内存区域</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/.github.io/2024/12/03/%E5%9B%BE%E8%A7%A3HTTP/" title="图解HTTP">图解HTTP</a><time datetime="2024-12-03T03:35:49.000Z" title="发表于 2024-12-03 11:35:49">2024-12-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/.github.io/2024/11/28/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/" title="自顶向下方法">自顶向下方法</a><time datetime="2024-11-28T12:05:16.000Z" title="发表于 2024-11-28 20:05:16">2024-11-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/.github.io/2024/11/12/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/" title="程序员的自我修养-第十一章">程序员的自我修养-第十一章</a><time datetime="2024-11-12T08:29:32.000Z" title="发表于 2024-11-12 16:29:32">2024-11-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/.github.io/2024/11/12/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-%E7%AC%AC%E5%8D%81%E7%AB%A0/" title="程序员的自我修养-第十章">程序员的自我修养-第十章</a><time datetime="2024-11-12T03:08:23.000Z" title="发表于 2024-11-12 11:08:23">2024-11-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/.github.io/2024/11/11/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/" title="虚拟内存">虚拟内存</a><time datetime="2024-11-11T01:46:18.000Z" title="发表于 2024-11-11 09:46:18">2024-11-11</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://s2.loli.net/2023/02/26/9fQnztK2ImqyLwS.webp')"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By John Doe</div><div class="footer_custom_text">Hi, welcome to my <a href="https://tjzhang-src.github.io/.github.io/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/.github.io/js/utils.js"></script><script src="/.github.io/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>function loadWaline () {
  function initWaline () {
    const waline = Waline.init(Object.assign({
      el: '#waline-wrap',
      serverURL: 'https://blog-comment-bfstu88s1-ttj2023.vercel.app/',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      path: window.location.pathname,
      comment: false,
    }, null))
  }

  const walineCSSLoad = document.getElementById('waline-css')

  if (typeof Waline === 'object') {
    walineCSSLoad ? initWaline() : getCSS('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.css','waline-css').then(initWaline)
  }
  else {
    getCSS('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.css','waline-css').then(() => {
      getScript('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.js').then(initWaline)
    })
  }
}

if ('Waline' === 'Waline' || !true) {
  if (true) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
  else setTimeout(loadWaline, 0)
} else {
  function loadOtherComment () {
    loadWaline()
  }
}</script><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'https://tjzhang-src.github.io/.github.io/2024/10/22/linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/'
    this.page.identifier = '/.github.io/2024/10/22/linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/'
    this.page.title = 'linux内核设计与实现'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }

  document.getElementById('darkmode').addEventListener('click', () => {
    setTimeout(() => window.disqusReset(), 200)
  })
}

if ('Waline' === 'Disqus' || !true) {
  if (true) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>