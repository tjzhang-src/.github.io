<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>操作系统-精髓与设计原理 | Welcome</title><meta name="author" content="John Doe"><meta name="copyright" content="John Doe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="概述指令的执行最简单指令处理包含两步：读取执行、执行指令。PC保存下一次要取的指令地址。取到的指令放到IR中。指令执行的动作分为四类：  从处理器到存储器传数据 从处理器到IO传数据 处理数据，加减 控制，指定下一次指令从某个地方读取  中断中断和指令周期    长IO等待：IO程序执行的时间太长，导致新WRITE调用来了，旧的WRITE操作还没有完全完成，所有新WRITE操作必须阻塞，等到第一次">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统-精髓与设计原理">
<meta property="og:url" content="https://tjzhang-src.github.io/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/index.html">
<meta property="og:site_name" content="Welcome">
<meta property="og:description" content="概述指令的执行最简单指令处理包含两步：读取执行、执行指令。PC保存下一次要取的指令地址。取到的指令放到IR中。指令执行的动作分为四类：  从处理器到存储器传数据 从处理器到IO传数据 处理数据，加减 控制，指定下一次指令从某个地方读取  中断中断和指令周期    长IO等待：IO程序执行的时间太长，导致新WRITE调用来了，旧的WRITE操作还没有完全完成，所有新WRITE操作必须阻塞，等到第一次">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2024-10-21T01:07:24.000Z">
<meta property="article:modified_time" content="2024-11-13T07:57:00.768Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="os">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/.github.io/img/favicon.png"><link rel="canonical" href="https://tjzhang-src.github.io/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//hm.baidu.com"/><link rel="stylesheet" href="/.github.io/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?4cc6526274b17acfe67a4be7d70e8d1c";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-FF1BJEGK51"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-FF1BJEGK51');
</script><script>const GLOBAL_CONFIG = { 
  root: '/.github.io/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '操作系统-精髓与设计原理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-11-13 15:57:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (false) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/.github.io/archives/"><div class="headline">文章</div><div class="length-num">43</div></a><a href="/.github.io/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/.github.io/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/.github.io/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/.github.io/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/.github.io/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/.github.io/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/.github.io/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/.github.io/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/.github.io/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/.github.io/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s2.loli.net/2023/02/26/9fQnztK2ImqyLwS.webp')"><nav id="nav"><span id="blog-info"><a href="/.github.io/" title="Welcome"><span class="site-name">Welcome</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/.github.io/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/.github.io/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/.github.io/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/.github.io/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/.github.io/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/.github.io/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/.github.io/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/.github.io/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">操作系统-精髓与设计原理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-21T01:07:24.000Z" title="发表于 2024-10-21 09:07:24">2024-10-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-13T07:57:00.768Z" title="更新于 2024-11-13 15:57:00">2024-11-13</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>37分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="操作系统-精髓与设计原理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="指令的执行"><a href="#指令的执行" class="headerlink" title="指令的执行"></a>指令的执行</h4><p>最简单指令处理包含两步：读取执行、执行指令。<code>PC</code>保存下一次要取的指令地址。取到的指令放到<code>IR</code>中。指令执行的动作分为四类：</p>
<ul>
<li>从处理器到存储器传数据</li>
<li>从处理器到IO传数据</li>
<li>处理数据，加减</li>
<li>控制，指定下一次指令从某个地方读取</li>
</ul>
<h4 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h4><h5 id="中断和指令周期"><a href="#中断和指令周期" class="headerlink" title="中断和指令周期"></a>中断和指令周期</h5><img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241102164055963.png" class title="image-20241102164055963">

<blockquote>
<p> 长IO等待：IO程序执行的时间太长，导致新WRITE调用来了，旧的WRITE操作还没有完全完成，所有新WRITE操作必须阻塞，等到第一次WRITE完成才行。</p>
</blockquote>
<img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241102164353691.png" class title="image-20241102164353691">

<blockquote>
<p>对于右侧的长IO等待，在IO操作未完成时，与用户指令的执行有重叠，正是这部分指令导致了效率的提高。</p>
</blockquote>
<h5 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h5><p>中断激活了很多事件，包括处理器<strong>硬件的事件和软件的事件（要注意那些是硬件完成的，哪些是软件完成的，廖总经常强调的）</strong>。</p>
<img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241102165734068.png" class title="image-20241102165734068">

<img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241102165748557.png" class title="image-20241102165748557">

<img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241102170533258.png" class title="image-20241102170533258">

<h5 id="多个中断"><a href="#多个中断" class="headerlink" title="多个中断"></a>多个中断</h5><p>一种是在中断运行时禁止其他中断，只有当处理器完成当前中断时，才由处理器检查是否有中断。</p>
<p>另一种是定义中断优先级，允许高优先级打断低优先级中断。</p>
<h4 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h4><p>存储器的目标可以归纳为三个问题：<strong>多大容量，多快速度，多贵价格</strong>。</p>
<p>通常既需要快速的又需要大容量的存储器。这不能使用单一存储器来实现，而是使用存储器层次结构。</p>
<p><strong>访问的局部性原理：</strong>短时间内，处理器的指令访存和数据访存呈簇状。</p>
<img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241102171519336.png" class title="image-20241102171519336">

<p>高速缓存通常对程序员以及处理器<strong>都不可见</strong>，高速缓存用于在内存和寄存器之间分段移动数据，以提高数据访问的性能。</p>
<p><strong>磁盘</strong></p>
<p>磁盘可以作为内存的拓展，即虚拟内存。（<strong>本质存在磁盘上</strong>）</p>
<p>在软件中可以有效地增加额外的存储层次。比如一部分内存作为<strong>缓冲区</strong>，也有时称为磁盘高速缓存（<strong>本质在内存上</strong>）。</p>
<p>两种方式提高磁盘性能：选择整批数据传入传出；把数据先放到缓冲区上，万一待会儿还要改呢。 </p>
<h4 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h4><p>高速缓存对操作系统不可见，但他会与其他存储管理硬件相互影响。</p>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>当处理器尝试访问字节时，会先检查该字节是否在高速缓存上</p>
<ul>
<li>若在，则将该字节通过高速缓存传入CPU</li>
<li>若不在，则将由固定数量的字节构成的内存数据读入高速缓存，然后将该字节从高速缓存读入CPU。</li>
</ul>
<p>高速缓存包含若干槽，每个槽可以存储若干字，当需要从内存读入数据时，则从内存读取槽大小的数据到缓存的某个槽中。</p>
<img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241102184957851.png" class title="image-20241102184957851">

<h4 id="直接内存存取"><a href="#直接内存存取" class="headerlink" title="直接内存存取"></a>直接内存存取</h4><blockquote>
<p>IO感觉应该指的是从内存读入或读出</p>
</blockquote>
<p>执行IO操作主要包含三种方式：<strong>可编程I&#x2F;O, 中断驱动I&#x2F;O和直接内存存取。</strong></p>
<ul>
<li>可编程I&#x2F;O：CPU给某个I&#x2F;O模块发命令，然后I&#x2F;O模块执行命令并设置状态寄存器中的位（不会通知CPU，尤其是不会中断处理器）。因此处理器执行IO命令后需要定期检查IO模块的状态。（基本上没用这种了吧，STM32的串口都是用的中断）</li>
<li>中断驱动I&#x2F;O：区别在于，然后I&#x2F;O模块执行命令后，会用中断打断处理器的执行请求服务，然后恢复处理器以前的执行过程。<strong>数据的传输会经过处理器。</strong></li>
</ul>
<p>这两种方式都有以下的缺陷：</p>
<ul>
<li>IO传输速度受限于处理器测试设备和提供服务的速度</li>
<li>处理器忙于管理IO传送，需要执行很多指令来完成IO传送。</li>
</ul>
<p><strong>更有效地技术：DMA</strong></p>
<p>DMA需要控制总线来进行数据传输，CPU可能执行速度会变慢，但是也会比中断驱动IO更有效。</p>
<h4 id="多处理器和多核计算机"><a href="#多处理器和多核计算机" class="headerlink" title="多处理器和多核计算机"></a>多处理器和多核计算机</h4><blockquote>
<p>虽然一般任务处理器按照顺序执行指令，每条指令依次取值、取操作数、执行、存储。但在微观上，在进行本条指令的执行时会进行下一条指令的取值，这其实是并行执行的例子。</p>
</blockquote>
<p>常见的三种并行方式：</p>
<h5 id="对称多处理器-SMP"><a href="#对称多处理器-SMP" class="headerlink" title="对称多处理器(SMP)"></a>对称多处理器(SMP)</h5><p>处理器共享IO和内存，由一个统一的操作系统控制。</p>
<img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241102192433194.png" class title="image-20241102192433194">

<p>有个缺陷是，多个高速缓存之间如何保证一致？硬件主导的同步。</p>
<h5 id="多核计算机"><a href="#多核计算机" class="headerlink" title="多核计算机"></a>多核计算机</h5><p>又称芯片多处理器，发现</p>
<h3 id="操作系统概述"><a href="#操作系统概述" class="headerlink" title="操作系统概述"></a>操作系统概述</h3><h4 id="目标与功能"><a href="#目标与功能" class="headerlink" title="目标与功能"></a>目标与功能</h4><h5 id="作为接口的操作系统"><a href="#作为接口的操作系统" class="headerlink" title="作为接口的操作系统"></a>作为接口的操作系统</h5><p>常见接口：<img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241102194840920.png" class title="image-20241102194840920"></p>
<h5 id="作为资源管理器的操作系统"><a href="#作为资源管理器的操作系统" class="headerlink" title="作为资源管理器的操作系统"></a><strong>作为资源管理器的操作系统</strong></h5><p>管理IO、存储器、处理器</p>
<h4 id="操作系统的演化"><a href="#操作系统的演化" class="headerlink" title="操作系统的演化"></a>操作系统的演化</h4><ul>
<li>串行处理</li>
<li>简单批处理：有一个监控程序常驻内存，用于加载程序，每次一个。</li>
<li>多道批处理程序：可以加载多个程序到内存，有一个程序在等待IO时可以切换到另一个程序。</li>
<li>分时系统，为了及时响应单个用户的请求</li>
</ul>
<h4 id="主要成就"><a href="#主要成就" class="headerlink" title="主要成就"></a>主要成就</h4><h5 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h5><img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241102203035246.png" class title="image-20241102203035246">

<h5 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h5><p><strong>微内核：</strong>是一种操作系统架构，它提供了操作系统的核心功能，如任务管理、线程管理、进程间通信（IPC）和内存管理等。在微内核架构中，大部分内核服务如文件系统、设备驱动等作为用户态的进程运行，这些服务之间通过消息传递进行通信。微内核的设计使得系统具有高度的模块化，一个服务的故障不会影响其他服务。</p>
<p><strong>多线程</strong>：</p>
<p>线程：包括处理器上下文环境以及栈中自身的数据。</p>
<p>进程：一个或多个线程以及相关资源（存储器空间、打开文件与设备）的集合。</p>
<h4 id="多核操作系统设计考虑因素"><a href="#多核操作系统设计考虑因素" class="headerlink" title="多核操作系统设计考虑因素"></a>多核操作系统设计考虑因素</h4><p>除了考虑同步、调度、并发进程和线程等问题，主要要考虑的是并行规模问题。对于当前的多核系统，并行分为三个层面：</p>
<ul>
<li>指令级并行，每个核心内部同时执行多个任务（比如超标量架构）</li>
<li>处理器层次的并行，在处理器上多线程程序的执行能力</li>
<li>多核上一个应用程序以并发多线程执行的能力</li>
</ul>
<p>并行的实现方式：</p>
<p>应用层并行，虚拟机方式</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>Linux可以动态的加载和卸载内核模块。</p>
<img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241102215501976.png" class title="image-20241102215501976">

<img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241102215510093.png" class title="image-20241102215510093">

<h3 id="进程描述与控制"><a href="#进程描述与控制" class="headerlink" title="进程描述与控制"></a>进程描述与控制</h3><h4 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h4><p>进程控制块包含了进程的充分信息，这为中断进程，再执行提供了支持。</p>
<img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241103110835908.png" class title="image-20241103110835908">

<p>新建态和退出态也很有用，当操作系统创建好进程的表格，进程就处于新建态，此时进程本身的程序还不在内存。程序的终止将使程序处于终止态，一些表和历史信息还是会保存在内存中，操作系统不需要了才彻底删除。</p>
<h5 id="被挂起的进程"><a href="#被挂起的进程" class="headerlink" title="被挂起的进程"></a>被挂起的进程</h5><p>挂起：一个新的进程状态。当系统中出现大量阻塞进程影响执行新进程时，会将进程挂起，并转移到磁盘，释放空间供另一个进程使用。</p>
<img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241103113627910.png" class title="image-20241103113627910">

<ul>
<li>阻塞-&gt;阻塞挂起：需要腾出空间时</li>
<li>就绪&#x2F;挂起-&gt;就绪：内存没有就绪进程或者挂起的进程比内存进程优先级高时</li>
<li>就绪-&gt;就绪&#x2F;挂起：对于低优先级的就绪进程和高优先级的阻塞进程（并且操作系统确信他很快会就绪），则会挂起就绪进程。</li>
</ul>
<p>挂机就等价于不在内存的进程。</p>
<img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241103114432112.png" class title="image-20241103114432112">

<h4 id="进程描述"><a href="#进程描述" class="headerlink" title="进程描述"></a>进程描述</h4><p>操作系统如何控制进程以及管理资源</p>
<h5 id="操作系统的控制结构"><a href="#操作系统的控制结构" class="headerlink" title="操作系统的控制结构"></a>操作系统的控制结构</h5><p>为了掌握每个进程和资源的状态，需要构造并维护每个实体的信息表：<strong>内存、I&#x2F;O、文件和进程</strong></p>
<h5 id="进程控制结构"><a href="#进程控制结构" class="headerlink" title="进程控制结构"></a>进程控制结构</h5><p>属性集称为进程控制块。程序、数据、栈和属性的集合称为进程映像。</p>
<p>进程控制块信息包括三类：</p>
<ul>
<li>进程标识信息：PID, PPID, 用户ID（说明拥有该进程的用户）</li>
<li>进程（处理器）状态信息：由寄存器的内容组成，包含用户可见寄存器、控制和状态寄存器以及栈指针。</li>
<li>进程控制信息：操作系统控制和协调各种活动进程所需的额外信息。</li>
</ul>
<img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241103140941059.png" class title="image-20241103140941059">

<h4 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h4><h5 id="执行控制"><a href="#执行控制" class="headerlink" title="执行控制"></a>执行控制</h5><p>一般来说，处理器有很多种执行模式，有些只能在特权模式下执行。处理器如何知道自己处于什么模式，如何切换？</p>
<blockquote>
<p>PSW通常有一个指示执行模式的位，当调用系统服务或中断来触发系统例程时，执行模式被设为内核模型，返回用户进程时，被设为用户模式。（比如说，发生中断时，由硬件清空标志位，返回时，由程序员手动设置标志位）</p>
</blockquote>
<h5 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h5><img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241103143319896.png" class title="image-20241103143319896">

<h5 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h5><p>什么时候切换？<strong>一旦操作系统从进程手中拿回了控制权，就可能切换。</strong></p>
<img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241103144406031.png" class title="image-20241103144406031">

<p>模式切换是什么？从用户模式切换到内核模式，这里保存上下文以及恢复上下文仅需很小的开销，还是硬件完成的（ARM里面就是R1-R3，PC, SP, PSW差不多吧）。如果切换进程，则需要做很多额外的处理。</p>
<img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241103145811703.png" class title="image-20241103145811703">

<h4 id="操作系统的执行"><a href="#操作系统的执行" class="headerlink" title="操作系统的执行"></a>操作系统的执行</h4><p>操作系统是进程吗，如何处理他和其他进程关系</p>
<h5 id="无内核进程"><a href="#无内核进程" class="headerlink" title="无内核进程"></a>无内核进程</h5><p>这讲的也好复杂，看最后一句吧。</p>
<img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241103152626962.png" class title="image-20241103152626962">

<h5 id="在用户进程内运行"><a href="#在用户进程内运行" class="headerlink" title="在用户进程内运行"></a>在用户进程内运行</h5><p><strong>即在用户进程的上下文执行所有操作系统软件。</strong>相当于用户调用系统函数。进程在内核模型运行时，有单独的内核栈，操作系统代码和数据位于共享地址空间。当发生中断陷阱系统调用时，需要保存模式上下文并<strong>切换模式</strong>，再切换到操作系统例程，但此时仍然是在用户进程内继续执行，不需要切换进程，只是在<strong>同一进程内切换模式</strong>。</p>
<h5 id="基于进程的操作系统"><a href="#基于进程的操作系统" class="headerlink" title="基于进程的操作系统"></a>基于进程的操作系统</h5><p>鼓励模块化，有些简单的功能可以用独立的进程实现，多处理器环境可以把服务放到单独的机器上。</p>
<blockquote>
<p>前面说过，进程可以通过中断陷阱系统调用访问操作系统代码，但这三个东西其实都是中断，系统调用也是通过软中断实现的嘛，中断触发后，切换处理器模式，保存上下文，然后调转到系统对应的代码运行。（可见中断的重要性，要是没有中断，程序可能就没法访问操作系统，也没法终止了，除非执行完）</p>
</blockquote>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h4 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h4><h5 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h5><p>多线程指的是在<strong>单个进程内支持多个并发执行路径</strong>的能力。</p>
<p>线程优点：</p>
<img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241103160908083.png" class title="image-20241103160908083">

<h5 id="线程的功能"><a href="#线程的功能" class="headerlink" title="线程的功能"></a>线程的功能</h5><p><strong>线程状态：</strong>类似进程，也有运行、就绪和阻塞态。挂起态对线程没有意义，因为这类状态仅适用于进程，一个进程被挂起，所有线程都要被换出。</p>
<p>几个与线程状态有关的操作：</p>
<ul>
<li>派生：产生新进程时，会派生一个线程，线程可以派生另一个线程。</li>
<li>阻塞</li>
<li>解除阻塞</li>
<li>结束</li>
</ul>
<p><strong>假设线程阻塞不会导致整个进程阻塞</strong>，则会有如下优点。（具体会不会阻塞要看后面用户级线程和内核级线程）。</p>
<p>可明显的加快程序的运行速度。</p>
<img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241103163350299.png" class title="image-20241103163350299">

<p><strong>线程同步</strong></p>
<p>与进程同步相似。</p>
<h4 id="线程分类"><a href="#线程分类" class="headerlink" title="线程分类"></a>线程分类</h4><h5 id="用户级和内核级线程（ULT-amp-KLT）后者又称为轻量级进程"><a href="#用户级和内核级线程（ULT-amp-KLT）后者又称为轻量级进程" class="headerlink" title="用户级和内核级线程（ULT &amp; KLT）后者又称为轻量级进程"></a><strong>用户级和内核级线程（ULT &amp; KLT）</strong>后者又称为轻量级进程</h5><h6 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a><strong>用户级线程</strong></h6><p>在纯ULT软件中，管理线程的工作由应用程序完成，他需要包含创建以及销毁，保存以及恢复上下文、调度的代码。内核不知道这件事，仍然以进程为单位调度。</p>
<img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241103164946820.png" class title="image-20241103164946820">

<p>使用纯ULT的优点：</p>
<img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241103170246772.png" class title="image-20241103170246772">

<p>也有对应的缺点：</p>
<ul>
<li>执行系统调用时，会阻塞进程中的所有线程</li>
<li>多线程不能利用多处理技术，同时刻只有一个线程被执行，<strong>无法并行。</strong></li>
</ul>
<p>现在有方法解决这两个问题：比如把应用程序写成多进程程序（欸，不考虑资源开销吗）；另一种方式是使用<strong>套管（jacketing）</strong>的技术。套管的目标是把产生阻塞的系统调用转化为一个非阻塞的系统调用。例如，线程不去调用系统级的IO例程，而是调用应用级的IO套管例程，这个套管例程发现IO忙时会将线程阻塞将控制权传递给另一个线程。这个线程重新获得控制权后，套管例程会再次检查IO设备。(即用应用级的方式来模拟系统调用，把事件停留在应用能处理的范围内)</p>
<h6 id="内核级线程"><a href="#内核级线程" class="headerlink" title="内核级线程"></a>内核级线程</h6><p>在纯KLT软件中，管理线程的工作均由内核完成。应用级没有线程管理代码，只有一个到内核线程设施的语言编程接口。Windows就是这样。</p>
<p>内核级线程解决了上面ULT的两个问题，但会耗费更多时间，</p>
<h6 id="混合方法"><a href="#混合方法" class="headerlink" title="混合方法"></a>混合方法</h6><img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241103172644972.png" class title="image-20241103172644972">

<blockquote>
<p>比如说，对于想要实现并行的线程，则将他们按照1:1的映射到内核线程，对于响应节约时间开销的线程，则按照N:1的方式映射到内核线程。</p>
</blockquote>
<h5 id="其他方案"><a href="#其他方案" class="headerlink" title="其他方案"></a>其他方案</h5><p>线程与进程满足多对多的关系</p>
<h4 id="多核与多线程"><a href="#多核与多线程" class="headerlink" title="多核与多线程"></a>多核与多线程</h4><p>对于某一类型任务，随着核数增加，加速比会先增加后减小（任务调度和缓存一致性都会带来开销）</p>
<img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241103185220014.png" class title="image-20241103185220014">

<h4 id="Windows的进程和线程管理"><a href="#Windows的进程和线程管理" class="headerlink" title="Windows的进程和线程管理"></a>Windows的进程和线程管理</h4><ul>
<li><p>应用程序由一个或多个进程构成，</p>
</li>
<li><p>作业对象运行将一组进程作为一个单元来管理。</p>
</li>
<li><p>线程池是一个工作线程集，主要用来减少应用程序线程的数量。</p>
</li>
<li><p>纤程（fiber），工作在线程的上下文中。（应该是比线程还轻量级的线程）</p>
</li>
<li><p>用户模型调度（UMS, 感觉和ULT很类似），以用户模型切换UMS线程。</p>
</li>
</ul>
<p>此处省略一万字</p>
<h4 id="Linux的进程与线程管理"><a href="#Linux的进程与线程管理" class="headerlink" title="Linux的进程与线程管理"></a>Linux的进程与线程管理</h4><h5 id="Linux任务"><a href="#Linux任务" class="headerlink" title="Linux任务"></a>Linux任务</h5><img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241103193533056.png" class title="image-20241103193533056">

<blockquote>
<p>这里的可中断，感觉和中断不是同一个意思。这里应该指的是能否被打断的意思。不能被打断，则会一直等到等待的事件。可以被打断，则也可以接收信号，然后做出处理。</p>
</blockquote>
<img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241103192930669.png" class>

<h5 id="Linux线程"><a href="#Linux线程" class="headerlink" title="Linux线程"></a>Linux线程</h5><p>传统UNIX系统支持在每个进程中只执行一个线程。</p>
<p>Linux使用clone命令来代替fork来创建线程。</p>
<h5 id="Linux命名空间"><a href="#Linux命名空间" class="headerlink" title="Linux命名空间"></a>Linux命名空间</h5><p>命名空间可使一个进程（或共享同一命名空间的进程）拥有与其他命名空间下进程的不同的系统视图。<strong>命名空间和cgroups是Linux轻量级虚拟化的基础。</strong>他为一组或一个进程提供了一个错觉，认为自己是系统上唯一的进程。Linux有六种命名空间<strong>mnt、pid、net、ipc、uts和user。</strong></p>
<h3 id="并发：互斥和同步"><a href="#并发：互斥和同步" class="headerlink" title="并发：互斥和同步"></a>并发：互斥和同步</h3><p>并发会在三种上下文中出现。</p>
<ul>
<li>多应用程序</li>
<li>结构化应用程序</li>
<li>操作系统结构</li>
</ul>
<p>并发其实就是加强进程互斥的能力。</p>
<img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241103203023553.png" class title="image-20241103203023553">

<h4 id="互斥：软件解决方法"><a href="#互斥：软件解决方法" class="headerlink" title="互斥：软件解决方法"></a>互斥：软件解决方法</h4><h5 id="Dekker算法"><a href="#Dekker算法" class="headerlink" title="Dekker算法"></a>Dekker算法</h5><blockquote>
<p>mutex是操作系统提供的，他更高效和易用，但在一些平台，没有mutex，Dekker算法就有用了，它提供了手动实现互斥的方式。</p>
</blockquote>
<p>错误示范：</p>
<ul>
<li>用一个全局变量turn，当自身id等于turn才能进入。缺陷是如果某个进程在临界区终止了，可能导致另外一个进程永远无法进入</li>
<li>每个进程保存一个状态flag，先检查对方进程的flag，为false时将自己的flag进入临界区。缺陷是没法保证互斥，有可能同时进入，而且如过另一个进程在临界区停止，也会导致当前进程进不去。</li>
</ul>
<p>两个进程下：有两个标志turn和flag，turn指定了都想进入临界区时的先后顺序。每个进程有个flag，代表自己是否有意愿进入临界区。当一个进程要进入临界区时，先设置flag为true，</p>
<ul>
<li>如果另一个进程flag为false，则当前进程直接进入</li>
<li>如果另一个进程flag为true，则检查turn<ul>
<li>如果当前进程id等于turn，则等到另一个进程flag变为false时在进入，结束时再将turn置为另一个进程的id</li>
<li>如果当前进程id不等于turn，则将进程flag变为false变为false</li>
</ul>
</li>
</ul>
<p>（貌似这个另一个进程被意外终止，导致flag和trun失效的状态？看下面，wnm）</p>
<img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241103212237800.png" class title="image-20241103212237800">

<h5 id="Perterson算法"><a href="#Perterson算法" class="headerlink" title="Perterson算法"></a>Perterson算法</h5><h4 id="并发的原理"><a href="#并发的原理" class="headerlink" title="并发的原理"></a>并发的原理</h4><p>并发时，进程被交替执行，呈现出交替执行的状态。</p>
<p>在单处理器多道系统（多处理器也是一样的）下，进程的执行速度不可预测，这导致了很多问题。比如资源共享，资源分配，定位错误也非常困难。</p>
<p>在单处理器下，主要是因为中断可能在任何时候进行，导致访问了共享资源。在多处理器情况下，不仅同样的条件会引起问题，当两个进程在两个核上执行时，也会引发问题。<strong>这两类问题的解决方式都是一样的：控制对共享资源的访问。</strong></p>
<h5 id="操作系统并发带来新的管理问题"><a href="#操作系统并发带来新的管理问题" class="headerlink" title="操作系统并发带来新的管理问题"></a>操作系统并发带来新的管理问题</h5><img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241104084339484.png" class title="image-20241104084339484">

<h5 id="进程的交互"><a href="#进程的交互" class="headerlink" title="进程的交互"></a>进程的交互</h5><img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241104084904930.png" class title="image-20241104084904930">

<p>竞争进程面临三个控制问题</p>
<ul>
<li>互斥，在临界区只能允许一个程序访问（下面两个都是因为这个问题出现的）</li>
<li>死锁，都在等待对方的资源</li>
<li>饥饿，某些进程一直访问不到资源</li>
</ul>
<p>共享进程也面临上面几个问题，还需要注意一致性问题。</p>
<h5 id="互斥的要求"><a href="#互斥的要求" class="headerlink" title="互斥的要求"></a>互斥的要求</h5><blockquote>
<p>软件方法应该就是Perterson算法吧</p>
</blockquote>
<img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241104090333665.png" class title="image-20241104090333665">

<h4 id="互斥：硬件的支持"><a href="#互斥：硬件的支持" class="headerlink" title="互斥：硬件的支持"></a>互斥：硬件的支持</h4><p>几种实现互斥的硬件方法</p>
<h5 id="中断禁用"><a href="#中断禁用" class="headerlink" title="中断禁用"></a>中断禁用</h5><blockquote>
<p>一旦禁用了中断，时钟中断、系统调用等都不会产生，就都不会将处理器交给系统，也不会导致进程调度。这种方式代价很高，同时这种方式不能用于多处理器体系结构中。因为多个进程会同时执行。 </p>
</blockquote>
<h5 id="专用机器指令"><a href="#专用机器指令" class="headerlink" title="专用机器指令"></a>专用机器指令</h5><p>在多处理器配置中，几个处理器都可以对内存进行访问，处理器之间没有支持互斥的中断机制。</p>
<p>处理器的设计人员提供了机器指令，用来保证两个动作的原子性，<strong>在一个取值周期完成对一个存储单一的读和写或读和测试</strong>。</p>
<p>这个指令的执行过程中，任何其他指令访问内存都被阻止。</p>
<blockquote>
<p>from kimi</p>
<p>以下是在多核环境中CAS操作可能发生的情况：</p>
<ol>
<li><strong>原子性</strong>：CAS操作是原子的，这意味着在任何给定时间点，只有一个核心可以成功地执行CAS操作并更新内存位置。其他核心的CAS操作会检测到内存位置的值已经改变，因此它们的操作会失败。</li>
<li><strong>失败重试</strong>：当一个核心的CAS操作失败时，它可以根据应用的需要决定是否重试该操作。这种机制是实现自旋锁（spinlock）的基础，其中线程或核心在失败后不断重试，直到成功为止。</li>
</ol>
</blockquote>
<p>最常见的两个指令（这些指令本身就支持并发，不需要程序员做处理）包括：</p>
<ul>
<li><p>比较和交换指令 检测一个内存区域是否等于某个值，相等则更新该内存区域。同时刻只能有一个进程能执行这个命令，其他进程会进入自旋等待，除此以外不能做任何事。(很多操作系统都用该指令支持并发)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int compare_ and_ swap (int *word, int testval，int newval)</span><br><span class="line">    int oldval ;</span><br><span class="line">    oldval = *word</span><br><span class="line">    if (oldval == testval) *word = newval;</span><br><span class="line">    return oldval ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>exchange指令 </p>
<p>这个指令交换寄存器和存储单元的内容，IA-64中的XCHG命令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void exchange (int *register, int *memory)</span><br><span class="line">&#123;</span><br><span class="line">    int temp;</span><br><span class="line">    temp = * memory;</span><br><span class="line">    *memory = *register;</span><br><span class="line">    * register = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的图片展示了上述指令的使用：（这两个命令的原子性由硬件保证，即使是多核，也只能有一个指令执行。可以用它来实现锁机制）</p>
<img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241104102857000.png" class title="image-20241104102857000"></li>
</ul>
<p><strong>优点&amp;缺点</strong></p>
<img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241104104039707.png" class title="image-20241104104039707">

<blockquote>
<p>这两个指令本身不会带来死锁问题，在这两个指令的基础上实现的并发程序才可能出现死锁。</p>
</blockquote>
<h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>前文讲了通过软件和硬件的方式来设计并发程序，现在将介绍操作系统提供的<strong>并发机制</strong>。主要分为<strong>信号量、管城、消息传递</strong>三大类。</p>
<img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241104105439985.png" class title="image-20241104105439985">

<p>二元信号量和互斥量的关键区别是，互斥量只能由同一个进程加锁解锁，而二元信号量没有这个限制。</p>
<ul>
<li>强信号量，规定了进程从阻塞队列中移除顺序的信号量，<strong>保证不会饥饿</strong></li>
<li>弱信号量，没有规定了进程从阻塞队列中移除顺序的信号量</li>
</ul>
<blockquote>
<p>先把下图看懂吧。通过下图可以看出，<strong>一旦当把一个进程移出等待队列时，该进程应该就默认获得要申请的资源了，</strong>（不用再次等待了，再次运行时，应该运行的是semwait后面那条指令了）。之前讲过，进程可能处于不可中断&#x2F;可中断阻塞态，如果是可中断，意味着程序能够被除等待事件的其他事件唤醒，比如如果是一个信号唤醒了程序，让他移出了等待队列，那么该进程就觉得自己等到了资源，但实际是被意外唤醒的，所以很多程序还会在semwiat后面判断一下时是否真的获得了资源。</p>
</blockquote>
<img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241104113120733.png" class title="image-20241104113120733">

<blockquote>
<p>感觉并发主要就要处理互斥，以及互斥带来的问题：饥饿与死锁</p>
</blockquote>
<h5 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h5><p>用信号量实现互斥，将信号量初始化为一，然后如下图运行。</p>
<img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241104122648109.png" class title="image-20241104122648109">



<h5 id="消费者生产者问题"><a href="#消费者生产者问题" class="headerlink" title="消费者生产者问题"></a>消费者生产者问题</h5><ul>
<li>资源数量记得用信号量保存，而不是用局部变量保存，因为局部变量可能出现同步错误</li>
<li>先wait信号量再wait互斥量</li>
</ul>
<h5 id="信号量的实现"><a href="#信号量的实现" class="headerlink" title="信号量的实现"></a>信号量的实现</h5><p>如前所述，semWait和semSignal操作必须作为原子原语实现，可以通过硬件或软件（Dekker或Peterson算法）实现<strong>，本质是互斥</strong>，只要保证任何时候只有一个进程可用semWait和semSignal控制信号量就行了。</p>
<p>对于单处理器系统，直接禁中断也是可以的哟。</p>
<img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241104202035616.png" class title="image-20241104202035616">

<h4 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h4><p>信号量是为了实现互斥和进程间的合作，操作系统提供的一种强大但原始的工具，难点在于semWati可能分布在整个程序中，很难看清效果。</p>
<p>管程是一种程序设计语言结构，他提供与信号量相同的功能，但更易于控制。</p>
<h5 id="使用信号的管程"><a href="#使用信号的管程" class="headerlink" title="使用信号的管程"></a>使用信号的管程</h5><img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241104203053599.png" class title="image-20241104203053599">

<blockquote>
<p>感觉信号量和互斥量只保证了访问是互斥的，其实要访问的资源也只是个全局变量。而管程将这个全局变量和访问方式也封装到了类里面。</p>
</blockquote>
<ul>
<li><p>管程提供互斥机制，同时只能有一个进程进入管程</p>
</li>
<li><p>管程包含同步处理，管程通过条件变量来支持同步，有两个函数可以操作条件变量</p>
<ul>
<li><p>cwait，调用的进程在条件c上阻塞</p>
</li>
<li><p>csignal，恢复在cwait后因某些条件而被阻塞的一个进程</p>
<blockquote>
<p>与信号量的区别在于：管程中的一个进程发csignal，如果没有等待的任务，则丢弃这个信号。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241104211721096.png" class title="image-20241104211721096">

<img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241104211752818.png" class title="image-20241104211752818">

<p>管程相对于信号量的优点在于，所有的同步机制都<strong>限制在管程内部（互斥机制也是由管程提供的</strong>），因此不但易于验证同步的正确性，还容易检测出错误。<strong>如果一个管程编写正确，则所有进程对于资源的访问都是对的。如果是信号量，则要求所有访问资源的进程都被正确编写。</strong></p>
<blockquote>
<p>from kimi</p>
<p>管程的互斥机制是由编译器提供的。在管程的设计中，编译器确保在同一时间内只有一个进程可以进入管程执行，这样可以保证对共享资源的互斥访问，避免多个进程同时访问共享资源而引起的数据不一致问题。这种互斥是由编译器强制实施的，程序员在编写使用管程的代码时不需要显式地处理互斥问题，这简化了并发编程的复杂性。简而言之，管程作为一种高级同步机制，封装了对共享资源的访问，而编译器负责实现这种封装背后的互斥逻辑。</p>
</blockquote>
<h5 id="使用通知和广播的管程"><a href="#使用通知和广播的管程" class="headerlink" title="使用通知和广播的管程"></a>使用通知和广播的管程</h5><p>Hoare关于管程的定义要求一个进程产生csignal信号时，当前进程立刻退出或阻塞，并运行队列中的一个进程。这有一些缺陷：</p>
<ul>
<li>导致额外的进程切换</li>
<li>调度程序必须非常可靠</li>
</ul>
<p>为此，Mesa语言有一种不同的管程。它使用cnotify代替csignal，cnotify会让发信号的进程继续运行，也会使条件队列得到通知，让他们在处理器可用时在运行。</p>
<img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241104221221108.png" class title="image-20241104221221108">

<ul>
<li><p>这里用while代替if，可以多检查一次条件变量</p>
</li>
<li><p>也可以给每个添加原语添加一个计时器，不管有没有被通知，计时器超时就会唤醒等待队列的第一个进程，就算误唤醒了也有while循环再次阻塞。这可以避免饥饿状态。</p>
</li>
<li><p>进程是接到通知而非强制激活，所有可以增加一个cbroadcasst原语，当不知道激活多少个进程时，不如就全部激活。</p>
</li>
</ul>
<img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241104222052411.png" class title="image-20241104222052411">

<h4 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h4><blockquote>
<p>同步让两个线程，一个运行完毕，另一个才能运行。所以同步是一种更复杂的互斥，而互斥是一种特殊的同步。</p>
</blockquote>
<p>为了实现合作，进程间应该交换信息，提供这个功能的是消息传递，消息传递还有一个优点，它可以在分布式系统，多处理器系统和单处理器系统中实现。</p>
<p>消息传递的功能以一对原语的形式提供：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">send(destination, message)</span><br><span class="line">receive(source, message)</span><br></pre></td></tr></table></figure>

<p>下表给出了消息传递系统的一些设计问题，后文将分析这些问题。</p>
<img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241105094828731.png" class title="image-20241105094828731">

<h5 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h5><p>隐含着同步的信息：一个进程发消息后，另一个进程才能接收消息。</p>
<p>发送方可以阻塞（知道接收方收到）也可以不阻塞，接收方可以阻塞直到等到消息或者不阻塞。可以分为三种组合：</p>
<img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241105095839190.png" class title="image-20241105095839190">

<p>无阻塞send很常用，但可能会导致还需要应答消息来判断对方是否收到，增加了程序员的负担。</p>
<p>阻塞receive很常用，但如果发送消息的进程消息丢失，则接收进程会无限期的阻塞，可以利用无阻塞receive来解决，但也可能出现消息丢失，可能的办法是</p>
<ul>
<li>receive先判断有没有消息</li>
<li>如果可以接受多个源进程的消息，。。。</li>
</ul>
<h5 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h5><ul>
<li><p>直接寻址</p>
<ul>
<li>send，要求目标进程的标识号</li>
<li>receive，显式指定，隐式指定</li>
</ul>
</li>
<li><p>间接寻址，给信箱发消息，接收消息，这允许1：1，m：1，1：m的关系。</p>
<img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241105101354824.png" class title="image-20241105101354824"></li>
</ul>
<p>进程与信箱的关系可能是静态的（1：1很可能是静态的），也可以是动态的。m：1关系时，信箱又被称为端口，端口的所有者是接收进程，撤销接收进程时，端口也会被撤销。对于通用的信箱，可以指定信箱归创建他的进程或操作系统所有。</p>
<h5 id="互斥-1"><a href="#互斥-1" class="headerlink" title="互斥"></a>互斥</h5><p>信箱虽然能实现同步，也能实现互斥，只允许一个进程读取该信箱。</p>
<img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241105104032095.png" class title="image-20241105104032095">

<h4 id="读者写者问题"><a href="#读者写者问题" class="headerlink" title="读者写者问题"></a>读者写者问题</h4><p>区分一下读者写者问题与一般互斥问题和生产者&#x2F;消费者问题。</p>
<ul>
<li>一般互斥问题是读者写者的一般情况，之所以要关注读者写者问题，是想要制定更高效的方案</li>
<li>生产者&#x2F;消费者问题不是读者写者问题，生产者也要写（取出一个单元）。</li>
</ul>
<p>下面分析读者写者问题的两种解决办法：</p>
<h5 id="读者优先"><a href="#读者优先" class="headerlink" title="读者优先"></a>读者优先</h5><p>欸，原文好难，后面看看吧。</p>
<h3 id="并发：饥饿和死锁"><a href="#并发：饥饿和死锁" class="headerlink" title="并发：饥饿和死锁"></a>并发：饥饿和死锁</h3><h4 id="死锁原理"><a href="#死锁原理" class="headerlink" title="死锁原理"></a>死锁原理</h4><h5 id="可重用资源"><a href="#可重用资源" class="headerlink" title="可重用资源"></a>可重用资源</h5><p>一次仅供一个进程安全使用而不因使用而耗尽的资源。如处理器，IO, 设备。这类问题的发生可能隐藏在复杂的程序逻辑中，难以检测。</p>
<h5 id="可消耗资源"><a href="#可消耗资源" class="headerlink" title="可消耗资源"></a>可消耗资源</h5><p>指的是可被创建和销毁的资源，数量通常没有限制，用完后该资源就不存在了，如信号，中断。</p>
<img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241105165832915.png" class title="image-20241105165832915">

<h5 id="死锁的必要条件"><a href="#死锁的必要条件" class="headerlink" title="死锁的必要条件"></a>死锁的必要条件</h5><ul>
<li>资源互斥</li>
<li>占用且等待</li>
<li>不可抢占资源</li>
<li>循环等待</li>
</ul>
<h4 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h4><ul>
<li>间接预防，阻止前三个必要条件<ul>
<li>互斥，没办法禁止呀，并发程序设计的基础就是这个</li>
<li>占有且等待（资源状态容易恢复时，这个才work），可以一次性分配完所有要的资源</li>
<li>不可抢占，预防不可抢占的方法有几种，比如<ul>
<li>如果占有资源的进程申请新资源被拒绝，则它应该释放所有资源</li>
<li>一个进程请求的资源被另一个进程占有时，操作系统可以抢占另一个进程，（高优先级进程应该可以抢占低优先级进程的资源）</li>
</ul>
</li>
</ul>
</li>
<li>直接预防，阻止第四个条件（循环等待）的发生<ul>
<li>给资源排序，只能先申请前面的，在申请后面的。</li>
</ul>
</li>
</ul>
<h4 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h4><p>死锁预防虽然可以预防死锁，但会导致效率变低。使用死锁避免，可以明智的选择，让系统达不到死锁。两种避免方法：</p>
<ul>
<li>一个进程的请求会导致死锁，则不启动该进程<ul>
<li>实现判断进程启动后所消耗的所有资源，如果超过系统量，则不启动</li>
</ul>
</li>
<li>一个进程增加的资源请求会导致死锁，则不允许这个资源分配<ul>
<li>又名<strong>银行家算法</strong></li>
</ul>
</li>
</ul>
<p>使用死锁避免时，必须先声明每个进程请求的最大资源，所讨论的进程必须是无关的，即他们的执行顺序没有同步的限制（那这不可能呀），分配的资源数量固定。</p>
<h4 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h4><h5 id="死锁检测算法"><a href="#死锁检测算法" class="headerlink" title="死锁检测算法"></a>死锁检测算法</h5><p>死锁检测可以在每个资源请求时发生。</p>
<h5 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h5><ul>
<li><p>取消所有死锁进程</p>
</li>
<li><p>回滚死锁进程到前面定义的检查点</p>
</li>
<li><p>按照最小代价取消死锁进程</p>
</li>
<li><p>连续抢占资源直到没有死锁</p>
</li>
</ul>
<img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241105185253069.png" class title="image-20241105185253069">

<h4 id="一种综合的死锁策略"><a href="#一种综合的死锁策略" class="headerlink" title="一种综合的死锁策略"></a>一种综合的死锁策略</h4><img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241105190150572.png" class title="image-20241105190150572">

<h4 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h4><p>五人五叉子，每个人要两个叉子，算法要互斥（不能用同一个叉子），也要避免饥饿和死锁。</p>
<h5 id="基于信号量"><a href="#基于信号量" class="headerlink" title="基于信号量"></a>基于信号量</h5><p>如果先拿左边的，再拿右边的，会导致死锁。可以通过信号量只让四个哲学家进入。</p>
<h5 id="基于管程"><a href="#基于管程" class="headerlink" title="基于管程"></a>基于管程</h5><p>因为管程中的过程是不能中断的（<a target="_blank" rel="noopener" href="https://www.nowcoder.com/questionTerminal/7f99f77a50be4d36858290636f822ef3">管程</a>），并且同时只能用一个进程进入管程，所以第一个哲学家能拿起左叉子，也能拿到右边的叉子。</p>
<h4 id="UNIX并发机制"><a href="#UNIX并发机制" class="headerlink" title="UNIX并发机制"></a>UNIX并发机制</h4><p>几种重要的并发机制：</p>
<p><strong>管道、消息、共享内存、信号量、信号</strong>（前三种提供了进程间传输数据的方式，也就实现了同步）</p>
<ul>
<li>管道是一个环形缓冲区，允许多个进程以生产者消费者模型进行通信</li>
<li>消息，类似于信箱</li>
<li>共享内存，速度最快</li>
<li>信号量，由如下元素组成：当前值，最后一个进程的id，</li>
<li>信号，给进程发事件的机制，只有在进程被唤醒或者从系统调用返回时，才能处理信号（这话在linux中应该不对喔）。</li>
</ul>
<h4 id="Linux内核并发机制"><a href="#Linux内核并发机制" class="headerlink" title="Linux内核并发机制"></a>Linux内核并发机制</h4><p>包含UNIX中所有并发机制。Linux还支持一种特殊的信号，<strong>实时信号</strong></p>
<img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241105201500402.png" class title="image-20241105201500402">

<p>Linux还未内核线程准备了丰富的并发机制，他们可以用在内核中。</p>
<h5 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h5><p>Linux提供了对<strong>变量的原子操作</strong>。原子操作执行时不会被打断，如果是单处理器，操作开始到结束，不能中断线程，如果是多处理，还需要锁住变量以免被其他进程访问。</p>
<ul>
<li>一种是对整数变量的整数操作</li>
<li>另一种是针对位图中某一位的位图操作</li>
</ul>
<blockquote>
<p>某些体系中，有对应的汇编指令，没有汇编指令就会锁住内存主线保证原子性</p>
</blockquote>
<img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241105202618116.png" class title="image-20241105202618116">

<h5 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h5><p>保护临界区的技术，首先检查内存区域的一个值是否为0，为0则进入并置1，非零则一直忙等待（而不是阻塞，如果锁持有时间非常短，那他相比阻塞导致的线程切换会少花费很多时间）</p>
<ul>
<li>普通自旋锁，不改变中断状态，确信临界区代码不被中断打断或者已经关闭了中断的情况下使用</li>
<li>_irq, 与普通自旋锁类似，但会在临界区关闭中断</li>
<li>_irqsave, 执行前保存中断状态，从临界区返回时，恢复中断状态。</li>
<li>_bh, 发生中断时，</li>
</ul>
<h5 id="信号量-1"><a href="#信号量-1" class="headerlink" title="信号量"></a>信号量</h5><h5 id="屏障"><a href="#屏障" class="headerlink" title="屏障"></a>屏障</h5><p>为了优化性能，部分指令编译时会交换顺序。</p>
<p>内存屏障可以保证之前的代码和之后的代码没办法穿过屏障。</p>
<h3 id="内存管理-1"><a href="#内存管理-1" class="headerlink" title="内存管理"></a>内存管理</h3><img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241105214811260.png" class title="image-20241105214811260">

<h4 id="内存管理的需求"><a href="#内存管理的需求" class="headerlink" title="内存管理的需求"></a>内存管理的需求</h4><p><strong>重定位，保护，共享，逻辑组织，物理组织</strong></p>
<h5 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h5><p>处理器硬件和软件必须以某种方式把程序代码中地址转化为实际的物理内存地址。</p>
<h5 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h5><p>防止访问不该访问的内存，处理器硬件才具有这个能力。</p>
<h4 id="内存分区"><a href="#内存分区" class="headerlink" title="内存分区"></a>内存分区</h4><p>常见的内存管理技术如下图所示，xx分区技术早已过时，简单分页&#x2F;分段没有实际使用过。</p>
<img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241106215420918.png" class title="image-20241106215420918">

<h5 id="前几种分区"><a href="#前几种分区" class="headerlink" title="前几种分区"></a>前几种分区</h5><p>略</p>
<h5 id="重定位-1"><a href="#重定位-1" class="headerlink" title="重定位"></a>重定位</h5><ul>
<li>逻辑地址，当前数据在内存中的（与物理地址无关的）地址</li>
<li>相对地址，相对于某些点（通常是程序的开始）的存储单元</li>
<li>物理地址，数据在内存的实际地址</li>
</ul>
<p>系统使用运行时动态加载的方式将相对地址的程序加载到内存，通常有一个基址寄存器保存程序的在内存的开始位置，还有一个界限寄存器指明程序的终止位置，遇到相对地址时，会将相对地址与基地址寄存器，在与界限寄存器比较，超过则触发中断。</p>
<img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241106221912727.png" class title="image-20241106221912727">

<h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>若使用大小不等的固定分区，会导致内部碎片，若使用大小可变的外部分区，会导致外部碎片。使用页时，只有进程尾部有内部碎片。</p>
<p>在分页中，每个进程维护一个页表，页表给出了该进程的每页所对应的页框的位置。每个逻辑地址包含一个页号和在该页中的偏移量，逻辑地址到物理地址的转换有处理器硬件完成，处理器使用页表产生物理地址（包括页框号和偏移量）。</p>
<h3 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h3><img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241107220653705.png" class title="image-20241107220653705">

<h3 id="加载与链接"><a href="#加载与链接" class="headerlink" title="加载与链接"></a>加载与链接</h3><ul>
<li><p>绝对加载，在编译时就指定每个内存访问的绝对地址（静态链接，比如从0x0000000000400000开始）</p>
</li>
<li><p>可重定位加载，加载前目标文件使用的是相对地址，加载器再把程序加载到内存的xxx地址时，给每个内存访问都加上xxx。（动态链接一般采用这种方式，加载时会修改.got和.plt.got段来进行重定位）</p>
</li>
<li><p>动态运行时加载，程序被加载到内存中，对内存的访问也是相对地址形式的，只有实际访存时，才会计算真实地址。（为了效率使用硬件实现）</p>
<blockquote>
<p>内存涉及到换入换出，如果换入到不同的地址，可重定位加载也不可用。</p>
</blockquote>
</li>
</ul>
<img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241107225002300.png" class title="image-20241107225002300">

<p>如上表，链接可以在产生加载模块时链接，也可以在往内存加载模块时链接，也可以在运行时链接。</p>
<p>链接编辑程序是负责产生可重定位加载模块的链接器。对于可重定位的加载模块，通常会创建每个目标模块相对于总的目标模块开始处的引用，</p>
<img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241107225849368.png" class title="image-20241107225849368">

<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><h4 id="硬件和控制结构"><a href="#硬件和控制结构" class="headerlink" title="硬件和控制结构"></a>硬件和控制结构</h4><p>进程要访问的地址不在内存时，处理器会产生缺页中断，系统会把进程置为阻塞态，然后将对应的内存块读入内存。</p>
<h5 id="分页-1"><a href="#分页-1" class="headerlink" title="分页"></a>分页</h5><p>每个进程有个页表，页表项包含有与<strong>物理内存中的页框</strong>所相应的页框号，以及一些控制位，P代表该页是否在内存中，M代表有没有修改该页内存。</p>
<img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241111145015863.png" class title="image-20241111145015863">

<p><strong>虚拟地址 &#x3D; 页号 + 偏移量</strong></p>
<p><strong>物理地址 &#x3D; 页框号 + 偏移量</strong></p>
<img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241111145200765.png" class title="image-20241111145200765">

<p>虚存有多少页，就要考虑如何存储这么多个页表项。</p>
<ul>
<li><p>大多数页表也是放到虚存而不是直接放到物理内存的，这可以避免将所有页表项加载到内存中。</p>
</li>
<li><p>使用两级方案，</p>
<img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241111150109586.png" class title="image-20241111150109586"></li>
</ul>
<p><strong>TLB表</strong>：</p>
<blockquote>
<p>TLB高速缓存：存放TLB表的高速缓存</p>
<p>内存高速缓存：Cache</p>
<p>磁盘高速缓存：内存上的一块区域，用来从&#x2F;向磁盘读写数据</p>
</blockquote>
<img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241111152438292.png" class title="image-20241111152438292">

<p>通过上文的图片得到物理地址后，然后在内存高速缓存查找是否有包含这个字的块，有则返回给CPU；没有则从内存中检索这个字（这又涉及到该字在不在内存的问题）整体流程如下图所示：</p>
<img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241111152854147.png" class title="image-20241111152854147">

<p>虚拟地址转换为物理地址时，需要访问页表项，这个页表项可能位于<strong>TLB、内存、磁盘中，</strong>要访问的字可能位于<strong>高速缓存、内存或磁盘</strong>中。</p>
<blockquote>
<p>一次访存可能产生两次缺页中断，也i沉思页表，一次是进程页</p>
</blockquote>
<h5 id="段页式"><a href="#段页式" class="headerlink" title="段页式"></a>段页式</h5><h4 id="操作系统软件"><a href="#操作系统软件" class="headerlink" title="操作系统软件"></a>操作系统软件</h4><p>操作系统的内存管理取决于三个基本的选择：</p>
<ul>
<li>是否使用虚存技术</li>
<li>是使用分页还是分段，或者都要</li>
<li>为各种存储管理特征采用的算法</li>
</ul>
<img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241111155315350.png" class title="image-20241111155315350">

<h5 id="读取策略"><a href="#读取策略" class="headerlink" title="读取策略"></a>读取策略</h5><ul>
<li>请求分页，请求到某个单元才将其读入内存，程序启动时会有大量的缺页中断</li>
<li>预先分页，一次读取多个页，即使某些页当前没有被用到，程序首次启动时可以使用这种方式。</li>
</ul>
<h5 id="放置策略"><a href="#放置策略" class="headerlink" title="放置策略"></a>放置策略</h5><p>通常无关紧要</p>
<h5 id="置换策略"><a href="#置换策略" class="headerlink" title="置换策略"></a>置换策略</h5><ul>
<li>最佳，由于需要预知未来的事件，不可能实现。</li>
<li>最近最少使用</li>
<li>先进先出</li>
<li>时钟</li>
</ul>
<h5 id="驻留集管理"><a href="#驻留集管理" class="headerlink" title="驻留集管理"></a>驻留集管理</h5><p>固定大小？全局&#x2F;局部置换？</p>
<h5 id="清除策略"><a href="#清除策略" class="headerlink" title="清除策略"></a>清除策略</h5><h5 id="加载控制"><a href="#加载控制" class="headerlink" title="加载控制"></a>加载控制</h5><p>控制驻留内存的进程数量，</p>
<img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241112171632705.png" class title="image-20241112171632705">

<h4 id="Linux内存管理"><a href="#Linux内存管理" class="headerlink" title="Linux内存管理"></a>Linux内存管理</h4><p>LInux内存管理的两个主要特征：<strong>进程虚拟内存和内核内存分配</strong>。</p>
<h5 id="虚拟内存-1"><a href="#虚拟内存-1" class="headerlink" title="虚拟内存"></a>虚拟内存</h5><p>Linux使用三级页表，三类表如下所示：</p>
<ul>
<li>页目录，最顶层的表，每个进程有一个，活动进程的页目录必须在内存中</li>
<li>页中间目录，每项指向一个页表</li>
<li>页表，每项指向一个虚拟页</li>
</ul>
<img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241112172614870.png" class title="image-20241112172614870">

<p><strong>页面分配</strong>：使用伙伴系统，来一次将多个连续的页映射到连续的页框中，提升效率。</p>
<p><strong>页面置换算法</strong>：</p>
<ul>
<li><p>LInux2.6.28之前，使修改的时钟算法，缺点是周期扫描缓存，造成额外开销。</p>
</li>
<li><p>之后，使用新的分割LRU算法，每个页表有PG_active和PG_referneced两个新的有效位，（之前的访问标志也应该存在）。</p>
<p>PG_active&#x3D;1代表短时间内访问了两次；PG_referneced&#x3D;1代表最近访问了一次，如果短时间内再被访问了一次，系统会将该页PG_active设为1。PG_active&#x3D;0的页面可能被一个LRU类型的算法置换。差不多是这样吧。</p>
<img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241112174155081.png" class title="image-20241112174155081"></li>
</ul>
<h5 id="内核内存分配"><a href="#内核内存分配" class="headerlink" title="内核内存分配"></a>内核内存分配</h5><img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241112174636110.png" class title="image-20241112174636110">

<blockquote>
<p>内核内存也是通过虚存分配的吗，还一直以为是直接映射的</p>
</blockquote>
<h3 id="单处理器调度"><a href="#单处理器调度" class="headerlink" title="单处理器调度"></a>单处理器调度</h3><ul>
<li>高级调度（长程调度），决定将那些作业调入内存并转化为进程</li>
<li>中级调度（中程调度），决定将那么进程从内存移出</li>
<li>低级调度（短程调度），处理器执行哪个进程</li>
</ul>
<h4 id="处理器调度的类型"><a href="#处理器调度的类型" class="headerlink" title="处理器调度的类型"></a>处理器调度的类型</h4><h4 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h4><ul>
<li>面向用户，比如交互式系统响应时间</li>
<li>面向系统，如何提高系统的利用率</li>
</ul>
<p>具体分类太多了，略</p>
<h5 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h5><p>假设是排队论，泊松到达率以及指数服务时间</p>
<h5 id="公平共享调度"><a href="#公平共享调度" class="headerlink" title="公平共享调度"></a>公平共享调度</h5><p>在多用户系统中，一组进程如何执行。</p>
<h3 id="多处理器、多核和实时调度"><a href="#多处理器、多核和实时调度" class="headerlink" title="多处理器、多核和实时调度"></a>多处理器、多核和实时调度</h3><h4 id="多处理器和多核调度"><a href="#多处理器和多核调度" class="headerlink" title="多处理器和多核调度"></a>多处理器和多核调度</h4><h5 id="粒度（同步的频率，粒度越小，同步越频繁，数据的一致性和实时性越高）"><a href="#粒度（同步的频率，粒度越小，同步越频繁，数据的一致性和实时性越高）" class="headerlink" title="粒度（同步的频率，粒度越小，同步越频繁，数据的一致性和实时性越高）"></a>粒度（同步的频率，粒度越小，同步越频繁，数据的一致性和实时性越高）</h5><p>既然是多核、多处理器，就要考虑同步问题，把进程间的同步粒度分为这些等级：</p>
<img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241112202531007.png" class title="image-20241112202531007">

<ul>
<li>粗和极粗，基本不用改动程序</li>
<li>中等，需由程序员显示指定潜在的并行性</li>
<li>细粒度，</li>
</ul>
<h5 id="设计问题"><a href="#设计问题" class="headerlink" title="设计问题"></a>设计问题</h5><p>多处理器中的调度设计三个问题</p>
<ul>
<li>把进程分配到处理器，分为静态分配（每个任务只分配给一个处理器）和动态分配（所有进程放到一个公共队列中，然后分给各处理器，Linux也是这种策略）。操作系统内核可以只运行在一个内核上（会出现性能瓶颈）也可以像普通进程一样随机分配到处理器。</li>
<li>在单处理器上使用多道程序设计</li>
<li>一个进程的实际分派</li>
</ul>
<p>所用的方法取决于应用程序的粒度级以及可用处理器的数量。</p>
<h5 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h5><p>多处理器情况下，调度算法之间的差别很小，很多算法并不比FCFS优秀太多，选择FCFS就行了。（应该是核太多了，让每个进程都能及时接受服务）</p>
<img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241112210651259.png" class title="image-20241112210651259">

<blockquote>
<p>横坐标可以看成平均服务时间的离散程度</p>
</blockquote>
<h5 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h5><p>在<strong>多处理器</strong>系统中，线程可开发应用程序中的真正并行性。一个应用程序在不同的处理器中运行，其性能会显著提升。几种线程调度方案：</p>
<ul>
<li><p>负载分配，维护一个全局队列。虽然有很多劣势，还实际还是用的挺多的。</p>
<ul>
<li>优势：简单，负载均匀的分布在处理器上</li>
<li>劣势：<ul>
<li>全局队列可能被多个处理器查找，造成性能瓶颈</li>
<li>一个进程的多个线程没法在同一个处理器运行</li>
</ul>
</li>
</ul>
</li>
<li><p>组调度，专业术语，已经用来表示同时调度组成一个进程的一组线程。对与<strong>中粒度到细粒度</strong>的应用程序，组调度非常重要（同组的多个线程之间有紧闭的合作&#x2F;同步关系，如果一个线程执行，而其他的不执行会严重的降低性能）。</p>
</li>
<li><p>专用处理器分配， 把一组处理器分配给一个应用程序（包括很多线程），直到应用程序结束。（当线程数大于处理器数目时，加速比会降低）</p>
<img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241112220757154.png" class title="image-20241112220757154"></li>
</ul>
<h5 id="多核线程调度"><a href="#多核线程调度" class="headerlink" title="多核线程调度"></a>多核线程调度</h5><p>随着内核数量越来越多，最小化访问片外存储器比最大化处理器利用率越优先。（不要为了利用率安排内存资源毫不相关的线程运行，以免影响cache命中率）</p>
<img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241112210113344.png" class title="image-20241112210113344">

<h4 id="实时调度"><a href="#实时调度" class="headerlink" title="实时调度"></a>实时调度</h4><h5 id="实时操作系统的特点"><a href="#实时操作系统的特点" class="headerlink" title="实时操作系统的特点"></a>实时操作系统的特点</h5><ul>
<li>可确定性，</li>
<li>可响应性</li>
<li>用户控制</li>
<li>可靠性</li>
<li>故障弱化操作</li>
</ul>
<h4 id="Linux调度"><a href="#Linux调度" class="headerlink" title="Linux调度"></a>Linux调度</h4><h5 id="实时调度-1"><a href="#实时调度-1" class="headerlink" title="实时调度"></a>实时调度</h5><img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241113102928660.png" class title="image-20241113102928660">

<img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241113102936661.png" class title="image-20241113102936661">

<h5 id="非实时调度"><a href="#非实时调度" class="headerlink" title="非实时调度"></a>非实时调度</h5><p>随着中央处理器的增加，Linux2.4对于SCHED_NORMAL类的调度程序表现的不好：</p>
<ul>
<li>所有处理器都只有一个队列，不利于高速缓存</li>
<li>一个处理器选择任务时，其他处理器只能围观</li>
<li>任务不可抢占。</li>
</ul>
<p>新的<strong>完全公平调度器（CFS）</strong></p>
<p>为每个任务维护一个虚拟运行时间，时间越短，代表他对处理器的需求越强。</p>
<p>CFS调度器基于红黑树实现，</p>
<img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241113104026871.png" class title="image-20241113104026871">

<h3 id="I-x2F-O管理和磁盘调度"><a href="#I-x2F-O管理和磁盘调度" class="headerlink" title="I&#x2F;O管理和磁盘调度"></a>I&#x2F;O管理和磁盘调度</h3><h4 id="I-x2F-O功能的组织"><a href="#I-x2F-O功能的组织" class="headerlink" title="I&#x2F;O功能的组织"></a>I&#x2F;O功能的组织</h4><p>三种I&#x2F;O技术：</p>
<ul>
<li>程序控制I&#x2F;O，发出I&#x2F;O命令后，一直等到设备准备好数据才执行</li>
<li>中断驱动I&#x2F;O，发出I&#x2F;O命令后，设备开始准备数据，处理器在这期间仍然可以执行其他命令<ul>
<li>如果该I&#x2F;O是阻塞的，则将进程阻塞并调度其他程序</li>
<li>如果该I&#x2F;O是非阻塞的，则继续执行该I&#x2F;O的后续命令。（I&#x2F;O是阻塞的意味着当前的I&#x2F;O命令很重要，必须先于后面的命令执行）</li>
</ul>
</li>
<li>直接内存访问，由DMA控制和I&#x2F;O模块的交换，在设备准备好数据、DMA传输完数据，才会给处理器发中断。</li>
</ul>
<h5 id="直接内存访问"><a href="#直接内存访问" class="headerlink" title="直接内存访问"></a>直接内存访问</h5><h4 id="操作系统设计问题"><a href="#操作系统设计问题" class="headerlink" title="操作系统设计问题"></a>操作系统设计问题</h4><p>设计目标</p>
<ul>
<li>效率</li>
<li>通用（隐藏设备特征）</li>
</ul>
<h5 id="I-x2F-O功能的逻辑结构"><a href="#I-x2F-O功能的逻辑结构" class="headerlink" title="I&#x2F;O功能的逻辑结构"></a>I&#x2F;O功能的逻辑结构</h5><img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241113111433458.png" class title="image-20241113111433458">

<ul>
<li><p>a，逻辑外部设备</p>
<ul>
<li>逻辑I&#x2F;O，打开、关闭、读写之类的命令（所有I&#x2F;O应该都差不多）</li>
<li>设备I&#x2F;O，请求的操作和数据被转换为设备对应的指令序列</li>
<li>调度和控制，I&#x2F;O的排队、调度都在这一层，（应该是直接给设备发数据命令的那一层吧）</li>
</ul>
</li>
<li><p>b，通信端口，与a的区别是，把逻辑I&#x2F;O变成了通信架构，通信架构由很多层构成，如TCP&#x2F;IP。</p>
</li>
<li><p>c，文件系统</p>
<ul>
<li>目录管理，将文件名变成标识符，通过标识符访问文件</li>
<li>文件系统，处理文件的逻辑结构，处理用户的操作如打开，读写。</li>
<li>物理组织，将对文件的逻辑访问变成实际的外村地址。</li>
</ul>
</li>
</ul>
<h4 id="I-x2F-O缓冲"><a href="#I-x2F-O缓冲" class="headerlink" title="I&#x2F;O缓冲"></a>I&#x2F;O缓冲</h4><p>执行I&#x2F;O指令直接将磁盘数据加载到内存的虚拟地址空间。缺点：</p>
<ul>
<li>对应的虚拟地址单元必须保留在内存中，如果是分页，则将对应的页面锁定。</li>
</ul>
<h5 id="单缓冲"><a href="#单缓冲" class="headerlink" title="单缓冲"></a>单缓冲</h5><p>对于面向流的缓冲，</p>
<ul>
<li>每次传输一行，用缓冲区保存一行数据，输入期间用户进程被挂起</li>
<li>每次传输一个字节，按照生产者消费者模型进行</li>
</ul>
<img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241113125004007.png" class title="image-20241113125004007">

<blockquote>
<p>如果CPU直接与IO交互，CPU的速率受限于IO，如果使用缓冲区，则可以等到缓冲区装满时再通知CPU一起处理。</p>
</blockquote>
<h4 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a>磁盘调度</h4><h5 id="磁盘性能参数"><a href="#磁盘性能参数" class="headerlink" title="磁盘性能参数"></a>磁盘性能参数</h5><p><strong>寻道时间</strong>：磁头定位到磁道的时间</p>
<p><strong>旋转延迟</strong>：找到磁道后，磁头到达扇区开始位置的时间为旋转延迟</p>
<p>存取时间：寻道时间+选择延迟</p>
<p>一个文件存放相邻的扇区会降低存取时间。</p>
<h5 id="磁盘调度策略"><a href="#磁盘调度策略" class="headerlink" title="磁盘调度策略"></a>磁盘调度策略</h5><p>SCAN（仅沿一个方向扫描），C-SCAN（访问磁道到顶后，在反向扫描）</p>
<h4 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h4><p>独立磁盘冗余阵列，用多个小容量磁盘代替大容量磁盘。由于有多个磁头，可以达到<strong>更高的I&#x2F;O速度</strong>，但多个设备也增大了失效的概率，所以使用奇偶校验来恢复数据。</p>
<img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241113150124960.png" class title="image-20241113150124960">

<img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241113150326719.png" class title="image-20241113150326719">

<p>常用 0，1，5，6</p>
<h5 id="RAID-0"><a href="#RAID-0" class="headerlink" title="RAID 0"></a>RAID 0</h5><p>很多超级计算机也使用这种方案，因为成本比可靠性重要。</p>
<p>磁盘依次存储到RAID0的每个条带中，如果I&#x2F;O请求有多个连续的条带组成，则该请求可以并行处理。</p>
<h4 id="Linux-I-x2F-O"><a href="#Linux-I-x2F-O" class="headerlink" title="Linux I&#x2F;O"></a>Linux I&#x2F;O</h4><h5 id="磁盘调度-1"><a href="#磁盘调度-1" class="headerlink" title="磁盘调度"></a>磁盘调度</h5><p>电梯调度有些问题，比如20，30，700， 25，如果一直有低块号请求，则700的会被延后。</p>
<p>读请求和写请求是不同的，写请求是异步的</p>
<ul>
<li>写请求把数据复制到缓冲区，应用程序就可以继续运行</li>
<li>读请求会要求进程等待，直到磁盘将数据发给应用程序。</li>
</ul>
<p><strong>最后期限调度程序</strong></p>
<p>维护一个排序的电梯队列和一个FIFO的队列，（读请求和写请求又分成了两个队列）</p>
<ul>
<li>当电梯队列的请求被服务时，会从两个队列同时移除该请求。</li>
<li>当FIFO的头部的请求超过到期时间时，会先从该FIFO队列获取任务，也会从两个队列同时移除该任务。</li>
</ul>
<img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241113154908860.png" class title="image-20241113154908860">

<p><strong>预期I&#x2F;O调度程序</strong></p>
<p>是对最后期限调度程序的补充，分配一个读请求时，调度程序会将调度系统的执行延迟6ms，这段时间内，如果该进程又发了一个相邻区域的读请求，则会立刻接受服务，否则继续使用最后期限调度程序。</p>
<p><strong>完全公平I&#x2F;O调度</strong></p>
<img src="/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/image-20241113155400050.png" class title="image-20241113155400050">

<h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><p>要不直接去看Linux内核</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://tjzhang-src.github.io/.github.io">John Doe</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://tjzhang-src.github.io/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/">https://tjzhang-src.github.io/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://tjzhang-src.github.io/.github.io" target="_blank">Welcome</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/.github.io/tags/os/">os</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/.github.io/2024/10/22/linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/" title="linux内核设计与实现"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">linux内核设计与实现</div></div></a></div><div class="next-post pull-right"><a href="/.github.io/2024/10/17/leetcode%E9%94%99%E9%A2%98/" title="leetcode错题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">leetcode错题</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Waline</span><span class="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/.github.io/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">John Doe</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/.github.io/archives/"><div class="headline">文章</div><div class="length-num">43</div></a><a href="/.github.io/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/.github.io/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/tjzhang-src"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E7%9A%84%E6%89%A7%E8%A1%8C"><span class="toc-number">1.1.</span> <span class="toc-text">指令的执行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD"><span class="toc-number">1.2.</span> <span class="toc-text">中断</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%92%8C%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F"><span class="toc-number">1.2.1.</span> <span class="toc-text">中断和指令周期</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86"><span class="toc-number">1.2.2.</span> <span class="toc-text">中断处理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E4%B8%AD%E6%96%AD"><span class="toc-number">1.2.3.</span> <span class="toc-text">多个中断</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.</span> <span class="toc-text">存储器的层次结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98"><span class="toc-number">1.4.</span> <span class="toc-text">高速缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">1.4.1.</span> <span class="toc-text">原理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E5%AD%98%E5%8F%96"><span class="toc-number">1.5.</span> <span class="toc-text">直接内存存取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E5%92%8C%E5%A4%9A%E6%A0%B8%E8%AE%A1%E7%AE%97%E6%9C%BA"><span class="toc-number">1.6.</span> <span class="toc-text">多处理器和多核计算机</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8-SMP"><span class="toc-number">1.6.1.</span> <span class="toc-text">对称多处理器(SMP)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E6%A0%B8%E8%AE%A1%E7%AE%97%E6%9C%BA"><span class="toc-number">1.6.2.</span> <span class="toc-text">多核计算机</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0"><span class="toc-number">2.</span> <span class="toc-text">操作系统概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87%E4%B8%8E%E5%8A%9F%E8%83%BD"><span class="toc-number">2.1.</span> <span class="toc-text">目标与功能</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%9C%E4%B8%BA%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">2.1.1.</span> <span class="toc-text">作为接口的操作系统</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%9C%E4%B8%BA%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%99%A8%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">2.1.2.</span> <span class="toc-text">作为资源管理器的操作系统</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%BC%94%E5%8C%96"><span class="toc-number">2.2.</span> <span class="toc-text">操作系统的演化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E6%88%90%E5%B0%B1"><span class="toc-number">2.3.</span> <span class="toc-text">主要成就</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.3.1.</span> <span class="toc-text">进程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">2.3.2.</span> <span class="toc-text">内存管理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%A0%B8%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E8%80%83%E8%99%91%E5%9B%A0%E7%B4%A0"><span class="toc-number">2.4.</span> <span class="toc-text">多核操作系统设计考虑因素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">2.5.</span> <span class="toc-text">其他</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E4%B8%8E%E6%8E%A7%E5%88%B6"><span class="toc-number">3.</span> <span class="toc-text">进程描述与控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E7%A8%8B"><span class="toc-number">3.1.</span> <span class="toc-text">什么是进程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A2%AB%E6%8C%82%E8%B5%B7%E7%9A%84%E8%BF%9B%E7%A8%8B"><span class="toc-number">3.1.1.</span> <span class="toc-text">被挂起的进程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0"><span class="toc-number">3.2.</span> <span class="toc-text">进程描述</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84"><span class="toc-number">3.2.1.</span> <span class="toc-text">操作系统的控制结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84"><span class="toc-number">3.2.2.</span> <span class="toc-text">进程控制结构</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">3.3.</span> <span class="toc-text">进程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%8E%A7%E5%88%B6"><span class="toc-number">3.3.1.</span> <span class="toc-text">执行控制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="toc-number">3.3.2.</span> <span class="toc-text">进程创建</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2"><span class="toc-number">3.3.3.</span> <span class="toc-text">进程切换</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%89%A7%E8%A1%8C"><span class="toc-number">3.4.</span> <span class="toc-text">操作系统的执行</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%A0%E5%86%85%E6%A0%B8%E8%BF%9B%E7%A8%8B"><span class="toc-number">3.4.1.</span> <span class="toc-text">无内核进程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%A8%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B%E5%86%85%E8%BF%90%E8%A1%8C"><span class="toc-number">3.4.2.</span> <span class="toc-text">在用户进程内运行</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.4.3.</span> <span class="toc-text">基于进程的操作系统</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.1.</span> <span class="toc-text">进程与线程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.1.1.</span> <span class="toc-text">多线程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">4.1.2.</span> <span class="toc-text">线程的功能</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%88%86%E7%B1%BB"><span class="toc-number">4.2.</span> <span class="toc-text">线程分类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%BA%A7%E5%92%8C%E5%86%85%E6%A0%B8%E7%BA%A7%E7%BA%BF%E7%A8%8B%EF%BC%88ULT-amp-KLT%EF%BC%89%E5%90%8E%E8%80%85%E5%8F%88%E7%A7%B0%E4%B8%BA%E8%BD%BB%E9%87%8F%E7%BA%A7%E8%BF%9B%E7%A8%8B"><span class="toc-number">4.2.1.</span> <span class="toc-text">用户级和内核级线程（ULT &amp; KLT）后者又称为轻量级进程</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%BA%A7%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.2.1.1.</span> <span class="toc-text">用户级线程</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E7%BA%A7%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.2.1.2.</span> <span class="toc-text">内核级线程</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.1.3.</span> <span class="toc-text">混合方法</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%96%B9%E6%A1%88"><span class="toc-number">4.2.2.</span> <span class="toc-text">其他方案</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%A0%B8%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.3.</span> <span class="toc-text">多核与多线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Windows%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">4.4.</span> <span class="toc-text">Windows的进程和线程管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Linux%E7%9A%84%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">4.5.</span> <span class="toc-text">Linux的进程与线程管理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Linux%E4%BB%BB%E5%8A%A1"><span class="toc-number">4.5.1.</span> <span class="toc-text">Linux任务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Linux%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.5.2.</span> <span class="toc-text">Linux线程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Linux%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">4.5.3.</span> <span class="toc-text">Linux命名空间</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%EF%BC%9A%E4%BA%92%E6%96%A5%E5%92%8C%E5%90%8C%E6%AD%A5"><span class="toc-number">5.</span> <span class="toc-text">并发：互斥和同步</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%EF%BC%9A%E8%BD%AF%E4%BB%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-number">5.1.</span> <span class="toc-text">互斥：软件解决方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Dekker%E7%AE%97%E6%B3%95"><span class="toc-number">5.1.1.</span> <span class="toc-text">Dekker算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Perterson%E7%AE%97%E6%B3%95"><span class="toc-number">5.1.2.</span> <span class="toc-text">Perterson算法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">5.2.</span> <span class="toc-text">并发的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B9%B6%E5%8F%91%E5%B8%A6%E6%9D%A5%E6%96%B0%E7%9A%84%E7%AE%A1%E7%90%86%E9%97%AE%E9%A2%98"><span class="toc-number">5.2.1.</span> <span class="toc-text">操作系统并发带来新的管理问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BA%A4%E4%BA%92"><span class="toc-number">5.2.2.</span> <span class="toc-text">进程的交互</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E7%9A%84%E8%A6%81%E6%B1%82"><span class="toc-number">5.2.3.</span> <span class="toc-text">互斥的要求</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%9A%84%E6%94%AF%E6%8C%81"><span class="toc-number">5.3.</span> <span class="toc-text">互斥：硬件的支持</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%A6%81%E7%94%A8"><span class="toc-number">5.3.1.</span> <span class="toc-text">中断禁用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%93%E7%94%A8%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4"><span class="toc-number">5.3.2.</span> <span class="toc-text">专用机器指令</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">5.4.</span> <span class="toc-text">信号量</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%92%E6%96%A5"><span class="toc-number">5.4.1.</span> <span class="toc-text">互斥</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E7%94%9F%E4%BA%A7%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">5.4.2.</span> <span class="toc-text">消费者生产者问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.4.3.</span> <span class="toc-text">信号量的实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E7%A8%8B"><span class="toc-number">5.5.</span> <span class="toc-text">管程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BF%A1%E5%8F%B7%E7%9A%84%E7%AE%A1%E7%A8%8B"><span class="toc-number">5.5.1.</span> <span class="toc-text">使用信号的管程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%80%9A%E7%9F%A5%E5%92%8C%E5%B9%BF%E6%92%AD%E7%9A%84%E7%AE%A1%E7%A8%8B"><span class="toc-number">5.5.2.</span> <span class="toc-text">使用通知和广播的管程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92"><span class="toc-number">5.6.</span> <span class="toc-text">消息传递</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5"><span class="toc-number">5.6.1.</span> <span class="toc-text">同步</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%BB%E5%9D%80"><span class="toc-number">5.6.2.</span> <span class="toc-text">寻址</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%92%E6%96%A5-1"><span class="toc-number">5.6.3.</span> <span class="toc-text">互斥</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E8%80%85%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">5.7.</span> <span class="toc-text">读者写者问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%BB%E8%80%85%E4%BC%98%E5%85%88"><span class="toc-number">5.7.1.</span> <span class="toc-text">读者优先</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%EF%BC%9A%E9%A5%A5%E9%A5%BF%E5%92%8C%E6%AD%BB%E9%94%81"><span class="toc-number">6.</span> <span class="toc-text">并发：饥饿和死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E5%8E%9F%E7%90%86"><span class="toc-number">6.1.</span> <span class="toc-text">死锁原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E7%94%A8%E8%B5%84%E6%BA%90"><span class="toc-number">6.1.1.</span> <span class="toc-text">可重用资源</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E6%B6%88%E8%80%97%E8%B5%84%E6%BA%90"><span class="toc-number">6.1.2.</span> <span class="toc-text">可消耗资源</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="toc-number">6.1.3.</span> <span class="toc-text">死锁的必要条件</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E9%A2%84%E9%98%B2"><span class="toc-number">6.2.</span> <span class="toc-text">死锁预防</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E9%81%BF%E5%85%8D"><span class="toc-number">6.3.</span> <span class="toc-text">死锁避免</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B"><span class="toc-number">6.4.</span> <span class="toc-text">死锁检测</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95"><span class="toc-number">6.4.1.</span> <span class="toc-text">死锁检测算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%81%A2%E5%A4%8D"><span class="toc-number">6.4.2.</span> <span class="toc-text">恢复</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E7%A7%8D%E7%BB%BC%E5%90%88%E7%9A%84%E6%AD%BB%E9%94%81%E7%AD%96%E7%95%A5"><span class="toc-number">6.5.</span> <span class="toc-text">一种综合的死锁策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98"><span class="toc-number">6.6.</span> <span class="toc-text">哲学家就餐问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">6.6.1.</span> <span class="toc-text">基于信号量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%AE%A1%E7%A8%8B"><span class="toc-number">6.6.2.</span> <span class="toc-text">基于管程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UNIX%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6"><span class="toc-number">6.7.</span> <span class="toc-text">UNIX并发机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Linux%E5%86%85%E6%A0%B8%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6"><span class="toc-number">6.8.</span> <span class="toc-text">Linux内核并发机制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="toc-number">6.8.1.</span> <span class="toc-text">原子操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-number">6.8.2.</span> <span class="toc-text">自旋锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F-1"><span class="toc-number">6.8.3.</span> <span class="toc-text">信号量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B1%8F%E9%9A%9C"><span class="toc-number">6.8.4.</span> <span class="toc-text">屏障</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-1"><span class="toc-number">7.</span> <span class="toc-text">内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E9%9C%80%E6%B1%82"><span class="toc-number">7.1.</span> <span class="toc-text">内存管理的需求</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8D%E5%AE%9A%E4%BD%8D"><span class="toc-number">7.1.1.</span> <span class="toc-text">重定位</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%9D%E6%8A%A4"><span class="toc-number">7.1.2.</span> <span class="toc-text">保护</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA"><span class="toc-number">7.2.</span> <span class="toc-text">内存分区</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%8D%E5%87%A0%E7%A7%8D%E5%88%86%E5%8C%BA"><span class="toc-number">7.2.1.</span> <span class="toc-text">前几种分区</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8D%E5%AE%9A%E4%BD%8D-1"><span class="toc-number">7.2.2.</span> <span class="toc-text">重定位</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%A1%B5"><span class="toc-number">8.</span> <span class="toc-text">分页</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%AE%B5"><span class="toc-number">9.</span> <span class="toc-text">分段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E4%B8%8E%E9%93%BE%E6%8E%A5"><span class="toc-number">10.</span> <span class="toc-text">加载与链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="toc-number">11.</span> <span class="toc-text">虚拟内存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E5%92%8C%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84"><span class="toc-number">11.1.</span> <span class="toc-text">硬件和控制结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E9%A1%B5-1"><span class="toc-number">11.1.1.</span> <span class="toc-text">分页</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AE%B5%E9%A1%B5%E5%BC%8F"><span class="toc-number">11.1.2.</span> <span class="toc-text">段页式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6"><span class="toc-number">11.2.</span> <span class="toc-text">操作系统软件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E7%AD%96%E7%95%A5"><span class="toc-number">11.2.1.</span> <span class="toc-text">读取策略</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%94%BE%E7%BD%AE%E7%AD%96%E7%95%A5"><span class="toc-number">11.2.2.</span> <span class="toc-text">放置策略</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BD%AE%E6%8D%A2%E7%AD%96%E7%95%A5"><span class="toc-number">11.2.3.</span> <span class="toc-text">置换策略</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A9%BB%E7%95%99%E9%9B%86%E7%AE%A1%E7%90%86"><span class="toc-number">11.2.4.</span> <span class="toc-text">驻留集管理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B8%85%E9%99%A4%E7%AD%96%E7%95%A5"><span class="toc-number">11.2.5.</span> <span class="toc-text">清除策略</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E6%8E%A7%E5%88%B6"><span class="toc-number">11.2.6.</span> <span class="toc-text">加载控制</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">11.3.</span> <span class="toc-text">Linux内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98-1"><span class="toc-number">11.3.1.</span> <span class="toc-text">虚拟内存</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">11.3.2.</span> <span class="toc-text">内核内存分配</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E5%A4%84%E7%90%86%E5%99%A8%E8%B0%83%E5%BA%A6"><span class="toc-number">12.</span> <span class="toc-text">单处理器调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%99%A8%E8%B0%83%E5%BA%A6%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">12.1.</span> <span class="toc-text">处理器调度的类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">12.2.</span> <span class="toc-text">调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83"><span class="toc-number">12.2.1.</span> <span class="toc-text">性能比较</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E5%85%B1%E4%BA%AB%E8%B0%83%E5%BA%A6"><span class="toc-number">12.2.2.</span> <span class="toc-text">公平共享调度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E3%80%81%E5%A4%9A%E6%A0%B8%E5%92%8C%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6"><span class="toc-number">13.</span> <span class="toc-text">多处理器、多核和实时调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E5%92%8C%E5%A4%9A%E6%A0%B8%E8%B0%83%E5%BA%A6"><span class="toc-number">13.1.</span> <span class="toc-text">多处理器和多核调度</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B2%92%E5%BA%A6%EF%BC%88%E5%90%8C%E6%AD%A5%E7%9A%84%E9%A2%91%E7%8E%87%EF%BC%8C%E7%B2%92%E5%BA%A6%E8%B6%8A%E5%B0%8F%EF%BC%8C%E5%90%8C%E6%AD%A5%E8%B6%8A%E9%A2%91%E7%B9%81%EF%BC%8C%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E5%92%8C%E5%AE%9E%E6%97%B6%E6%80%A7%E8%B6%8A%E9%AB%98%EF%BC%89"><span class="toc-number">13.1.1.</span> <span class="toc-text">粒度（同步的频率，粒度越小，同步越频繁，数据的一致性和实时性越高）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E9%97%AE%E9%A2%98"><span class="toc-number">13.1.2.</span> <span class="toc-text">设计问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-number">13.1.3.</span> <span class="toc-text">进程调度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-number">13.1.4.</span> <span class="toc-text">线程调度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E6%A0%B8%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-number">13.1.5.</span> <span class="toc-text">多核线程调度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6"><span class="toc-number">13.2.</span> <span class="toc-text">实时调度</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">13.2.1.</span> <span class="toc-text">实时操作系统的特点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Linux%E8%B0%83%E5%BA%A6"><span class="toc-number">13.3.</span> <span class="toc-text">Linux调度</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6-1"><span class="toc-number">13.3.1.</span> <span class="toc-text">实时调度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%9E%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6"><span class="toc-number">13.3.2.</span> <span class="toc-text">非实时调度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-x2F-O%E7%AE%A1%E7%90%86%E5%92%8C%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6"><span class="toc-number">14.</span> <span class="toc-text">I&#x2F;O管理和磁盘调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#I-x2F-O%E5%8A%9F%E8%83%BD%E7%9A%84%E7%BB%84%E7%BB%87"><span class="toc-number">14.1.</span> <span class="toc-text">I&#x2F;O功能的组织</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE"><span class="toc-number">14.1.1.</span> <span class="toc-text">直接内存访问</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E9%97%AE%E9%A2%98"><span class="toc-number">14.2.</span> <span class="toc-text">操作系统设计问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#I-x2F-O%E5%8A%9F%E8%83%BD%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="toc-number">14.2.1.</span> <span class="toc-text">I&#x2F;O功能的逻辑结构</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#I-x2F-O%E7%BC%93%E5%86%B2"><span class="toc-number">14.3.</span> <span class="toc-text">I&#x2F;O缓冲</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E7%BC%93%E5%86%B2"><span class="toc-number">14.3.1.</span> <span class="toc-text">单缓冲</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6"><span class="toc-number">14.4.</span> <span class="toc-text">磁盘调度</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E6%80%A7%E8%83%BD%E5%8F%82%E6%95%B0"><span class="toc-number">14.4.1.</span> <span class="toc-text">磁盘性能参数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5"><span class="toc-number">14.4.2.</span> <span class="toc-text">磁盘调度策略</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RAID"><span class="toc-number">14.5.</span> <span class="toc-text">RAID</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#RAID-0"><span class="toc-number">14.5.1.</span> <span class="toc-text">RAID 0</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Linux-I-x2F-O"><span class="toc-number">14.6.</span> <span class="toc-text">Linux I&#x2F;O</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6-1"><span class="toc-number">14.6.1.</span> <span class="toc-text">磁盘调度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="toc-number">15.</span> <span class="toc-text">文件管理</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/.github.io/2024/12/04/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/" title="Linux高性能服务器编程">Linux高性能服务器编程</a><time datetime="2024-12-04T09:01:31.000Z" title="发表于 2024-12-04 17:01:31">2024-12-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/.github.io/2024/12/03/%E5%9B%BE%E8%A7%A3HTTP/" title="图解HTTP">图解HTTP</a><time datetime="2024-12-03T03:35:49.000Z" title="发表于 2024-12-03 11:35:49">2024-12-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/.github.io/2024/11/28/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/" title="自顶向下方法">自顶向下方法</a><time datetime="2024-11-28T12:05:16.000Z" title="发表于 2024-11-28 20:05:16">2024-11-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/.github.io/2024/11/12/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/" title="程序员的自我修养-第十一章">程序员的自我修养-第十一章</a><time datetime="2024-11-12T08:29:32.000Z" title="发表于 2024-11-12 16:29:32">2024-11-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/.github.io/2024/11/12/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-%E7%AC%AC%E5%8D%81%E7%AB%A0/" title="程序员的自我修养-第十章">程序员的自我修养-第十章</a><time datetime="2024-11-12T03:08:23.000Z" title="发表于 2024-11-12 11:08:23">2024-11-12</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://s2.loli.net/2023/02/26/9fQnztK2ImqyLwS.webp')"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By John Doe</div><div class="footer_custom_text">Hi, welcome to my <a href="https://tjzhang-src.github.io/.github.io/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/.github.io/js/utils.js"></script><script src="/.github.io/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>function loadWaline () {
  function initWaline () {
    const waline = Waline.init(Object.assign({
      el: '#waline-wrap',
      serverURL: 'https://blog-comment-bfstu88s1-ttj2023.vercel.app/',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      path: window.location.pathname,
      comment: false,
    }, null))
  }

  const walineCSSLoad = document.getElementById('waline-css')

  if (typeof Waline === 'object') {
    walineCSSLoad ? initWaline() : getCSS('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.css','waline-css').then(initWaline)
  }
  else {
    getCSS('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.css','waline-css').then(() => {
      getScript('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.js').then(initWaline)
    })
  }
}

if ('Waline' === 'Waline' || !true) {
  if (true) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
  else setTimeout(loadWaline, 0)
} else {
  function loadOtherComment () {
    loadWaline()
  }
}</script><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'https://tjzhang-src.github.io/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/'
    this.page.identifier = '/.github.io/2024/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/'
    this.page.title = '操作系统-精髓与设计原理'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }

  document.getElementById('darkmode').addEventListener('click', () => {
    setTimeout(() => window.disqusReset(), 200)
  })
}

if ('Waline' === 'Disqus' || !true) {
  if (true) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>