<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>Linux高性能服务器编程 | Welcome</title><meta name="author" content="John Doe"><meta name="copyright" content="John Doe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1-4章又介绍了TCP&#x2F;IP协议 TCP&#x2F;IP协议簇     上面这图很具有误导性，比如ICMP是作为数据封装到IP内，但把他们画到同一层。ARP是作为数据封装到数据链路（比如以太网帧）内，但把他们画到同一层  TCP: 可靠的、面向连接的、基于流的。 UDP: 不可靠、无连接、基于数据报的。 封装&amp;分用：分用指的解析本层书籍，将处理后的数据往上层传。   复位报文段产">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux高性能服务器编程">
<meta property="og:url" content="https://tjzhang-src.github.io/.github.io/2024/12/04/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="Welcome">
<meta property="og:description" content="1-4章又介绍了TCP&#x2F;IP协议 TCP&#x2F;IP协议簇     上面这图很具有误导性，比如ICMP是作为数据封装到IP内，但把他们画到同一层。ARP是作为数据封装到数据链路（比如以太网帧）内，但把他们画到同一层  TCP: 可靠的、面向连接的、基于流的。 UDP: 不可靠、无连接、基于数据报的。 封装&amp;分用：分用指的解析本层书籍，将处理后的数据往上层传。   复位报文段产">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2024-12-04T09:01:31.000Z">
<meta property="article:modified_time" content="2025-02-20T12:54:14.380Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="web">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/.github.io/img/favicon.png"><link rel="canonical" href="https://tjzhang-src.github.io/.github.io/2024/12/04/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//hm.baidu.com"/><link rel="stylesheet" href="/.github.io/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?4cc6526274b17acfe67a4be7d70e8d1c";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-FF1BJEGK51"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-FF1BJEGK51');
</script><script>const GLOBAL_CONFIG = { 
  root: '/.github.io/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux高性能服务器编程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-02-20 20:54:14'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (false) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/.github.io/archives/"><div class="headline">文章</div><div class="length-num">44</div></a><a href="/.github.io/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/.github.io/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/.github.io/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/.github.io/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/.github.io/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/.github.io/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/.github.io/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/.github.io/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/.github.io/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/.github.io/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s2.loli.net/2023/02/26/9fQnztK2ImqyLwS.webp')"><nav id="nav"><span id="blog-info"><a href="/.github.io/" title="Welcome"><span class="site-name">Welcome</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/.github.io/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/.github.io/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/.github.io/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/.github.io/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/.github.io/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/.github.io/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/.github.io/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/.github.io/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Linux高性能服务器编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-12-04T09:01:31.000Z" title="发表于 2024-12-04 17:01:31">2024-12-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-02-20T12:54:14.380Z" title="更新于 2025-02-20 20:54:14">2025-02-20</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">16.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>53分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Linux高性能服务器编程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>1-4章又介绍了TCP&#x2F;IP协议</p>
<h3 id="TCP-x2F-IP协议簇"><a href="#TCP-x2F-IP协议簇" class="headerlink" title="TCP&#x2F;IP协议簇"></a>TCP&#x2F;IP协议簇</h3><img src="/.github.io/2024/12/04/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20241204171026525.png" class title="image-20241204171026525">



<blockquote>
<p>上面这图很具有误导性，比如ICMP是作为数据封装到IP内，但把他们画到同一层。ARP是作为数据封装到数据链路（比如以太网帧）内，但把他们画到同一层</p>
</blockquote>
<p>TCP: 可靠的、面向连接的、基于流的。</p>
<p>UDP: 不可靠、无连接、基于数据报的。</p>
<p>封装&amp;分用：分用指的解析本层书籍，将处理后的数据往上层传。</p>
<img src="/.github.io/2024/12/04/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20241219111244485.png" class title="image-20241219111244485">

<h4 id="复位报文段"><a href="#复位报文段" class="headerlink" title="复位报文段"></a>复位报文段</h4><p>产生复位报文段的三种情况：</p>
<h5 id="访问不存在的端口"><a href="#访问不存在的端口" class="headerlink" title="访问不存在的端口"></a>访问不存在的端口</h5><p>访问不存在的端口或者该端口处于TIME_WAIT状态，客户端会收到复位报文段。</p>
<h5 id="异常终止连接"><a href="#异常终止连接" class="headerlink" title="异常终止连接"></a>异常终止连接</h5><p>TCP提供了异常终止一个连接的方式，即向对方发送一个复位报文段。对方收到后，会丢弃所有排队等待发送的数据。</p>
<h5 id="处理半打开连接"><a href="#处理半打开连接" class="headerlink" title="处理半打开连接"></a>处理半打开连接</h5><p>比如服务端和客户端已经连接上，但是服务端网线被拔了，重新接上后。只有客户端维护着连接，当他往管道写入数据时，会受到一个复位报文段。</p>
<h4 id="TCP交互数据流"><a href="#TCP交互数据流" class="headerlink" title="TCP交互数据流"></a>TCP交互数据流</h4><p>TCP连接的应用数据分为两类：<strong>交互数据和成块数据</strong>。</p>
<p>比如通<code>telnet</code>访问服务器，会经过如下过程</p>
<p>每键入一个字符，会将该字符用<code>TCP</code>包发给服务器，服务器回发了确认消息以及数据，客户端立刻回发确认消息。</p>
<p>这可能导致网络上过多的数据包，可以通过Nagle算法解决：即限制通信双方只能有一个未被确认的的报文段（即，收到对方的确认前不能发送新数据）</p>
<h4 id="TCP成块数据流"><a href="#TCP成块数据流" class="headerlink" title="TCP成块数据流"></a>TCP成块数据流</h4><h4 id="带外数据"><a href="#带外数据" class="headerlink" title="带外数据"></a>带外数据</h4><p>用于通告对方本端发生的重要事件。</p>
<p>TCP、UDP都没有真正的带外数据，不过TCP利用其头部中的紧急指针和紧急指针标志为应用程序提供了一种紧急方式。</p>
<p>发送方将带外数据写入到发送缓冲区后，会设置紧急指针和紧急指针标志。</p>
<img src="/.github.io/2024/12/04/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20241218213232983.png" class title="image-20241218213232983">

<h3 id="TCP-x2F-IP通信案例"><a href="#TCP-x2F-IP通信案例" class="headerlink" title="TCP&#x2F;IP通信案例"></a>TCP&#x2F;IP通信案例</h3><h3 id="Linux网络编程基础API"><a href="#Linux网络编程基础API" class="headerlink" title="Linux网络编程基础API"></a>Linux网络编程基础API</h3><h4 id="socket地址API"><a href="#socket地址API" class="headerlink" title="socket地址API"></a>socket地址API</h4><h5 id="主机字节序和网络字节序"><a href="#主机字节序和网络字节序" class="headerlink" title="主机字节序和网络字节序"></a>主机字节序和网络字节序</h5><p>大部分PC使用（小端）主机字节序，Java虚拟机使用大端字节序。为了避免在建立连接时再沟通双方字节序，所以干脆在传输过程中都使用大端（网络）字节序。</p>
<p><code>htonl, htons, ntohl, ntohs</code>是常用的转换方式。</p>
<h5 id="通用socket地址"><a href="#通用socket地址" class="headerlink" title="通用socket地址"></a>通用socket地址</h5><p>表示socket地址的是结构体sockaddr，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct sockaddr&#123;</span><br><span class="line">	sa_family_t sa_family;</span><br><span class="line">	char sa_data[14];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="专用socket地址"><a href="#专用socket地址" class="headerlink" title="专用socket地址"></a>专用socket地址</h5><img src="/.github.io/2024/12/04/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20241219103735765.png" class title="image-20241219103735765">

<p>所有专用socket地址类型的变量在使用时需要转化为通用socket地址类型sockaddr（强制转换）。</p>
<h5 id="IP地址转换函数"><a href="#IP地址转换函数" class="headerlink" title="IP地址转换函数"></a>IP地址转换函数</h5><img src="/.github.io/2024/12/04/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20241219104609523.png" class title="image-20241219104609523">

<p><code>inet_addr</code>用于将点分十进制<strong>字符串IPv4地址</strong>转换为字节序<strong>整数</strong>表示的IPv4地址。</p>
<p><code>inet_aton</code>也是完成这个功能，但他将转换结果保存到参数inp指向的结构中。</p>
<p><code>inet_ntoa</code>将网络字节序整数转化为点分十进制表示的IPv4地址，但该函数内部用<strong>一个静态变量</strong>存储转换结果，他是不可重入的。</p>
<p>上面的三个函数只能用于IPv4，下面的两个函数可以指定协议簇，适用于IPv4和IPv6.</p>
<img src="/.github.io/2024/12/04/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20241219105222213.png" class title="image-20241219105222213">

<h4 id="创建socket"><a href="#创建socket" class="headerlink" title="创建socket"></a>创建socket</h4><p><code>int socket(int domain, int type, int protocol)</code>。</p>
<ul>
<li>domain参数告诉系统使用哪个底层协议簇，比如PF_INET, PF_INET6</li>
<li>type参数指定了服务类型，SOCK_STREAM表示使用TCP。（从内核2.6.17开始，可以将SOCK_STREAM和两个标志<strong>相与</strong>后传给函数，这两个标志SOCK_NONBLOCK和SOCK_CLOEXEC分别表示socket是非阻塞的以及创建子进程时在子进程中关闭该socket）</li>
<li>protocol参数通常设为0</li>
</ul>
<p>成功返回socket文件描述符，失败返回-1并设置errno。</p>
<h4 id="命名socket"><a href="#命名socket" class="headerlink" title="命名socket"></a>命名socket</h4><p>创建socket后，还需要为其指定某个具体的socket地址，这称为socket命名。<code>int bind(int sockfd, const struct sockaddr* my_addr, socklen_t addrlen)</code></p>
<p>bind将my_addr指定的sockat地址分配给未命名的sockfd文件描述符。成功返回0，失败返回-1并设置errno，常见的两个errno：</p>
<ul>
<li>EACCES，如果绑定的地址是知名服务端口，bind将返回这个错误。</li>
<li>EADDRINUSE，被绑定的地址正在使用中，比如将socket绑定到一个TIME_WAIT状态的socket地址。</li>
</ul>
<h4 id="监听socket"><a href="#监听socket" class="headerlink" title="监听socket"></a>监听socket</h4><p><code>int listen(int sockfd, int backlog)</code>,</p>
<p>backlog参数指定处于<code>ESTABLISHED</code>的socket的上限，典型值为5。处于半连接状态<code>SYN_RCVD</code>的上限由内核参数配置。</p>
<h4 id="接受连接"><a href="#接受连接" class="headerlink" title="接受连接"></a>接受连接</h4><p><code>int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen)</code>，</p>
<p>addr用来获取远端socket地址。accept成功时返回新的连接socket，否则返回-1并设置errno。</p>
<h4 id="发起连接"><a href="#发起连接" class="headerlink" title="发起连接"></a>发起连接</h4><p><code>int connect(int sockfd, const struct sockaddr *serv_addr, socklen_t addrlen)</code>,</p>
<h4 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h4><p><code>int close(int fd)</code></p>
<p>它会将该fd的引用计数减一，当fd的引用计数变为0时，才会关闭连接。如果要立刻终止连接，可以使用shutdown系统调用</p>
<p><code>int shutdown(int sockfd, int howto)</code>howto有三种参数</p>
<ul>
<li>SHUT_RD，关闭读，应用程序不能读该sockfd，并清空读缓冲区。</li>
<li>SHUT_WR，关闭写，应用程序不能写该sockfd，并清空写缓冲区。</li>
<li>SHUTRDWR，关闭读写</li>
</ul>
<h4 id="数据读写"><a href="#数据读写" class="headerlink" title="数据读写"></a>数据读写</h4><h5 id="TCP数据读写"><a href="#TCP数据读写" class="headerlink" title="TCP数据读写"></a>TCP数据读写</h5><p>通用的文件读写操作<code>read</code>和<code>write</code>适用于<code>socket</code>，但socket编程接口提供了几个专门用于数据读写的数据调用，他们增强了对数据读写的控制，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssize_t recv(int sockfd, void *buf, size_t len, int flags);</span><br><span class="line">ssize_t send(int sockfd, const void *buf, size_t len, int flags);</span><br></pre></td></tr></table></figure>

<ul>
<li>recv: flags通常设为0即可。recv成功返回数据长度，出错则返回-1并设置errno，对方已经关闭连接则返回0。(如果还没收到对方的数据，则不返回)</li>
<li>send，成功返回实际写入数据的长度，失败返回-1并设置errno。</li>
</ul>
<p>flags参数提供了额外的控制。</p>
<img src="/.github.io/2024/12/04/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20241219141525027.png" class title="image-20241219141525027">

<p>flags参数只对当此send和recv调用生效，可以通过setsockopt来永久的修改socket的某些属性。</p>
<p>针对含有带外数据TCP数据读取，正常数据的接收会被带外数据截断，比如服务器发送<code>123abc123</code>,其中abc是带外数据（设置flags为MSG_OOB），客户端通过一次recv是没法读取全部数据的，通过recv()读取<code>123ab</code>,然后通过recv(MSG_OOB)读取<code>c</code>, 通过recv读取<code>123</code>。</p>
<h5 id="UDP数据读写"><a href="#UDP数据读写" class="headerlink" title="UDP数据读写"></a>UDP数据读写</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssize_t recvfrom(int sockfd, void* buf, size_t len, int flags, struct sockaddr* src_addr, socklen_t* addrlen);</span><br><span class="line">ssize_t sendto(int sockfd, const void* buf, size_t len, int flags, const struct sockaddr* dest_addr, socklen_t addrlen);</span><br></pre></td></tr></table></figure>

<p>因为UDP是无连接的，并不会将sockfd绑定到一个固定的地址上，所以每次发送数据时都需要指定从哪个地址发送数据，</p>
<h5 id="通用数据读写函数"><a href="#通用数据读写函数" class="headerlink" title="通用数据读写函数"></a>通用数据读写函数</h5><p>socket编程接口提供了一对通用的数据读写系统调用。它可以用与TCP和UDP的数据读取。</p>
<img src="/.github.io/2024/12/04/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20241219150112522.png" class title="image-20241219150112522">

<h4 id="带外标记"><a href="#带外标记" class="headerlink" title="带外标记"></a>带外标记</h4><h4 id="地址信息函数"><a href="#地址信息函数" class="headerlink" title="地址信息函数"></a>地址信息函数</h4><p>获取sockfd对应的socket地址。</p>
<img src="/.github.io/2024/12/04/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20241219150631131.png" class title="image-20241219150631131">

<h4 id="socket选项"><a href="#socket选项" class="headerlink" title="socket选项"></a>socket选项</h4><p>如果说fcntl是控制文件描述符属性的通用POSIX方法，那么如下的两个系统调用则是设置socket文件描述符属性的方法：</p>
<img src="/.github.io/2024/12/04/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20241219151243991.png" class title="image-20241219151243991">

<p>不同的level指定了要对哪些协议进行操作：</p>
<img src="/.github.io/2024/12/04/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20241219151946741.png" class title="image-20241219151946741">

<ul>
<li>对服务器而言有些选项只能在listen系统调用前生效，因为比如最大报文段选项只能在TCP同步报文段设置，执行listen系统调用后，可能已经接受了客户端的连接，这时已经没法更改最大报文段选项了。通常accept返回的socket会自动继承监听socket的选项，包括SO_DEBUG、SO_DONTROUTE等。</li>
<li>对于客户端而言，这些选项应该在connect之前设置。</li>
</ul>
<h5 id="SO-REUSEADDR选项"><a href="#SO-REUSEADDR选项" class="headerlink" title="SO_REUSEADDR选项"></a>SO_REUSEADDR选项</h5><p>通过将该选项设置为1，可以直接使用处于TIME_WAIT状态的socket地址，也可以通过修改内核参数来快速回收被关闭的socket。</p>
<h5 id="SO-RCVBUF和SO-SNDBUF"><a href="#SO-RCVBUF和SO-SNDBUF" class="headerlink" title="SO_RCVBUF和SO_SNDBUF"></a>SO_RCVBUF和SO_SNDBUF</h5><p>设置TCP发送和接收缓冲区的大小。系统会将该参数加倍，并且不得小于某个最小值。</p>
<h5 id="SO-REVLOWAT和SO-SNDLOWAT选项"><a href="#SO-REVLOWAT和SO-SNDLOWAT选项" class="headerlink" title="SO_REVLOWAT和SO_SNDLOWAT选项"></a>SO_REVLOWAT和SO_SNDLOWAT选项</h5><p>通常低水位标记都为1字节。当可读数据大于低水位标记时，会通知应用程序读数据，当空闲空间大于低水位时，会通知往socket写数据。</p>
<h5 id="SO-LINGER选项"><a href="#SO-LINGER选项" class="headerlink" title="SO_LINGER选项"></a>SO_LINGER选项</h5><p>用于控制close系统调用在关闭TCP连接时的行为。</p>
<ul>
<li><p>默认情况下，当通过close关闭连接时，会立刻返回，并将TCP发送缓冲区残留的数据发送给对方。</p>
</li>
<li><p>当设置了SO_LINGER选项时，需要传递一个linger结构体</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct linger&#123;</span><br><span class="line">	int l_onoff; //开启还是关闭</span><br><span class="line">	int l_linger; //滞留时间</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>l_onoff等于0时，SO_LINGER选项不起作用，close仍然使用默认行为来关闭socket。</li>
<li>l_onoff不为0，l_linger等于0，这时close系统调用立刻返回，TCP模块将丢弃残留的数据，同时给对方发送一个复位报文段。</li>
<li>l_onoff不为0，l_linger大于0。<ul>
<li>对于阻塞socket，close将等待一段长为l_linger的时间，直到发送完所有数据并收到确认，没有发送完以及得到确认会返回-1设置errno为EWOULDBLOCK.</li>
<li>对于非阻塞socket，close会立刻返回，此时需要根据返回值和errno来判断数据是否已经发送完毕。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="网络信息API"><a href="#网络信息API" class="headerlink" title="网络信息API"></a>网络信息API</h4><p>可以用主机名来代表ip地址，也可以用服务名称来代表端口号。</p>
<h5 id="gethostbyname和gethostbyaddr"><a href="#gethostbyname和gethostbyaddr" class="headerlink" title="gethostbyname和gethostbyaddr"></a>gethostbyname和gethostbyaddr</h5><p>可以通过名字和地址获取主机的完整信息。（先从&#x2F;etc&#x2F;hosts中找，再从DNS找）</p>
<h5 id="getservbyname和getservbyport"><a href="#getservbyname和getservbyport" class="headerlink" title="getservbyname和getservbyport"></a>getservbyname和getservbyport</h5><p>可以通过名字和端口号获取服务的完整信息。（从&#x2F;etc&#x2F;services读取服务信息）</p>
<p>这四个函数都不可重入，不是线程安全的。函数名后加<code>_r</code>代表可重入的。</p>
<h5 id="getaddrinfo"><a href="#getaddrinfo" class="headerlink" title="getaddrinfo"></a>getaddrinfo</h5><p>可以根据主机名获取IP地址，也可以通过服务名获得端口号，是否可重入取决于其内部的gethostbyname和getservbyname是否是可重入的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int getaddrinfo(const char* hostname, const char* service, const struct addrinfo* hints, struct addrinfo** result);</span><br></pre></td></tr></table></figure>

<ul>
<li>hostname可以是主机名也可以是IP地址</li>
<li>service可以是服务名也可以是端口号</li>
<li>hints可以为NULL</li>
<li>results指向一个addrinfo类型的链表</li>
</ul>
<h5 id="getnameinfo"><a href="#getnameinfo" class="headerlink" title="getnameinfo"></a>getnameinfo</h5><p>获取主机名和服务名</p>
<h3 id="高级IO函数"><a href="#高级IO函数" class="headerlink" title="高级IO函数"></a>高级IO函数</h3><p>Linux提供了很多高级的IO函数，他们在特定的情况下性能很优异，这些函数分为三类：</p>
<ul>
<li>创建文件描述符的函数，如pipe、dup&#x2F;dup2函数</li>
<li>读写数据的函数，如readv&#x2F;writev、sendfile、mmap&#x2F;munmap、splice和tee函数</li>
<li>用于控制I&#x2F;O行为和属性的函数，如fcntl函数</li>
</ul>
<h4 id="PIPE函数"><a href="#PIPE函数" class="headerlink" title="PIPE函数"></a>PIPE函数</h4><p>pipe函数用于创建一个管道，以实现进程间通信。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int pipe(int fd[2]);</span><br></pre></td></tr></table></figure>

<ul>
<li>通过pipe函数创建的两个文件描述符fd[0]和fd[1]分别构成管道的两端，只能从fd[1]写，只能从fd[0]读，要实现双向传输需要两个管道。</li>
<li>默认情况下管道是阻塞的。</li>
<li>如果写端的引用计数为0，则读端的read操作返回0，代表读到了文件结束标记。如果读端的引用计数为0，写端的写操作会失败，出发SIGPIPE信号。</li>
</ul>
<p>还有一个socketpair函数，它可以方面的创建<strong>双向管道</strong>。</p>
<h4 id="dup函数和dup2函数"><a href="#dup函数和dup2函数" class="headerlink" title="dup函数和dup2函数"></a>dup函数和dup2函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int dup(int oldfd);</span><br><span class="line">int dup2(int oldfd, int newfd);</span><br></pre></td></tr></table></figure>

<p>这两个函数可以复制一个文件描述符，两者的区别在于dup返回的文件描述符返回的是最小的未被使用的描述符，dup2返回的是指定的描述符newfd。</p>
<p>通过dup和dup2创建的文件描述符并不继承原文件描述符的属性，比如close-on-exec和non-blocking等。</p>
<h4 id="readv函数和writev函数"><a href="#readv函数和writev函数" class="headerlink" title="readv函数和writev函数"></a>readv函数和writev函数</h4><p>readv将数据从文件描述符读到分散的内存块中，writev将多块分散的内存数据写入到文件描述符中。这两者相当于简化版的sendmsg和recvmsg函数。</p>
<img src="/.github.io/2024/12/04/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20241219194727150.png" class title="image-20241219194727150">

<p>如果想要向对方发送多个缓冲区上的数据，则没有必要将他们拼接到一个缓冲区上在发送，而是可以直接通过writev来发送。</p>
<img src="/.github.io/2024/12/04/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20241219200505431.png" class title="image-20241219200505431">

<h4 id="sendfile函数"><a href="#sendfile函数" class="headerlink" title="sendfile函数"></a>sendfile函数</h4><p>sendfile可以直接在两个文件描述符之间传递数据（完全在内核空间操作），从而避免了在内核缓冲区和用户缓冲区之间的数据拷贝，效率很高，称为<strong>零拷贝</strong>。in_fd必须是一个文件描述符(因为sendfile底层需要使用mmap将in_fd进行映射)，out_fd在Linux2.6.33后可以是任何文件。</p>
<p><code>ssize_t sendfile(int  out_fd, int in_fd, off_t* offset, ssize_t count)</code>，</p>
<h4 id="mmap和munmap函数"><a href="#mmap和munmap函数" class="headerlink" title="mmap和munmap函数"></a>mmap和munmap函数</h4><p>mmap可以申请一段内存，用于进程间通信的，也可以将文件映射到内存中。</p>
<img src="/.github.io/2024/12/04/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20241219202240380.png" class title="image-20241219202240380">

<ul>
<li>start指定了映射到虚拟内存中的地址，可以为空</li>
<li>length指定了内存段的长度</li>
<li>prot参数用来设置内存段的访问权限，可读可写可执行</li>
<li>flags指定一些标志，比如是否在进程间共享，是否是从文件映射来的。</li>
</ul>
<p>成功返回指向内存区域的指针，失败返回MAP_FAILED((void*)-1)</p>
<h4 id="splice函数"><a href="#splice函数" class="headerlink" title="splice函数"></a>splice函数</h4><p>用于在两个文件描述符之间移动数据，也是零拷贝数据。(两个文件描述符中，<strong>有一个必须是管道</strong>)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">ssize_t splice(int fd_in, loff_t *off_in, int fd_out,loff_t *off_out, size_t len, unsigned int flags);</span><br></pre></td></tr></table></figure>

<h4 id="tee函数"><a href="#tee函数" class="headerlink" title="tee函数"></a>tee函数</h4><p>在两个管道文件描述符之间复制数据，他不消耗数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssize_t tee(int fd_in, int fd_out, size_t len, unsigned int flags);</span><br></pre></td></tr></table></figure>

<h4 id="fcntl函数"><a href="#fcntl函数" class="headerlink" title="fcntl函数"></a>fcntl函数</h4><p>fcntl和ioctl都可以对文件描述符进行各种操作，ioctl比fcntl能执行更多的控制，对于控制文件描述符常用的属性，fcntl函数是POSIX规定的首选方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int fcntl(int fd, int cmd, ... /* arg */ );</span><br></pre></td></tr></table></figure>

<img src="/.github.io/2024/12/04/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20241220153028717.png" class title="image-20241220153028717">

<p>fcntl常用来将文件描述符设置为非阻塞的。</p>
<img src="/.github.io/2024/12/04/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20241220153408639.png" class title="image-20241220153408639">

<h3 id="Linux服务器程序规范"><a href="#Linux服务器程序规范" class="headerlink" title="Linux服务器程序规范"></a>Linux服务器程序规范</h3><ul>
<li>服务器程序以守护进程形式存在，父进程一般是init进程</li>
<li>服务器程序一般有日志系统，可以输出到文件，一般在<code>/var/log</code>下，有的服务器还能输出日志到专门的UDP服务器。</li>
<li>Linux服务器程序一般是以非root身份运行的，如mmysqld、httpd、syslogd，分别有自己的运行账户mysql、apache、syslog。</li>
<li>可以通过命令行选项和配置文件对服务器程序进行配置，大部分配置文件存放在<code>/etc</code>目录下</li>
<li>服务器启动时会生成一个PID文件存入<code>/var/run</code>目录下，以记录该程序的PID，以便于其他程序查询。</li>
</ul>
<h4 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h4><h5 id="Linux系统日志"><a href="#Linux系统日志" class="headerlink" title="Linux系统日志"></a>Linux系统日志</h5><p>Linux一般使用rsyslogd(syslogd)这个守护进程来处理日志。该进程可以同时接收来自用户进程和内核的日志。</p>
<ul>
<li>用户进程是通过调用syslog函数来生成系统日志，该函数将日志输出到UNIX本地域socket类型的<code>/dev/log</code>上。rsyslogd则监听该文件以获取用户进程的输出。</li>
<li>内核日志是通过printk等函数打印到内核的环形缓存中，环形缓存的内容直接映射到<code>/proc/kmsg</code>文件中，rsyslogd通过读取该文件获取内核日志。</li>
</ul>
<p>rsyslogd收到用户或内核的日志后，会根据配置文件将日志输出到日志文件。</p>
<img src="/.github.io/2024/12/04/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20241220161559781.png" class title="image-20241220161559781">

<h5 id="syslog函数"><a href="#syslog函数" class="headerlink" title="syslog函数"></a>syslog函数</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;syslog.h&gt;</span><br><span class="line">void syslog(int priority, const char *format, ...);</span><br></pre></td></tr></table></figure>

<p>该函数使用可变参数来结构化输出。</p>
<ul>
<li><p>priority，是设施值和日志级别的按位与，设施值的默认值是LOG_USER, 日志级别有如下几类：</p>
<img src="/.github.io/2024/12/04/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20241220163848517.png" class title="image-20241220163848517"></li>
</ul>
<p>可以使用下面的函数开启logger并设置syslog的默认输出方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void openlog(const char *ident, int option, int facility);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>ident指定的字符串被存放到日志消息的时间之后，它通常被设置为程序的名字</p>
</li>
<li><p>option参数对后序syslog调用的行为进行配置，它可以如下值的组合</p>
<img src="/.github.io/2024/12/04/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20241220164146827.png" class title="image-20241220164146827">
</li>
<li><p>facility可以修改syslog函数中的默认设施值，</p>
</li>
</ul>
<p>通过如下函数设置日志掩码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int setlogmask(int maskpri);</span><br></pre></td></tr></table></figure>

<h4 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h4><p>很多服务器进程需要以root身份启动，但实际运行时，需要切换为普通用户身份运行，以保证安全性。</p>
<h5 id="UID、EUID、GID和EGID"><a href="#UID、EUID、GID和EGID" class="headerlink" title="UID、EUID、GID和EGID"></a>UID、EUID、GID和EGID</h5><img src="/.github.io/2024/12/04/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20241220165201234.png" class title="image-20241220165201234">

<p>uid表示的是进程的创建者，euid表示的是进程对资源的实际访问权限。</p>
<ul>
<li>通常一个进程能访问什么资源，取决于<strong>创建它的进程（uid，从用户的角度上看的）</strong>的权限。</li>
<li>使用euid后，一个进程能访问什么资源，取决于该<strong>程序的所有者（从文件系统的层面上看的）</strong>的权限</li>
</ul>
<blockquote>
<p>比如su程序的所有者是root，并且他设置了set-user-id标志，那么通过非root用户执行该程序时，有效用户是root。有效用户为root的进程称为特权进程。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main(void)&#123;</span><br><span class="line">    uid_t uid = getuid();</span><br><span class="line">    uid_t euid = geteuid();</span><br><span class="line">    printf(&quot;userid is %d, effective userid is %\n&quot;, uid, euid);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">(yolo) tangjie.zhang@moveai415:chapter7$ g++ -o uid_euid uid_euid.cpp </span><br><span class="line">(yolo) tangjie.zhang@moveai415:chapter7$ ./uid_euid //1037对应我的用户的id，euid暂时没有设置，可以通过chmod +s uid_euid配置</span><br><span class="line">userid is 1037, effective userid is %</span><br></pre></td></tr></table></figure>

<h5 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h5><p>通过setgid和setuid实现。</p>
<h4 id="进程间关系"><a href="#进程间关系" class="headerlink" title="进程间关系"></a>进程间关系</h4><h5 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h5><blockquote>
<p>Linux下用户有用户id和用户组id</p>
<p>Linux下的文件对应一个所有者用户、同组用户和其他用户</p>
</blockquote>
<p>Linux下的每个进程都隶属一个进程组，都有一个PID和PGID（进程组ID）。每个进程组都有一个首领进程，他的PGID和PID是相同的，进程组会一直存在直到所有进程都退出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int setpgid(pid_t pid, pid_t pgid)</span><br></pre></td></tr></table></figure>

<p>该函数用于将PID为pid的进程的PGID设置为pgid。</p>
<ul>
<li>如果pid和pgid相同，则将该进程从原进程组分离出来，并设置为进程组首领。</li>
<li>pid为0，则默认将当前进程的PGID设置为pgid。</li>
<li>pgid为0，则使用pid作为目标PGID。</li>
</ul>
<p>一个进程只能设置自己或者其子进程PGID, </p>
<h5 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h5><p>一些有<strong>关联的进程</strong>将形成一个会话（session），下面的函数用于创建一个会话。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pid_t setsid(void);</span><br></pre></td></tr></table></figure>

<p>该函数不能有进程组的首领进程调用，当非首领进程调用该函数时，会产生创建一个新会话，并且：</p>
<ul>
<li>调用进程成为会话的首领，此时该进程是新会话的唯一成员</li>
<li>新建一个进程组，调用进程成为该组的首领</li>
</ul>
<p>Linux进程没有提供所谓会话ID的概念，Linux认为它等于会话首领所在的进程组的PGID。提供了如下的方式读取：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pid_t getsid(pid_t pid);</span><br></pre></td></tr></table></figure>

<h5 id="用ps命令查看进程关系"><a href="#用ps命令查看进程关系" class="headerlink" title="用ps命令查看进程关系"></a>用ps命令查看进程关系</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ps -o pid,ppid,pgid,sid,comm | less</span><br><span class="line">    PID    PPID    PGID     SID COMMAND</span><br><span class="line">3535939 3535938 3535939 3535939 bash</span><br><span class="line">3537268 3535939 3537268 3535939 ps</span><br><span class="line">3537269 3535939 3537268 3535939 less</span><br></pre></td></tr></table></figure>

<p>这三个命令创建了一个会话和两个进程组，bash是会话的首领也是进程组3535938的首领，ps命令是进程组3537268的首领。</p>
<img src="/.github.io/2024/12/04/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20241220194810282.png" class title="image-20241220194810282">

<h4 id="系统资源限制"><a href="#系统资源限制" class="headerlink" title="系统资源限制"></a>系统资源限制</h4><p>Linux上运行的程序会受到系统资源限制的影响，比如物理设备限制（CPU、内存），Linux系统资源限制可以通过如下的函数读取和设置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;sys/resource.h&gt;</span><br><span class="line">int getrlimit(int resource, struct rlimit *rlim);</span><br><span class="line">int setrlimit(int resource, const struct rlimit *lim);</span><br><span class="line">struct rlimit&#123;</span><br><span class="line">	rlim_t rlim_cur; //rlim_t是一个整数类型</span><br><span class="line">	rlim_t rlim_max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>rlim_cur是指定资源的软限制，而rlim_max是硬限制，（CPU时间超过软限制时，会由系统向进程发送SIGXCPU, 文件尺寸大于软限制时，会由系统向进程发送SIGXFSZ信号）</p>
<img src="/.github.io/2024/12/04/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20241220195930448.png" class title="image-20241220195930448">

<h4 id="改变工作目录和根目录"><a href="#改变工作目录和根目录" class="headerlink" title="改变工作目录和根目录"></a>改变工作目录和根目录</h4><blockquote>
<p>当我们使用相对路径时，系统会以工作目录为起点来查找文件。</p>
<p>使用绝对路径时，使用根目录为起点来查找文件。如果使用<code>chroot /usr/local</code>，那么这个进程的根目录就会变为<code>/usr/local</code>，此时，即使执行<code>ls /</code>，看到的也是<code>/usr/local</code>目录下的内容。</p>
</blockquote>
<p>获取进程当前工作目录和改变进程工作目录的函数分别是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">getcwd</span><span class="params">(<span class="type">char</span> * buf, <span class="type">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">chdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * path)</span></span>;</span><br></pre></td></tr></table></figure>

<p>改变进程根目录的函数是chroot（只有特权进程才能改变根目录）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">chroot</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="服务器程序后台化"><a href="#服务器程序后台化" class="headerlink" title="服务器程序后台化"></a>服务器程序后台化</h4><p>可以使用daemon库函数来实现，也可以亲手实现（创建子进程，关闭父进程，使其父进程变为init，更改文件权限掩码为0，设定本进程为进程组的首领，切换工作目录，关闭输入输出，把输入输出重定向到<code>dev/null</code>）</p>
<blockquote>
<p>关闭标准输出后，如果程序还在使用printf打印信息，这些信息会被放到缓冲区，所以建议使用<code>/dev/null</code>来让屏蔽输出。</p>
</blockquote>
<h3 id="高性能服务器程序框架"><a href="#高性能服务器程序框架" class="headerlink" title="高性能服务器程序框架"></a>高性能服务器程序框架</h3><p>三个主要模块：</p>
<ul>
<li>I&#x2F;O处理单元：四种IO模型和两种事件处理模式</li>
<li>逻辑单元：两种高效并发方式，以及高效的逻辑处理方式——有限状态机</li>
<li>存储单元</li>
</ul>
<h4 id="服务器模型"><a href="#服务器模型" class="headerlink" title="服务器模型"></a>服务器模型</h4><h5 id="C-x2F-S模型"><a href="#C-x2F-S模型" class="headerlink" title="C&#x2F;S模型"></a>C&#x2F;S模型</h5><p>如下，使用的是IO复用技术之一的select系统调用。</p>
<img src="/.github.io/2024/12/04/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20241220212301740.png" class title="image-20241220212301740">

<h5 id="P2P"><a href="#P2P" class="headerlink" title="P2P"></a>P2P</h5><h4 id="服务器编程框架"><a href="#服务器编程框架" class="headerlink" title="服务器编程框架"></a>服务器编程框架</h4><p>服务器的基本框架都是一致的，如下：</p>
<img src="/.github.io/2024/12/04/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20241220212627348.png" class title="image-20241220212627348">

<p>该图各个部分的功能如下：</p>
<img src="/.github.io/2024/12/04/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20241220213230390.png" class title="image-20241220213230390">

<ul>
<li>IO处理单元负责管理客户连接，（数据收发，optional，取决于事件处理模式）</li>
<li>逻辑单元通常是一个进程、线程、逻辑服务器</li>
<li>网络存储单元</li>
</ul>
<h4 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h4><p>socket默认是阻塞的，可以通过socket的第二个参数或fcntl系统调用来将其设置为非阻塞的。阻塞的概念适用于所有文件描述符，阻塞的文件描述符称为阻塞IO，否则称为非阻塞IO。</p>
<ul>
<li>如果是阻塞IO，当没有完成操作时，该进程会被阻塞，直到完成操作。可能被阻塞的系统调用包括accept、send、recv、connect。</li>
<li>如果是非阻塞IO，不管事件有没有发生，系统调用都会立刻返回。如果时间没有立刻发生，系统调用会返回-1，这和出错的情况一样，所以还必须根据errno来区分这两者情况。<ul>
<li>对accept、send、recv而言，事件未发生时，errno被设置为EAGAIN或EWOULDBLOCK（期望阻塞）。</li>
<li>对connect而言，事件未发生时，errno被设置为EINPROGRESS（正在处理）。</li>
</ul>
</li>
</ul>
<p>非阻塞IO必须和其他<strong>IO通知机制</strong>一起使用，比如<strong>IO复用和SIGIO信号</strong>。</p>
<ul>
<li>IO复用，应用程序通过IO复用函数向内核注册一组事件，内核通过IO复用函数将其中就绪的事件通知应用程序。常用的IO复用函数包括<code>select, poll, epoll_wait</code>。</li>
<li>SIGIO信号也可以用来报告IO事件，可以为一个文件指定一个进程。当文件内容改变时，会给对应进程发SIGIO、SIGURG信号。见6.8，10。</li>
</ul>
<p>阻塞IO、IO复用、信号驱动IO都是同步IO模型。那什么是异步IO模型呢？</p>
<blockquote>
<p>对于同步IO而言，需要等待操作完成（通过阻塞或轮询，epoll_wati也会阻塞），才会执行其他任务，整个IO过程由调用方管理。（比如recv，需要等待接收缓冲区非空，才会返回，并接收数据）</p>
<p>对于异步IO而言，不需要等待任何事件，立刻返回，具体操作由操作系统完成。</p>
</blockquote>
<p>对异步IO而言，用户可以直接对IO执行读写操作，这些操作告诉内核用户读写缓冲区的位置，以及内核通知应用程序的方式。同步IO需要用户自行执行IO操作，而异步IO由内核来执行IO操作（数据在用户缓冲区与内核缓冲区的移动是靠内核完成的），并在完成时通知程序。</p>
<h4 id="两种高效的事件处理模式"><a href="#两种高效的事件处理模式" class="headerlink" title="两种高效的事件处理模式"></a>两种高效的事件处理模式</h4><p>服务器程序需要处理三类事件：IO事件、信号和定时事件。</p>
<p>两种事件处理模型：Reactor和Proactor。通常用同步IO实现Reactor模式，而使用异步IO实现Proactor模式。（也可以使用同步IO实现Proactor模式）</p>
<h5 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式"></a>Reactor模式</h5><p>Reactor模式：主线程（IO处理单元）只负责监听文件描述符，有的话就通知工作线程（逻辑单元）。除此之外，主线程不做其他实质性的工作。接受连接、读写数据、处理客户请求均在工作线程完成。</p>
<p>使用同步IO模型(比如epoll_wait)实现的Reactor模式的工作流程如下：（可能阻塞的操作需要通过epoll_wait来统一监测，比如从socket读、写）</p>
<ul>
<li>主线程往epoll内核事件表注册socket上的读就绪事件</li>
<li>主线程调用epoll_wait阻塞，等待socket上有数据可读。</li>
<li>socket上有数据可读时，epoll_wait会通知主线程，主线程将socket可读事件放入请求队列。</li>
<li>睡眠在请求队列上的某个工作线程被唤醒，他从socket读取数据，并处理客户请求，生成结果。然后往epoll内核事件表注册该socket上的写就绪事件。</li>
<li>主线程调用epoll_wait阻塞，等待对应socket上可以写数据。（有足够的缓冲区）</li>
<li>当socket可写时，epoll_wait通知主线程，主线程将socket可写事件放入请求队列。</li>
<li>睡眠的某个工作线程被唤醒，往socket上写入结果。</li>
</ul>
<img src="/.github.io/2024/12/04/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20241221171828529.png" class title="image-20241221171828529">

<blockquote>
<p>所有工作线程都会根据事件的类型来决定处理方式，是读、操作还是写。所以没必要区分读工作线程和写工作线程。</p>
</blockquote>
<h5 id="Proactor模式"><a href="#Proactor模式" class="headerlink" title="Proactor模式"></a>Proactor模式</h5><p>Proactor模式：Proactor模式将所有IO操作交给主线程和内核来处理，工作线程仅仅负责业务逻辑。</p>
<p>使用异步IO模型（aio_read和aio_write）实现的Proactor模式的工作流程是：</p>
<ul>
<li>主线程调用aio_read函数向内核注册socket上的读完成事件，并告诉内核用户读缓冲区的位置，以及读完成后通知主线程的方式（比如信号）。</li>
<li>主线程继续处理其他逻辑</li>
<li>当socket上的数据被读到用户缓冲区时，内核向主线程发一个信号，通知数据可用。</li>
<li>主线程使用预定义的<strong>信号处理函数</strong>（sighandler）选择一个工作线程来处理客户请求。工作线程执行完后，调用aio_write向内核注册socket上的写完成事件，并告诉内核用户缓冲区的位置，以及操作完成后如何通知主线程。</li>
<li>主程序继续处理其他逻辑</li>
<li>当数据被写到socket后，内核向应用程序发一个信号，以通知应用程序是否已经发送完毕。</li>
<li>应用程序使用预定义好的<strong>信号处理函数</strong>来完成善后，</li>
</ul>
<img src="/.github.io/2024/12/04/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20241221174758114.png" class title="image-20241221174758114">

<blockquote>
<p>这里的epoll_wait只需要监听连接事件，而不用监听读写事件。</p>
</blockquote>
<h5 id="模拟Proactor模式"><a href="#模拟Proactor模式" class="headerlink" title="模拟Proactor模式"></a>模拟Proactor模式</h5><p>由主线程（代替内核）执行数据读写操作，然后向工作线程通知这一事件，这样工作线程也只需要对数据进行处理。</p>
<img src="/.github.io/2024/12/04/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20241221192924423.png" class title="image-20241221192924423">

<h4 id="两种高效的并发模式"><a href="#两种高效的并发模式" class="headerlink" title="两种高效的并发模式"></a>两种高效的并发模式</h4><p>并发编程指IO处理单元和多个逻辑单元之间协调完成任务的方法。分为<strong>半同步&#x2F;半异步，领导者&#x2F;追随者</strong>模式。</p>
<h5 id="半同步-x2F-半异步方式"><a href="#半同步-x2F-半异步方式" class="headerlink" title="半同步&#x2F;半异步方式"></a>半同步&#x2F;半异步方式</h5><blockquote>
<p>这里的同步和IO模型中的同步和异步是不同的概念。</p>
<ul>
<li>在IO模型中，同步和异步区分的是内核向应用程序通知的是那种IO事件（是就绪事件还是完成事件），以及由谁来完成IO读写。</li>
<li>在并发模式中，同步指的是完全按照代码序列的顺序运行，异步指的是程序的执行需要由系统事件来驱动。常见的系统事件包括中断、信号。</li>
</ul>
</blockquote>
<img src="/.github.io/2024/12/04/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20241221200026972.png" class title="image-20241221200026972">

<p>按照同步方式运行的线程称为同步线程，按照异步方式运行的线程称为异步线程。异步线程的执行效率高，但复杂。同步线程效率低，但简单。对应服务器，使用半同步&#x2F;半异步模式实现。</p>
<p>逻辑单元部分是同步的，IO处理单元部分是异步的。（逻辑单元部分是按照代码顺序执行的，IO处理单元部分是根据各种事件运行的）</p>
<p>事件处理模式可以和IO模型接合起来：</p>
<p><strong>半同步半反应堆模式</strong>（并发模式是半同步半异步，事件处理模式是reactor模式）</p>
<img src="/.github.io/2024/12/04/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20241221204823911.png" class title="image-20241221204823911">

<p><strong>一种高效的半同步半异步模式</strong>：主线程只管理<strong>监听socket</strong>，工作线程管理<strong>连接socket</strong>。（这不就异步吗，为什么还要叫半同步，&#x2F;晕晕）</p>
<img src="/.github.io/2024/12/04/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20241221204956164.png" class title="image-20241221204956164">

<h5 id="领导者-x2F-追随者模式"><a href="#领导者-x2F-追随者模式" class="headerlink" title="领导者&#x2F;追随者模式"></a>领导者&#x2F;追随者模式</h5><p>多个工作线程轮流获取事件源集合，轮流监听。如果当前领导者进程检测到IO事件，首先要从线程池选择新的领导者线程，这个新的领导者线程等待IO事件，原来的领导者线程开始处理IO事件。</p>
<img src="/.github.io/2024/12/04/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20241221212933867.png" class title="image-20241221212933867">

<ul>
<li><p>句柄集，管理若干句柄（IO资源，即若干socket），领导者调用绑定到句柄上的事件处理器来处理事件</p>
</li>
<li><p>线程集，所有工作线程（领导者+追随者线程）的管理者，负责线程同步以及新领导的推选。线程集中的线程必然处于如下状态之一：</p>
<ul>
<li>Leader：线程处于领导者状态，在等待句柄集上的IO事件。</li>
<li>Processing：线程正在处理事件。领导者检测到IO事件后，可以转换到Processing态，并选新领导者；也可以指定其他Follower来处理事件。Processing态的线程处理完后，如果当前没有Leader，则自己当Leader。</li>
<li>Follower：可以调用线程集的join方法成为新Leader，也可以被Leader指定任务。</li>
</ul>
</li>
<li><p>事件处理器和具体的事件处理器</p>
<img src="/.github.io/2024/12/04/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20241221214541846.png" class title="image-20241221214541846"></li>
</ul>
<h4 id="有限状态机——逻辑单元内部的高效编程方法"><a href="#有限状态机——逻辑单元内部的高效编程方法" class="headerlink" title="有限状态机——逻辑单元内部的高效编程方法"></a>有限状态机——逻辑单元内部的高效编程方法</h4><p>应用层协议比如HTTP头部包含数据包类型字段，可以将类型映射为逻辑单元的一种执行状态，比如GET，HEAD，POST。</p>
<ul>
<li>状态独立的FSM：不能在状态之间转换。</li>
<li>带状态转移的FSM：可以在内部驱动下进行状态转移。</li>
</ul>
<p>例如HTTP头部解析，读到空行代表头部结束，需要使用一个主状态机来判断头部是否结束，还需要使用一个从状态机对每个请求行进行解析。</p>
<ul>
<li>主状态机：包含两个状态，表示当前读取的是<strong>头部字段还是请求行</strong>。</li>
<li>从状态机：包含三个状态，表示当前读取的行<strong>正确、错误还是不完整</strong>。</li>
<li>服务器处理HTTP的结果包含如下几种：NO_REQUEST, GET_REQUEST, BAD_REQUEST, FORBIDDEN_REQUEST, INTER_REQUEST, CLOSE_CONNECTION。</li>
</ul>
<h4 id="提高服务器性能的建议"><a href="#提高服务器性能的建议" class="headerlink" title="提高服务器性能的建议"></a>提高服务器性能的建议</h4><h5 id="池"><a href="#池" class="headerlink" title="池"></a>池</h5><p>直接从池中获取资源，比动态分配资源的速度要快很多。</p>
<p>常见的比如：</p>
<ul>
<li>内存池，用于socket的接收和发送缓存。</li>
<li>进程&#x2F;线程池，直接从进程池取得一个执行实体，而无需动态的调用fork。</li>
<li>连接池，用于维护服务器和数据库程序的一组连接。</li>
</ul>
<h5 id="数据复制"><a href="#数据复制" class="headerlink" title="数据复制"></a>数据复制</h5><p>gao高性能服务器应该避免不必要的数据复制，尤其是发生在内核和用户代码之间的复制。</p>
<p>如果没必要，则不需要将数据读到用户缓冲区。比如发送服务器上的文件时，可以直接通过sendfile发送，而不是先读到应用程序的缓存，再发送。</p>
<p>进程之间数据访问也应该被避免，当两个工作进程需要传递大量数据时，使用共享内存，而不是管道或消息队列。</p>
<h5 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h5><p>不应使用过多的工作线程，避免太多的上下文切换。</p>
<h5 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h5><p>避免锁，或者使用细粒度的锁，使用读写锁。</p>
<h3 id="IO复用"><a href="#IO复用" class="headerlink" title="IO复用"></a>IO复用</h3><p>IO复用使监听多个文件描述符成为了可能。</p>
<p>IO复用是串行的（不使用多进程等手段时），每次只能选择一个文件描述符再执行。</p>
<p>常见的包括select、poll和epoll。</p>
<h4 id="select系统调用"><a href="#select系统调用" class="headerlink" title="select系统调用"></a>select系统调用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/select.h&gt;</span><br><span class="line">int select(int nfds, fd_set *readfds, fd_set *writefds,</span><br><span class="line">           fd_set *exceptfds, struct timeval *timeout);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>nfds：代表被监听的文件描述符的总数，<strong>即为所有文件描述符的最大值加一</strong>，一定要注意，不然没法监听（0-maxnum总共有maxnum+1个数）。</p>
</li>
<li><p>readfds、writefds、exceptfds参数分别指向可读可写和异常事件对应的文件描述符集合。fd_set是一个结构体，其中包含了一个整型数组，数组的每一位代表一个fd。</p>
</li>
<li><p>timeout用来设置select函数的超时时间，timeval结构体有两个值代表秒和微秒</p>
<ul>
<li>如果设为0，则立刻返回</li>
<li>设为NULL，则一直阻塞，直到某个文件描述符就绪</li>
<li>成功返回就绪文件描述符的总数</li>
<li>给定时间内，没有文件描述符就绪，返回0</li>
<li>失败时，返回-1并设置errno</li>
<li>如果在等待期间，程序收到信号，select返回-1并设置errno为EINTR。</li>
</ul>
</li>
</ul>
<h5 id="文件描述符就绪条件"><a href="#文件描述符就绪条件" class="headerlink" title="文件描述符就绪条件"></a>文件描述符就绪条件</h5><p>在如下情况下，socket可读：（或者说，在如下情况下，直接调用的recv会返回）</p>
<ul>
<li>socket内核缓冲区的字节数大于等于低水位标志SO_RECVLOWAT（即1），调用read后返回大于0的数。</li>
<li>socket的对方关闭连接，调用read后返回0。</li>
<li>监听socket上有新的连接请求。（通知后，应用程序可以根据文件描述符判断是listenfd，然后用accept来处理新的连接请求，如果不是listenfd，则进行其他处理）</li>
<li>socket上有未处理的错误，使用getsocopt来读取和清除该错误。</li>
</ul>
<p>在如下情况下，socket可写：（或者说，在如下情况下，直接调用的send会返回）</p>
<ul>
<li>socket内核发送缓冲区可以字节数大于等于低水位标志SO_SNDLOWAT（即1）</li>
<li>socket的写操作被关闭，这是继续往socket写数据时会触发SIGPIPE信号。</li>
<li>socket使用非阻塞connect连接成功或者失败之后。</li>
<li>socket上有未处理的错误，使用getsocopt来读取和清除该错误。</li>
</ul>
<blockquote>
<p>服务端网线被拔了，重新接上后。只有客户端维护着连接，当他往管道写入数据时，会受到一个复位报文段。</p>
</blockquote>
<p>select能处理的异常情况只有一种：socket上接收到带外数据。</p>
<h5 id="处理带外数据"><a href="#处理带外数据" class="headerlink" title="处理带外数据"></a>处理带外数据</h5><p>SELECT返回后，判断sockfd的读、写、异常位是否被置位，然后执行针对性的操作。</p>
<h4 id="poll系统调用"><a href="#poll系统调用" class="headerlink" title="poll系统调用"></a>poll系统调用</h4><p>poll系统调用和select类似，也是在指定时间内轮询一定数量的文件描述符，已测试是否有就绪者。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;poll.h&gt;</span><br><span class="line">int poll(struct pollfd *fds, nfds_t nfds, int timeout);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>fds是一个pollfd结构类型的数组，它指定我们所有感兴趣的文件描述符上发生的可读可写异常事件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct pollfd&#123;</span><br><span class="line">	int fd;</span><br><span class="line">	short events;//注册的事件</span><br><span class="line">	short revents;//实际发生的事件，由内核来写</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>nfds指定第一个参数，数组的大小</p>
</li>
<li><p>timeout指定超时值。</p>
</li>
</ul>
<h4 id="epoll系列系统调用"><a href="#epoll系列系统调用" class="headerlink" title="epoll系列系统调用"></a>epoll系列系统调用</h4><h5 id="内核事件表"><a href="#内核事件表" class="headerlink" title="内核事件表"></a>内核事件表</h5><p>epoll与select和poll不同的是，将事件表放到了内核中，而不是通过函数参数传入传出。所有epoll需要一个额外的文件描述符标识放到内核中的事件表。</p>
<p>创建内核事件表，获取文件描述符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;sys/epoll.h&gt;</span><br><span class="line">int epoll_create(int size);//返回到数就是内核事件表对应的文件描述符</span><br></pre></td></tr></table></figure>

<p>操作内核事件表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>fd指的是要操控的文件描述符</p>
</li>
<li><p>op有三种</p>
<ul>
<li>EPOLL_CTL_ADD</li>
<li>EPOLL_CTL_MOD</li>
<li>EPOLL_CTL_DEL</li>
</ul>
</li>
<li><p>event指定事件，他是epoll_event结构类型如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct epoll_event&#123;</span><br><span class="line">	__uint32_t events;</span><br><span class="line">	epoll_data_t data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>其中events成员描述事件类型，事件类型的种类和poll很相似。但多了两个：EPOLLET、EPOLLONESHOT。</p>
</li>
<li><p>epoll_data_t是一个union，如下(这些数据是epoll_wait返回时用的，返回的是epoll_event类型，通过这个类型的data的fd需要能够获得文件描述符)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef union epoll_data&#123;</span><br><span class="line">	void *ptr;</span><br><span class="line">	int fd;</span><br><span class="line">	uint32_t u32;</span><br><span class="line">	uint64_t u64;</span><br><span class="line">&#125;epoll_data_t;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h5 id="epoll-wati函数"><a href="#epoll-wati函数" class="headerlink" title="epoll_wati函数"></a>epoll_wati函数</h5><p>他在一段超时时间内等待一组文件描述符上的事件，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/epoll.h&gt;</span><br><span class="line">int epoll_wait(int epfd, struct epoll_event *events,</span><br><span class="line">                      int maxevents, int timeout);</span><br></pre></td></tr></table></figure>

<p>成功时返回文件描述符的个数，失败时返回-1并设置errno。</p>
<ul>
<li>timeout</li>
<li>maxevents，必须大于0</li>
<li>events，检测到事件，就将事件放到第二个参数里面，个数由返回值指出。</li>
</ul>
<h5 id="LT和ET模式"><a href="#LT和ET模式" class="headerlink" title="LT和ET模式"></a>LT和ET模式</h5><p>epoll对文件描述符的操作有两种模式：LT和ET（LT是默认模式，ET更高效）。</p>
<p>具体代码可见数据以及3090上。</p>
<blockquote>
<p>ET模式不能搭配阻塞IO使用。</p>
<p>因为当第一次收到数据时，ET模式的会循环使用recv读取数据，当读完数据时，也会使用recv继续读取，这时因为IO是阻塞的，那么程序就会阻塞在IO操作上。</p>
<p>相对的，使用非阻塞IO时，recv返回后，会根据errno来判断是继续读，还是暂停读。</p>
</blockquote>
<h5 id="EPOLLONESHOT事件"><a href="#EPOLLONESHOT事件" class="headerlink" title="EPOLLONESHOT事件"></a>EPOLLONESHOT事件</h5><p>为了防止工作进程在处理数据时，又收到了新的数据，这会唤醒另一个工作线程来处理同一个socket上的数据，导致冲突。我们希望任何时刻，同一个socket只能被一个工作进程处理。</p>
<p>对于注册了EPOLLONESHOT事件的文件描述符来说，操作系统只能触发一次该文件描述符的的事件。只有通过epoll_ctl重置了该文件描述符上的EPOLLONESHOT后，该文件描述符才会触发新事件。（工作进程一旦处理完该socket，就应该立刻重置EPOLLONESHOT）</p>
<p>如果一个工作线程在处理某个socket，这时有新的数据来了，则新的数据也会被该工作线程处理。</p>
<h4 id="三组IO复用函数的比较"><a href="#三组IO复用函数的比较" class="headerlink" title="三组IO复用函数的比较"></a>三组IO复用函数的比较</h4><p>相同点：可以监听多个文件描述符，可以等待timeout指定的时间，返回值代表事件的数量。</p>
<p>不同点：</p>
<ul>
<li>select和poll每次返回整个用户注册的事件集合（包括注册的和没注册的），epoll则只返回就绪事件</li>
<li>poll和epoll用参数指定最大文件描述符数量，他们都能达到系统允许打开的最大文件描述符数据，（65535或更大， <code>cat /proc/sys/fs/file-max</code>)，select则有限制。</li>
<li>select和poll只能工作在低效的LT模式，而epoll可以工作在高效的ET模式，并支持EPOLLONESHOT事件。</li>
<li>从实现原理上说，select和poll使用轮询的方式，epoll使用回调的方式。epoll适用于连接数量多但活动连接少的情况下。</li>
</ul>
<img src="/.github.io/2024/12/04/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20241223210321934.png" class title="image-20241223210321934">

<h4 id="IO复用的高级应用一：非阻塞connect"><a href="#IO复用的高级应用一：非阻塞connect" class="headerlink" title="IO复用的高级应用一：非阻塞connect"></a>IO复用的高级应用一：非阻塞connect</h4><blockquote>
<p>EINPROGRESS（代表当前socket是非阻塞的，连接没法立刻建立，可以通过io复用通知，时间合适时再建立）<br>              The  socket is nonblocking and the connection cannot be completed immediately.  (UNIX<br>              domain sockets failed with EAGAIN instead.)  It is possible to select(2)  or  poll(2)<br>              for  completion  by  selecting  the  socket  for  writing.  After select(2) indicates<br>              writability, use getsockopt(2) to read the SO_ERROR option at level SOL_SOCKET to de‐<br>              termine whether connect() completed successfully (SO_ERROR is zero) or unsuccessfully<br>              (SO_ERROR is one of the usual error codes listed here, explaining the reason for  the<br>              failure).</p>
</blockquote>
<blockquote>
<p> errno 是一个全局变量，用于指示最近一次系统调用失败的原因.</p>
<p>so_error 是一个套接字选项，用于获取与套接字相关的异步错误。（前文说过哟，在4个情况下，包括出错，send、recv调用都会返回，然后通过getsockopt来获取信息）</p>
</blockquote>
<p>这避免了客户端调用connect时的阻塞等待，当需要连接多个服务端时效果好。</p>
<h4 id="IO复用的高级应用二：聊天室程序"><a href="#IO复用的高级应用二：聊天室程序" class="headerlink" title="IO复用的高级应用二：聊天室程序"></a>IO复用的高级应用二：聊天室程序</h4><p>客户端需要读取用户输入，将数据发给服务器；从服务器接收数据，将数据显示出来。</p>
<p>服务器需要监听端口，并转发客户端的数据。</p>
<h5 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h5><p>使用poll同时监听用户输入和网络连接，使用splice将输入定向到网络连接并发送。零拷贝。</p>
<h4 id="IO复用的高级应用三：同时处理TCP和UDP服务"><a href="#IO复用的高级应用三：同时处理TCP和UDP服务" class="headerlink" title="IO复用的高级应用三：同时处理TCP和UDP服务"></a>IO复用的高级应用三：同时处理TCP和UDP服务</h4><p>服务器也需要监听多个socket，比如TCP socket或者 UDP socket，为此，需要使用IO复用。</p>
<h4 id="nc命令，（非书籍内容）"><a href="#nc命令，（非书籍内容）" class="headerlink" title="nc命令，（非书籍内容）"></a>nc命令，（非书籍内容）</h4><ul>
<li><p>在某个端口监听: <code>nc -l -p 8888</code></p>
</li>
<li><p>连接某个端口：<code>nc -v 127.0.0.1 8888</code>(TCP) 或者<code>nc -vu 127.0.0.1 8888</code>(UDP),连接后可以正常进行通信，比如发送HTTP报文等。</p>
</li>
<li><p>传输文件：在一端使用比如<code>nc -l -p 8888 &gt; test.txt</code>在另一端使用<code>nc -nv 127.0.0.1 8888 &lt; example.txt</code>，也可以反过来用。</p>
</li>
<li><p>传输目录：和ssh类型，发送端先将文件夹通过tar压缩为一个压缩包，然后重定向为nc的输入，将数据发给对方：</p>
<p><code>tar -cvf - tools | nc -nv 127.0.0.1 888</code>(其中<code>-</code>表示将压缩的数据输出到标准输出1，这又被通过管道传给了第二个命令的输入0，前面的重定向也是类似的<code>&gt;</code>)。发送端也是类似的：<code>nc -l -p 10089 | tar -xvf -</code>。</p>
<p>通过ssh传送：<code>tar -cvf - tools |ssh -p 3090 xxx@218.194.61.218 &#39;pwd;tar -xvf -&#39;</code></p>
</li>
<li><p>远程控制（需要支持<code>-c, -e</code>命令，可能需要先卸载netcat然后安装增强版ncat）：指定<code>-c, -e</code>命令后，会再连接后开启一个新的bash来执行命令。<code>nc -lp 8888 -c bash</code></p>
</li>
</ul>
<blockquote>
<p>指定ps显示方式：<code>ps -eo pid,ppid,pgid,sid,comm,user</code></p>
</blockquote>
<h4 id="超级服务xinetd"><a href="#超级服务xinetd" class="headerlink" title="超级服务xinetd"></a>超级服务xinetd</h4><p>Linux因特网服务<code>inetd</code>是超级服务，管理多个子服务，即监听多个端口。</p>
<p>随着systemd等更现代的系统和服务管理工具的出现，xinetd和inetd的使用逐渐减少。</p>
<h5 id="xinetd配置文件"><a href="#xinetd配置文件" class="headerlink" title="xinetd配置文件"></a>xinetd配置文件</h5><h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>服务器比如处理（或者忽略一些常见的信号，以免终止）。</p>
<h4 id="Linux信号概述"><a href="#Linux信号概述" class="headerlink" title="Linux信号概述"></a>Linux信号概述</h4><h5 id="发送信号"><a href="#发送信号" class="headerlink" title="发送信号"></a>发送信号</h5><p>发送信号的函数是kill函数, </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">int kill(pid_t pid, int sig);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>pid</p>
<ul>
<li>pid &gt; 0, 代表把信号发给PID为pid的进程</li>
<li>pid &#x3D; 0，代表把信号发给本进程组内的其他进程</li>
<li>pid &#x3D; -1，代表把信号发给除init进程外的所有进程（前提是有权限）</li>
<li>pid &lt; -1, 代表发给组ID为-pid的进程组的所有成员。</li>
</ul>
</li>
<li><p>sig，信号值都大于0。取0时代表不发送任何信号。</p>
</li>
</ul>
<p>失败时返回-1，并设置errno，</p>
<ul>
<li>EINVAL, 代表无效的信号</li>
<li>EPERM, 代表该进程没有权限发送给任何一个目标进程</li>
<li>ESRCH, 代表目标进程不存在</li>
</ul>
<h5 id="信号处理方式"><a href="#信号处理方式" class="headerlink" title="信号处理方式"></a>信号处理方式</h5><p>目标进程在收到信号后，需要定义一个接收函数来处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;signal.h&gt;</span><br><span class="line">typedef void (*__sighandler_t)(int);</span><br></pre></td></tr></table></figure>

<p>信号处理函数只带有一个整形参数，指示信号类型，此函数应该是可重入的。</p>
<p>除了用户自定义信号函数外，还有其他处理方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define SIG_DFL ((__sighandler_t) 0)</span><br><span class="line">#define SIG_IGN ((__sighandler_t) 1)</span><br></pre></td></tr></table></figure>

<ul>
<li>SIG_IGN, 忽略目标信号函数</li>
<li>SIG_DFL, 表示使用信号的默认处理方式。默认的处理方式有如下几种：结束进程、忽略信号、暂停进程、继续进程、结束进程并生成核心转储文件等。</li>
</ul>
<h5 id="Linux信号"><a href="#Linux信号" class="headerlink" title="Linux信号"></a>Linux信号</h5><p>Linux的可用信号都定义在<code>bits/signum.h</code>中，包括标准信号和POSIX实时信号。几个比较常用的：</p>
<ul>
<li>SIGHUP: 检测到控制终端挂起或者控制进程死亡时，进程会收到 SIGHUP。现在操作系统，该信号通常意味着使用的 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E7%BB%88%E7%AB%AF">虚拟终端</a> 已经被关闭。许多 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B">守护进程</a> 在接收到该信号时，会重载他们的设置和重新打开日志文件（logfiles），而不是去退出程序。<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Nohup">nohup</a> 命令用于无视该信号。</li>
<li>SIGPIPE：往读端被关闭的管道或者socket连接中写数据时会收到这个信号。</li>
<li>SIGURG</li>
<li>SIGALRM</li>
<li>SIGCHLD</li>
</ul>
<h5 id="中断系统调用"><a href="#中断系统调用" class="headerlink" title="中断系统调用"></a>中断系统调用</h5><p>处于可中断阻塞态的进程可能被信号中断，并将errno设置为EINTR。被中断后，进程被唤醒并处理信号。可以为信号设置SA_RESTART来自动重启被信号中断的系统调用。</p>
<h4 id="信号函数"><a href="#信号函数" class="headerlink" title="信号函数"></a>信号函数</h4><h5 id="signal系统调用——为信号设置处理函数的一种方式"><a href="#signal系统调用——为信号设置处理函数的一种方式" class="headerlink" title="signal系统调用——为信号设置处理函数的一种方式"></a>signal系统调用——为信号设置处理函数的一种方式</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;signal.h&gt;</span><br><span class="line">_sighandler_t signal(int sig, _sighandler_t _handler);</span><br></pre></td></tr></table></figure>

<ul>
<li>sig，指明信号类型</li>
<li>_handler，指定信号sig的处理函数，前面定义的SIG_IGN和SIG_DFL也属于这个类型。</li>
</ul>
<p>返回值是返回上一次调用signal函数时传入的函数指针。</p>
<h5 id="sigaction系统调用——为信号设置处理函数的一种更健壮的方式"><a href="#sigaction系统调用——为信号设置处理函数的一种更健壮的方式" class="headerlink" title="sigaction系统调用——为信号设置处理函数的一种更健壮的方式"></a>sigaction系统调用——为信号设置处理函数的一种更健壮的方式</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;signal.h&gt;</span><br><span class="line">int sigaction(int sig, const struct sigaction* act, struct sigaction* oact);</span><br></pre></td></tr></table></figure>

<ul>
<li>sig参数指出要捕获的信号类型</li>
<li>act指定信号对应的新的处理方式</li>
<li>oact参数则返回信号对应的旧的处理方式</li>
</ul>
<p>act和oact参数都是sigaction结构体类型的指针。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct sigaction &#123;</span><br><span class="line">   void     (*sa_handler)(int);</span><br><span class="line">   void     (*sa_sigaction)(int, siginfo_t *, void *);</span><br><span class="line">   sigset_t   sa_mask;</span><br><span class="line">   int        sa_flags;</span><br><span class="line">   void     (*sa_restorer)(void);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>sa_hander成员用来指定信号处理函数。</li>
<li>sa_mask，在<strong>信号处理函数执行期间</strong>用来屏蔽一组信号。</li>
<li>sa_flags用来指定程序收到信号时的行为。</li>
</ul>
<h4 id="信号集"><a href="#信号集" class="headerlink" title="信号集"></a>信号集</h4><h5 id="信号集函数"><a href="#信号集函数" class="headerlink" title="信号集函数"></a>信号集函数</h5><p>Linux使用数据结构sigset_t来表示一组信号。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typedef struct&#123;</span><br><span class="line">	unsigned long int __val[_SIGSET_NWORDS];</span><br><span class="line">&#125;__sigset_t;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>set代表他是一个集合，_t代表它是一种数据类型</p>
</blockquote>
<h5 id="进程信号掩码"><a href="#进程信号掩码" class="headerlink" title="进程信号掩码"></a>进程信号掩码</h5><p>前面提到过，可以通过sa_mask成员来设置进程的信号掩码，也可以通过如下的方式设置。（区别在于sigaction 中的 sa_mask生效范围是信息处理函数，sigprocmask的作用范围是整个进程）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;signal.h&gt;</span><br><span class="line">int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);</span><br></pre></td></tr></table></figure>

<ul>
<li>set指定新的信号掩码，</li>
<li>oset输出原来的信号掩码，</li>
<li>how指定了设置进程信号掩码的方式。比如SIG_BLOCK代表将新的进程信号掩码设定为当前值以及_set指定值的并集。</li>
</ul>
<p>可以将set设为NULL, 然后仍然可以利用oset参数来获取进程当前的信号掩码。</p>
<h5 id="被挂起的信号"><a href="#被挂起的信号" class="headerlink" title="被挂起的信号"></a>被挂起的信号</h5><p>当给一个进程发送一个被屏蔽的信号时，操作系统将该信号设置为进程的一个被挂起的信号，如果取消对被挂起信号的屏蔽，则它能立刻被进程接收到。通过如下函数可以获得进程当前被挂起的信号集。set保存的是被挂起的信号集。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int sigpending(sigset_t* set);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>即使某个信号被发送多次，sigpending函数也只反映一次。</p>
</blockquote>
<h4 id="统一事件源"><a href="#统一事件源" class="headerlink" title="统一事件源"></a>统一事件源</h4><p>信号是一种异步事件，为了让信号处理函数快速执行，避免屏蔽掉信号。使用一种解决方法：把信号的主要处理逻辑放到程序的主循环中，而当信号处理函数被触发时，他只是通知主循环程序接收信号，并把信号值传给主循环。</p>
<p>通常使用管道来传递，主程序使用IO复用系统调用来监听管道上的可读文件。</p>
<h4 id="网络编程相关信号"><a href="#网络编程相关信号" class="headerlink" title="网络编程相关信号"></a>网络编程相关信号</h4><h5 id="SIGHUP"><a href="#SIGHUP" class="headerlink" title="SIGHUP"></a>SIGHUP</h5><ul>
<li>对于在控制终端中执行的进程，当进程与控制制失去连接时，就会收到这个信号。当终端被关闭时，就会触发SIGHUP信号。</li>
<li>对于守护进程，他们并没有和终端相关联，他们收到SIGHUP信号时，可以重新加载配置文件或打开日志文件，以适应新的配置。</li>
</ul>
<blockquote>
<p>strace -p 7438 &amp;&gt; a.txt</p>
<p>strace可以跟踪该进程的系统调用和信号；&amp;&gt;代表将标准输出和标准错误输出都输出到后面的文件中。（只用&gt;时代表只处理标准输出）</p>
</blockquote>
<h5 id="SIGPIPE"><a href="#SIGPIPE" class="headerlink" title="SIGPIPE"></a>SIGPIPE</h5><p>往<strong>读端关闭的管道或者socket连接</strong>中写数据会引发SIGPIPE信号并将errno设置为<strong>EPIPE</strong>。收到SIGPIPE后，进程的默认行为是终止该进程，可以配置信号处理函数来解决。</p>
<p>可以通过设置send函数的MSG_NOSIGNAL标志来禁止写操作触发SIGPIPE信号，在这种情况下，就可以通过errno值来判断socket的读端是否已经关闭。</p>
<p>也可以通过IO复用系统调用来判断，以POLL为例：pollhup代表连接被双方关闭，pollrdhup代表本端没法继续读数据了（要么是连接关闭，要么是对方关闭了写端，或者本端口关闭了读端，参考：<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/56177060/pollhup-vs-pollrdhup">linux - POLLHUP vs. POLLRDHUP? - Stack Overflow</a>）</p>
<blockquote>
<p>上面主要介绍了几种判断连接是否存在的方式：</p>
<ul>
<li>使用send，看会不会触发sigpipe异常</li>
<li>使用errno判断</li>
<li>使用IO复用系统调用判断</li>
</ul>
</blockquote>
<h5 id="SIGURG"><a href="#SIGURG" class="headerlink" title="SIGURG"></a>SIGURG</h5><p>如何判断是否有带外数据到达呢：</p>
<ul>
<li>使用IO复用技术，比如监听的事件中加上一个EPOLLPRI</li>
<li>使用SIGURG信号</li>
</ul>
<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>Linux提供了三种定时方法：</p>
<ul>
<li>socket选项 SO_RCVTIMEO 和 SO_SNDTIMEO</li>
<li>SIGALRM信号</li>
<li>IO复用系统调用的超时参数</li>
</ul>
<h4 id="SO-RCVTIMEO和SO-SNDTIMEO"><a href="#SO-RCVTIMEO和SO-SNDTIMEO" class="headerlink" title="SO_RCVTIMEO和SO_SNDTIMEO"></a>SO_RCVTIMEO和SO_SNDTIMEO</h4><p>这两个可以设置socket接收数据和发送数据的超时时间。这两个选项只对如下几种标准的系统调用有用。</p>
<img src="/.github.io/2024/12/04/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20250115150723041.png" class title="image-20250115150723041">

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret = setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &amp;timeout, len);</span><br></pre></td></tr></table></figure>

<h4 id="SIGALRM信号"><a href="#SIGALRM信号" class="headerlink" title="SIGALRM信号"></a>SIGALRM信号</h4><h5 id="基于升序链表的简单定时器"><a href="#基于升序链表的简单定时器" class="headerlink" title="基于升序链表的简单定时器"></a>基于升序链表的简单定时器</h5><p>通过升序链表构建一个简单的定时器，只需要定期的触发定时器类的tick函数即可。</p>
<h5 id="处理非活动连接"><a href="#处理非活动连接" class="headerlink" title="处理非活动连接"></a>处理非活动连接</h5><p>虽然可以在socket选项中KEEPALIVE来激活定期检查机制，但也可以考虑在应用层实现类似于KEEPALIVE的机制。</p>
<h4 id="高性能定时器（容器）"><a href="#高性能定时器（容器）" class="headerlink" title="高性能定时器（容器）"></a>高性能定时器（容器）</h4><h5 id="时间轮"><a href="#时间轮" class="headerlink" title="时间轮"></a>时间轮</h5><p>以固定的频率调用tick函数，并检测到期的定时器，执行定时器上的回调函数。</p>
<h5 id="时间堆"><a href="#时间堆" class="headerlink" title="时间堆"></a>时间堆</h5><p>将超时时间最小的定时器的超时值作为心跳间隔，到期后调用tick函数。执行回调函数后，再从剩下的定时器中找到超时时间最小的一个，将这段时间作为下一次心搏间隔。<strong>最小堆很适合这种定时方案</strong>。</p>
<h3 id="高性能IO框架库Libevent"><a href="#高性能IO框架库Libevent" class="headerlink" title="高性能IO框架库Libevent"></a>高性能IO框架库Libevent</h3><p>常见的库包括ACE、ASIO和Libenvet。</p>
<h4 id="IO框架库"><a href="#IO框架库" class="headerlink" title="IO框架库"></a>IO框架库</h4><p>封装了较为底层的系统调用，给应用程序提供了一组更便于使用的接口。</p>
<p>各种IO框架库的实现原理类似，要么是Reactor，要么是Proactor。</p>
<p>基于Reactor模式的框架库包含如下几个组件：句柄、事件多路分发器、事件处理器、具体的事件处理器、Reactor。</p>
<h5 id="句柄"><a href="#句柄" class="headerlink" title="句柄"></a>句柄</h5><p>句柄是一种抽象的标识符，用于表示对系统资源的引用。比如IO事件的句柄是文件描述符，信号事件的句柄是信号值。</p>
<h5 id="事件多路分发器"><a href="#事件多路分发器" class="headerlink" title="事件多路分发器"></a>事件多路分发器</h5><p>在事件循环中，程序需要循环的等待并处理事件。等待事件一般使用IO复用技术实现。IO框架库一般会将系统支持的各种IO复用技术封装成统一的接口，成为事件多路分发器。其内部会调用select、poll、epoll_wait等函数。</p>
<img src="/.github.io/2024/12/04/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20250212120302262.png" class title="image-20250212120302262">

<h5 id="事件处理器、具体的事件处理器"><a href="#事件处理器、具体的事件处理器" class="headerlink" title="事件处理器、具体的事件处理器"></a>事件处理器、具体的事件处理器</h5><p>负责执行事件对应的业务逻辑，它通常包含回调函数，这些回调函数在事件循环中被执行。</p>
<h5 id="Reactor"><a href="#Reactor" class="headerlink" title="Reactor"></a>Reactor</h5><p>Reactor是IO框架库的核心，包含几种主要方法：</p>
<ul>
<li>handle_events，执行事件循环，等待事件，然后处理就绪事件对应的事件处理器。</li>
<li>register_handler，</li>
<li>remove_handler</li>
</ul>
<h3 id="多进程编程"><a href="#多进程编程" class="headerlink" title="多进程编程"></a>多进程编程</h3><h4 id="fork系统调用"><a href="#fork系统调用" class="headerlink" title="fork系统调用"></a>fork系统调用</h4><h4 id="exec系列系统调用"><a href="#exec系列系统调用" class="headerlink" title="exec系列系统调用"></a>exec系列系统调用</h4><h4 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h4><p>使用waitpid等待指定的子进程结束，设置options参数为WNOHANG可以让waitpid调用变为非阻塞的。他在任何情况下都会立刻返回，但需要根据返回值判断调用是否成功（和einprogress类似）</p>
<ul>
<li>返回0， 子进程还没有结束</li>
<li>返回正数，子进程已经退出了</li>
<li>返回负数，调用失败</li>
</ul>
<p>但是如果出现返回0的情况，此时必须等待子进程结束了之后再次调用waitpid，如果使用一个while循环不断判断，那这就与阻塞没有任何区别了，所以可以利用SIGCHLD信号。进程结束时，给他的父进程发一个SIGCHLD信号，这样父进程收到信号进入信号处理函数，就肯定说明子进程结束了，此时再使用waitpid。</p>
<img src="/.github.io/2024/12/04/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20250212163739462.png" class title="image-20250212163739462">

<h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><p>管道可以实现进程内部与外部之间的通信。</p>
<p>一对管道只能实现一个方向的数据传输。要实现父子进程的双向数据传输，就必须使用两个管道。socket编程接口提供了一个创建全双工socket的系统调用：socketpair。</p>
<p>管道只能用于有关联的进程之间通信（因为管道的文件描述符不是整个系统唯一的，而是进程唯一的），比如父子进程。而下面的方式可以用于无关联的多个进程之间的通信，因为他们使用一个全局唯一的键值来标识一条信道。</p>
<h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><h5 id="信号量原语"><a href="#信号量原语" class="headerlink" title="信号量原语"></a>信号量原语</h5><p>要编写有通用目的的代码，确保关键代码的独占式访问是非常困难的，Dekker和Perterson算法尝试从语言本身，而不是依赖内核来解决并发问题，但这会导致CPU利用率低下。</p>
<p>Linux信号量的API定义在sys&#x2F;sem.h头文件中，主要包含三个系统调用：semget、semop和semctl。他们被设计为操作一组信号量，而不是单个信号量。（上面的这个信号量是System V信号量机制的一部分，而sem_open是POSIX标准的一部分，两种方式都可以获取信号量）</p>
<h5 id="semget系统调用"><a href="#semget系统调用" class="headerlink" title="semget系统调用"></a>semget系统调用</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int semget(key_t key, int num_sems, int sem_flags);</span><br></pre></td></tr></table></figure>

<p><strong>创建</strong>一个新的信号量集，或者<strong>获取</strong>一个已经存在的信号量集。key参数标识一个全局唯一的信号量集。</p>
<h5 id="semop系统调用"><a href="#semop系统调用" class="headerlink" title="semop系统调用"></a>semop系统调用</h5><h5 id="semctl系统调用"><a href="#semctl系统调用" class="headerlink" title="semctl系统调用"></a>semctl系统调用</h5><h5 id="特殊键值IPC-PRIVATE"><a href="#特殊键值IPC-PRIVATE" class="headerlink" title="特殊键值IPC_PRIVATE"></a>特殊键值IPC_PRIVATE</h5><p>向semget的参数key传递IPC_PRIVATE时，不管信号量存不存在，都会创建一个新的信号量，这个信号量只可以供该进程及其子进程（对子进程而言他能获得semid这个变量，这是能在子进程中使用的原因）使用，其他进程无法访问。</p>
<h4 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h4><p>最高效的IPC机制，不涉及任何数据传输。但必须使用其他手段来同步进程对共享内存的访问，以免出现竞态条件。</p>
<h5 id="shmget系统调用（System-V）"><a href="#shmget系统调用（System-V）" class="headerlink" title="shmget系统调用（System V）"></a>shmget系统调用（System V）</h5><p>创建一段新的共享内存标识符，或者获取一段已经存在的共享内存标识符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int shmget(key_t key, size_t size, int shmflg);</span><br></pre></td></tr></table></figure>

<p>和semget系统调用一致，key是一个键值，表示一段全局唯一的共享内存。size指定共享内存的大小，如果只是获取已经存在的共享内存，则可以为0.</p>
<h5 id="shmat和shmdt"><a href="#shmat和shmdt" class="headerlink" title="shmat和shmdt"></a>shmat和shmdt</h5><p>shmat将共享内存标识符关联到进程的地址空间中。shmdt取消关联。</p>
<h5 id="shmctl系统调用"><a href="#shmctl系统调用" class="headerlink" title="shmctl系统调用"></a>shmctl系统调用</h5><h5 id="shm-open（POSIX）"><a href="#shm-open（POSIX）" class="headerlink" title="shm_open（POSIX）"></a>shm_open（POSIX）</h5><p>使用shm_open打开后再使用mmap进行关联，再使用ummap，shm_unlink。</p>
<h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><h5 id="msgget"><a href="#msgget" class="headerlink" title="msgget"></a>msgget</h5><p>创建或者获取一个消息队列。</p>
<h5 id="msgsnd"><a href="#msgsnd" class="headerlink" title="msgsnd"></a>msgsnd</h5><h5 id="msgrcv"><a href="#msgrcv" class="headerlink" title="msgrcv"></a>msgrcv</h5><h5 id="msgctl"><a href="#msgctl" class="headerlink" title="msgctl"></a>msgctl</h5><h4 id="在进程间传递文件描述符"><a href="#在进程间传递文件描述符" class="headerlink" title="在进程间传递文件描述符"></a>在进程间传递文件描述符</h4><p>传递一个文件描述符给另一个进程，并不是单纯的复制该文件描述符的值。而是要创建一个文件描述符，并且该文件描述符指向内核中相同的文件表项。可以通过代码实现。</p>
<h3 id="多线程编程"><a href="#多线程编程" class="headerlink" title="多线程编程"></a>多线程编程</h3><h5 id="Linux线程库"><a href="#Linux线程库" class="headerlink" title="Linux线程库"></a>Linux线程库</h5><p>最常见的线程库是LinuxThreads和<strong>NPTL</strong>。（Native POSIX Thread Library）</p>
<p>旧版本Linux不支持内核线程时，可以使用clone系统调用+不复制地址空间来获得线程（但这个线程的pid与父进程不一致）。Linux2.6之后，提供了真正的内核线程，他</p>
<ul>
<li>让内核线程不再是一个进程，避免了很多用进程模拟线程产生的语义问题。</li>
</ul>
<h4 id="创建线程和结束线程"><a href="#创建线程和结束线程" class="headerlink" title="创建线程和结束线程"></a>创建线程和结束线程</h4><ul>
<li>pthread_create</li>
<li>pthread_exit，线程结束时最好调用如下函数，以确保安全，该函数不会返回。</li>
<li>pthread_join，一个进程中的所有线程都可以调用pthread_join来回收其他线程。没有回收则会一直阻塞。</li>
<li>pthread_cancel，希望终止或者取消一个线程。目标线程也可也配置能否被取消以及取消类型。</li>
</ul>
<h4 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h4><ul>
<li>detachstate，包括JOINABLE和DETACH这两个状态，位于DETACH态时，结束时会自行释放占用的系统资源。</li>
</ul>
<h4 id="POSIX信号量"><a href="#POSIX信号量" class="headerlink" title="POSIX信号量"></a>POSIX信号量</h4><p>线程之间也需要控制对共享资源的访问。主要有三种用于线程同步的机制：<strong>POSIX信号量、互斥量和条件变量</strong>。</p>
<p>常见的POSIX信号量函数如下：（之前的semget都是System V标准下的信号量）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int sem_init(sem_t* sem, int pshared, unsigned int value);</span><br><span class="line">int sem_destory(sem_t* sem);</span><br><span class="line">int sem_wait(sem_t* sem);</span><br><span class="line">int sem_trywait(sem_t* sem);</span><br><span class="line">int sem_post(sem_t* sem);</span><br></pre></td></tr></table></figure>



<h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><img src="/.github.io/2024/12/04/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20250214153647946.png" class title="image-20250214153647946">

<h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><ul>
<li>pshared，互斥锁能否被不同的进程共享。</li>
<li>type<ul>
<li>普通锁（默认）：够用但是有缺陷。比如对上锁的普通锁再次加锁会出现死锁。线程A对线程B加的锁进行解锁，以及解一个已经解开的锁会出现未定义行为。</li>
<li>检错锁，当遇到上面的三种错误行为，会报错。</li>
<li>嵌套锁，具备检错锁的特点，同时可以加锁多次，解锁多次。解锁次数与加锁次数相同后，其他线程才能获得这个锁。</li>
</ul>
</li>
</ul>
<h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><p>互斥锁用于同步对共享数据的访问，条件变量用于在线程之间同步共享数据的值。</p>
<img src="/.github.io/2024/12/04/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20250214160558035.png" class title="image-20250214160558035">

<p>使用wait等待条件达成，使用signal唤醒被阻塞的线程。条件变量可能被多线程所访问，所以需要使用<strong>互斥量来控制对条件变量</strong>。</p>
<blockquote>
<p>为什么pthread_cond_wait里面会先释放锁，在申请锁，因为刚进函数时，需要等待条件达成，这里必然会阻塞，为了防止其他线程无法访问条件变量，需要先进行解锁，当再次被唤醒时，就意味着条件已经达成（或者是被信号中断），需要再次加锁，返回。这里进行一次加锁和解锁可能是为了保持一致性，毕竟进函数前已经加锁，出函数也应该加锁。</p>
</blockquote>
<p>条件变量比信号量灵活一点，毕竟条件变量可以进行条件判断。而信号量只会判断是否为0.</p>
<h4 id="线程同步机制包装类"><a href="#线程同步机制包装类" class="headerlink" title="线程同步机制包装类"></a>线程同步机制包装类</h4><p>为了复用代码，将前面的三种线程同步机制封装成3个类。</p>
<h4 id="多线程环境"><a href="#多线程环境" class="headerlink" title="多线程环境"></a>多线程环境</h4><p><strong>线程安全</strong>（可重入函数）：一个函数能被多个线程同时调用并不发生竞态条件。</p>
<p>Linux库函数只有一小部分不可重入的，比如inet_ntoa、getservbyname和getservbyport函数。之所以不可重入，是因为其中使用了静态变量。Linux对很多不可重入的库函数都提供了可重入版本，这些可重入版本的函数名是在原函数名尾部加上_r。在多线程程序中调用库函数，<strong>一定要使用其可重入版本</strong>。</p>
<blockquote>
<p>可重入函数使用互斥锁，或者避免静态变量来保证可重入。</p>
</blockquote>
<h5 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h5><p>如果在进程A中创建一个线程B，在现场将一个互斥锁加锁，再fork一个进程C，这时进程C中没有线程，但是互斥锁处于加锁状态。</p>
<p>解决方式：fork前确认所有锁都是解锁状态，比如使用pthread_atfork()，如果锁是解开的，那么prepare会正常调用，否则会报错（如果不是嵌套锁的话）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void prepare_fork() &#123;</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);  // 确保互斥锁解锁</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="线程与信号"><a href="#线程与信号" class="headerlink" title="线程与信号"></a>线程与信号</h5><ul>
<li><p>sigprocmask：设置的信号屏蔽字（signal mask）会影响进程中的所有线程。</p>
</li>
<li><p>pthread_sigmask：设置的信号屏蔽字仅影响调用它的线程，而不会影响其他线程。</p>
</li>
</ul>
<p>进程级信号（比如kill）发给进程后，可以被其中任意线程处理，每个线程可以配置信号掩码来判断能否处理信号（比如可以用一个单独的线程处理信号，其他线程屏蔽信号）。</p>
<p>线程级信号（pthread_kill）可以直接发送给目标线程。</p>
<p>信号处理函数作用于进程，一种类型的信号处理函数同进程只有一个。</p>
<blockquote>
<p>可以使用信号处理函数，也可以使用sigwait，这两者都可以判断是否接受到信号。为了只让一个线程出现信号，一般方式是让所有线程都屏蔽某些信号，然后在某一个线程中使用sigwait来处理信号。</p>
</blockquote>
<h3 id="进程池以及线程池"><a href="#进程池以及线程池" class="headerlink" title="进程池以及线程池"></a>进程池以及线程池</h3><p>这两个池很类似，之后都介绍进程池。</p>
<p>进程池的子进程数量在3-10个，而线程池的子线程数量和CPU数量差不多。</p>
<p>进程池子中的子进程运行着相同的代码，并且比较干净，因为不是从父进程fork而来。</p>
<blockquote>
<p>getpid 实际返回的是调用线程所属组的ID（TGID）, 而不是线程的PID。</p>
<p>gettid可以获取线程真实的PID。详见<code>man getpid</code>。</p>
<pre><code>From a kernel perspective, the PID (which is shared by all of the threads in a multithreaded process) is sometimes also known as the thread group ID (TGID).  This contrasts with the kernel  thread  ID  (TID),  which  is unique  for  each  thread.   For further details, see gettid(2) and the discussion of the CLONE_THREAD flag in clone(2).
</code></pre>
</blockquote>
<p>主进程选择哪个子进程来为新任务服务：</p>
<ul>
<li>使用某种算法来选择，比如随机和轮流算法。</li>
<li>主进程和所有子进程通过一个共享的工作队列来同步，子进程睡眠在该工作队列上，有新任务来时，将任务添加到工作队列上，这样有一个子进程将获得接管权，其他子进程继续睡眠。</li>
</ul>
<p>选择子进程后，</p>
<ul>
<li><p>父进程还需要通知子进程需要处理的数据，最简单的方式是预先在父子进程建一条管道，使用该管道通信。</p>
</li>
<li><p>至于线程，则可以直接将数据定义为全局的，毕竟这本来就是被所有线程共享的。</p>
</li>
</ul>
<img src="/.github.io/2024/12/04/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20250215171155679.png" class title="image-20250215171155679">

<h4 id="处理多客户"><a href="#处理多客户" class="headerlink" title="处理多客户"></a>处理多客户</h4><img src="/.github.io/2024/12/04/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20250216153827156.png" class title="image-20250216153827156">

<img src="/.github.io/2024/12/04/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20250216153835483.png" class title="image-20250216153835483">

<h3 id="服务器调制、调试和测试"><a href="#服务器调制、调试和测试" class="headerlink" title="服务器调制、调试和测试"></a>服务器调制、调试和测试</h3><p>Linux对应用程序能打开的最大文件描述符数量有两个限制：用户级限制、系统级限制。</p>
<h4 id="调整内核参数"><a href="#调整内核参数" class="headerlink" title="调整内核参数"></a>调整内核参数</h4><p>几乎所有内核模块，都在<code>/proc/sys</code>下提供了配置文件，也可也通过<code>sysctl -a</code>来查看这些内核参数。</p>
<p>&#x2F;proc文件系统是一个<strong>虚拟文件系统</strong>，它反映了当前内核的状态，所以通过修改&#x2F;proc下的文件来调整参数只是临时的修改，重启后就会失效。要永久生效需要配置<code>/etc/sysctl.conf</code>,并执行<code>sysctl -p</code>使它生效。</p>
<ul>
<li><code>/proc/sys/fs/file-max</code>, 系统级（不是用户）文件描述符限制</li>
<li><code>/proc/sys/fs/epoll/max_user_watches</code>，单用户能往epoll事件表注册事件的总数。</li>
<li><code>/proc/sys/net/core/somaxconn</code>, 指定listen监听队列中，能够建立完整连接并进入ESTABLISHED状态的socket的最大数目。</li>
<li><code>/proc/sys/net/ipv4/tcp_max_syn_backlog</code>, 指定listen监听队列中，能够转移到ESTABLISHED或者SYS_RCVD状态的socket的最大数目。</li>
<li><code>/proc/sys/net/ipv4/tcp_rmem</code>，指定一个socket的TCP写缓冲区的最小值、默认值、最大值。</li>
<li><code>/proc/sys/net/ipv4/tcp_wmem</code>，指定一个socket的TCP读缓冲区的最小值、默认值、最大值。</li>
<li><code>/proc/sys/net/ipv4/tcp_syncookies</code>，是否打开TCP同步标签，防止某个监听socket不停的收到同一个地址的连接请求而导致listen队列移除。（SYN泛红）</li>
</ul>
<h4 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h4><p>调试多进程时，可以用gdb attach到子进程进行调试。</p>
<p>调试多线程时：</p>
<ul>
<li>可以使用info threads查看所有可以调试的线程。</li>
<li>thread ID指定线程</li>
<li>set scheduler-looking [off|<strong>on</strong>|step]来锁定当前线程，使当前线程可以运行，而其他线程停止运行。</li>
</ul>
<h4 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h4><h3 id="系统监测工具"><a href="#系统监测工具" class="headerlink" title="系统监测工具"></a>系统监测工具</h3><p>常用的工具：tcpdump、nc、strace、lsof、netstat、vmstat、ifstat、mystat。</p>
<h4 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h4><p>支持三种方式过滤包：</p>
<ul>
<li>类型，支持的类型包括host、net、port、portrange。分别代表主机名（IP），用CIDR方法代表的网络地址，端口号，端口范围。比如: <code>tcpdump net 198.168.1.1/24</code></li>
<li>方向，用<code>src</code>指定源方向，而<code>dst</code>指定目的方向。比如：<code>tcpdump dst 10089</code>.</li>
<li>协议，指定目标协议，比如：<code>tcpdump icmp</code>.</li>
</ul>
<p>tcpdump甚至支持逻辑操作符：</p>
<p><code>tcpdump icmp host 192.168.1.140 and 192.168.1.117</code>,代表抓取<strong>主机140和主机117之间的icmp报文</strong>。</p>
<p>表达式复杂时，可以使用括号将其分组，不过需要使用反斜杠将其转义或者使用单引号将其括住。</p>
<h4 id="lsof"><a href="#lsof" class="headerlink" title="lsof"></a>lsof</h4><p>列出当前系统打开的文件描述符的工具。</p>
<ul>
<li><code>lsof -i [46][protocol][@hostname|hostaddr][:service|port]</code>，显示socket文件描述符。如：<code>lsof -i 4TCP@127.0.0.1:8888</code>。</li>
<li><code>lsof -u</code>，显示指定用户启动的所有进程的所有文件描述符。</li>
<li><code>lsof -c</code>，显示指定的命令打开的所有文件描述符。</li>
<li><code>lsof -p</code>, 显示指定进程打开的所有文件描述符</li>
<li><code>lsof -t</code>,显示打开了文件描述符的进程的PID。</li>
</ul>
<p>lsof显示的内容相当丰富：</p>
<ul>
<li>fd,文件描述符的描述，cwd代表进程的工作目录，rtd代表用户的根目录，txt代表进程运行的程序代码，mem表示映射到内存中的文件。有些FD是以数字+访问权限表示的，包括r，w，u（可读可写）。</li>
<li>type，dir是目录，reg是普通文件，chr是字符设备，</li>
<li></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://tjzhang-src.github.io/.github.io">John Doe</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://tjzhang-src.github.io/.github.io/2024/12/04/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/">https://tjzhang-src.github.io/.github.io/2024/12/04/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://tjzhang-src.github.io/.github.io" target="_blank">Welcome</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/.github.io/tags/web/">web</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/.github.io/2025/02/22/xv6/" title="xv6"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">xv6</div></div></a></div><div class="next-post pull-right"><a href="/.github.io/2024/12/03/%E5%9B%BE%E8%A7%A3HTTP/" title="图解HTTP"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">图解HTTP</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/.github.io/2024/12/03/%E5%9B%BE%E8%A7%A3HTTP/" title="图解HTTP"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-03</div><div class="title">图解HTTP</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Waline</span><span class="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/.github.io/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">John Doe</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/.github.io/archives/"><div class="headline">文章</div><div class="length-num">44</div></a><a href="/.github.io/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/.github.io/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/tjzhang-src"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-x2F-IP%E5%8D%8F%E8%AE%AE%E7%B0%87"><span class="toc-number">1.</span> <span class="toc-text">TCP&#x2F;IP协议簇</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E4%BD%8D%E6%8A%A5%E6%96%87%E6%AE%B5"><span class="toc-number">1.1.</span> <span class="toc-text">复位报文段</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E7%AB%AF%E5%8F%A3"><span class="toc-number">1.1.1.</span> <span class="toc-text">访问不存在的端口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%BB%88%E6%AD%A2%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.1.2.</span> <span class="toc-text">异常终止连接</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%8D%8A%E6%89%93%E5%BC%80%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.1.3.</span> <span class="toc-text">处理半打开连接</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E4%BA%A4%E4%BA%92%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-number">1.2.</span> <span class="toc-text">TCP交互数据流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E6%88%90%E5%9D%97%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-number">1.3.</span> <span class="toc-text">TCP成块数据流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%A6%E5%A4%96%E6%95%B0%E6%8D%AE"><span class="toc-number">1.4.</span> <span class="toc-text">带外数据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-x2F-IP%E9%80%9A%E4%BF%A1%E6%A1%88%E4%BE%8B"><span class="toc-number">2.</span> <span class="toc-text">TCP&#x2F;IP通信案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80API"><span class="toc-number">3.</span> <span class="toc-text">Linux网络编程基础API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#socket%E5%9C%B0%E5%9D%80API"><span class="toc-number">3.1.</span> <span class="toc-text">socket地址API</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E6%9C%BA%E5%AD%97%E8%8A%82%E5%BA%8F%E5%92%8C%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F"><span class="toc-number">3.1.1.</span> <span class="toc-text">主机字节序和网络字节序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%9A%E7%94%A8socket%E5%9C%B0%E5%9D%80"><span class="toc-number">3.1.2.</span> <span class="toc-text">通用socket地址</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%93%E7%94%A8socket%E5%9C%B0%E5%9D%80"><span class="toc-number">3.1.3.</span> <span class="toc-text">专用socket地址</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#IP%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0"><span class="toc-number">3.1.4.</span> <span class="toc-text">IP地址转换函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAsocket"><span class="toc-number">3.2.</span> <span class="toc-text">创建socket</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E5%90%8Dsocket"><span class="toc-number">3.3.</span> <span class="toc-text">命名socket</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%91%E5%90%ACsocket"><span class="toc-number">3.4.</span> <span class="toc-text">监听socket</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%97%E8%BF%9E%E6%8E%A5"><span class="toc-number">3.5.</span> <span class="toc-text">接受连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E8%B5%B7%E8%BF%9E%E6%8E%A5"><span class="toc-number">3.6.</span> <span class="toc-text">发起连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%97%AD%E8%BF%9E%E6%8E%A5"><span class="toc-number">3.7.</span> <span class="toc-text">关闭连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99"><span class="toc-number">3.8.</span> <span class="toc-text">数据读写</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#TCP%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99"><span class="toc-number">3.8.1.</span> <span class="toc-text">TCP数据读写</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#UDP%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99"><span class="toc-number">3.8.2.</span> <span class="toc-text">UDP数据读写</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99%E5%87%BD%E6%95%B0"><span class="toc-number">3.8.3.</span> <span class="toc-text">通用数据读写函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%A6%E5%A4%96%E6%A0%87%E8%AE%B0"><span class="toc-number">3.9.</span> <span class="toc-text">带外标记</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E4%BF%A1%E6%81%AF%E5%87%BD%E6%95%B0"><span class="toc-number">3.10.</span> <span class="toc-text">地址信息函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#socket%E9%80%89%E9%A1%B9"><span class="toc-number">3.11.</span> <span class="toc-text">socket选项</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#SO-REUSEADDR%E9%80%89%E9%A1%B9"><span class="toc-number">3.11.1.</span> <span class="toc-text">SO_REUSEADDR选项</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SO-RCVBUF%E5%92%8CSO-SNDBUF"><span class="toc-number">3.11.2.</span> <span class="toc-text">SO_RCVBUF和SO_SNDBUF</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SO-REVLOWAT%E5%92%8CSO-SNDLOWAT%E9%80%89%E9%A1%B9"><span class="toc-number">3.11.3.</span> <span class="toc-text">SO_REVLOWAT和SO_SNDLOWAT选项</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SO-LINGER%E9%80%89%E9%A1%B9"><span class="toc-number">3.11.4.</span> <span class="toc-text">SO_LINGER选项</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AFAPI"><span class="toc-number">3.12.</span> <span class="toc-text">网络信息API</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#gethostbyname%E5%92%8Cgethostbyaddr"><span class="toc-number">3.12.1.</span> <span class="toc-text">gethostbyname和gethostbyaddr</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#getservbyname%E5%92%8Cgetservbyport"><span class="toc-number">3.12.2.</span> <span class="toc-text">getservbyname和getservbyport</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#getaddrinfo"><span class="toc-number">3.12.3.</span> <span class="toc-text">getaddrinfo</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#getnameinfo"><span class="toc-number">3.12.4.</span> <span class="toc-text">getnameinfo</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7IO%E5%87%BD%E6%95%B0"><span class="toc-number">4.</span> <span class="toc-text">高级IO函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PIPE%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.</span> <span class="toc-text">PIPE函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dup%E5%87%BD%E6%95%B0%E5%92%8Cdup2%E5%87%BD%E6%95%B0"><span class="toc-number">4.2.</span> <span class="toc-text">dup函数和dup2函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#readv%E5%87%BD%E6%95%B0%E5%92%8Cwritev%E5%87%BD%E6%95%B0"><span class="toc-number">4.3.</span> <span class="toc-text">readv函数和writev函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sendfile%E5%87%BD%E6%95%B0"><span class="toc-number">4.4.</span> <span class="toc-text">sendfile函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mmap%E5%92%8Cmunmap%E5%87%BD%E6%95%B0"><span class="toc-number">4.5.</span> <span class="toc-text">mmap和munmap函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#splice%E5%87%BD%E6%95%B0"><span class="toc-number">4.6.</span> <span class="toc-text">splice函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tee%E5%87%BD%E6%95%B0"><span class="toc-number">4.7.</span> <span class="toc-text">tee函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fcntl%E5%87%BD%E6%95%B0"><span class="toc-number">4.8.</span> <span class="toc-text">fcntl函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E8%A7%84%E8%8C%83"><span class="toc-number">5.</span> <span class="toc-text">Linux服务器程序规范</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A5%E5%BF%97"><span class="toc-number">5.1.</span> <span class="toc-text">日志</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Linux%E7%B3%BB%E7%BB%9F%E6%97%A5%E5%BF%97"><span class="toc-number">5.1.1.</span> <span class="toc-text">Linux系统日志</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#syslog%E5%87%BD%E6%95%B0"><span class="toc-number">5.1.2.</span> <span class="toc-text">syslog函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF"><span class="toc-number">5.2.</span> <span class="toc-text">用户信息</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#UID%E3%80%81EUID%E3%80%81GID%E5%92%8CEGID"><span class="toc-number">5.2.1.</span> <span class="toc-text">UID、EUID、GID和EGID</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%87%E6%8D%A2%E7%94%A8%E6%88%B7"><span class="toc-number">5.2.2.</span> <span class="toc-text">切换用户</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E5%85%B3%E7%B3%BB"><span class="toc-number">5.3.</span> <span class="toc-text">进程间关系</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%84"><span class="toc-number">5.3.1.</span> <span class="toc-text">进程组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%9A%E8%AF%9D"><span class="toc-number">5.3.2.</span> <span class="toc-text">会话</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%A8ps%E5%91%BD%E4%BB%A4%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB"><span class="toc-number">5.3.3.</span> <span class="toc-text">用ps命令查看进程关系</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6"><span class="toc-number">5.4.</span> <span class="toc-text">系统资源限制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B9%E5%8F%98%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95%E5%92%8C%E6%A0%B9%E7%9B%AE%E5%BD%95"><span class="toc-number">5.5.</span> <span class="toc-text">改变工作目录和根目录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E5%90%8E%E5%8F%B0%E5%8C%96"><span class="toc-number">5.6.</span> <span class="toc-text">服务器程序后台化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6"><span class="toc-number">6.</span> <span class="toc-text">高性能服务器程序框架</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A8%A1%E5%9E%8B"><span class="toc-number">6.1.</span> <span class="toc-text">服务器模型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#C-x2F-S%E6%A8%A1%E5%9E%8B"><span class="toc-number">6.1.1.</span> <span class="toc-text">C&#x2F;S模型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#P2P"><span class="toc-number">6.1.2.</span> <span class="toc-text">P2P</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6"><span class="toc-number">6.2.</span> <span class="toc-text">服务器编程框架</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IO%E6%A8%A1%E5%9E%8B"><span class="toc-number">6.3.</span> <span class="toc-text">IO模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E9%AB%98%E6%95%88%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.4.</span> <span class="toc-text">两种高效的事件处理模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Reactor%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.4.1.</span> <span class="toc-text">Reactor模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Proactor%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.4.2.</span> <span class="toc-text">Proactor模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9FProactor%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.4.3.</span> <span class="toc-text">模拟Proactor模式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E9%AB%98%E6%95%88%E7%9A%84%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.5.</span> <span class="toc-text">两种高效的并发模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%8A%E5%90%8C%E6%AD%A5-x2F-%E5%8D%8A%E5%BC%82%E6%AD%A5%E6%96%B9%E5%BC%8F"><span class="toc-number">6.5.1.</span> <span class="toc-text">半同步&#x2F;半异步方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A2%86%E5%AF%BC%E8%80%85-x2F-%E8%BF%BD%E9%9A%8F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.5.2.</span> <span class="toc-text">领导者&#x2F;追随者模式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA%E2%80%94%E2%80%94%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83%E5%86%85%E9%83%A8%E7%9A%84%E9%AB%98%E6%95%88%E7%BC%96%E7%A8%8B%E6%96%B9%E6%B3%95"><span class="toc-number">6.6.</span> <span class="toc-text">有限状态机——逻辑单元内部的高效编程方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%90%E9%AB%98%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD%E7%9A%84%E5%BB%BA%E8%AE%AE"><span class="toc-number">6.7.</span> <span class="toc-text">提高服务器性能的建议</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B1%A0"><span class="toc-number">6.7.1.</span> <span class="toc-text">池</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6"><span class="toc-number">6.7.2.</span> <span class="toc-text">数据复制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-number">6.7.3.</span> <span class="toc-text">上下文切换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%94%81"><span class="toc-number">6.7.4.</span> <span class="toc-text">锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO%E5%A4%8D%E7%94%A8"><span class="toc-number">7.</span> <span class="toc-text">IO复用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#select%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">7.1.</span> <span class="toc-text">select系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%B0%B1%E7%BB%AA%E6%9D%A1%E4%BB%B6"><span class="toc-number">7.1.1.</span> <span class="toc-text">文件描述符就绪条件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%B8%A6%E5%A4%96%E6%95%B0%E6%8D%AE"><span class="toc-number">7.1.2.</span> <span class="toc-text">处理带外数据</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#poll%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">7.2.</span> <span class="toc-text">poll系统调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#epoll%E7%B3%BB%E5%88%97%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">7.3.</span> <span class="toc-text">epoll系列系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E4%BA%8B%E4%BB%B6%E8%A1%A8"><span class="toc-number">7.3.1.</span> <span class="toc-text">内核事件表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#epoll-wati%E5%87%BD%E6%95%B0"><span class="toc-number">7.3.2.</span> <span class="toc-text">epoll_wati函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LT%E5%92%8CET%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.3.3.</span> <span class="toc-text">LT和ET模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#EPOLLONESHOT%E4%BA%8B%E4%BB%B6"><span class="toc-number">7.3.4.</span> <span class="toc-text">EPOLLONESHOT事件</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E7%BB%84IO%E5%A4%8D%E7%94%A8%E5%87%BD%E6%95%B0%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">7.4.</span> <span class="toc-text">三组IO复用函数的比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IO%E5%A4%8D%E7%94%A8%E7%9A%84%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8%E4%B8%80%EF%BC%9A%E9%9D%9E%E9%98%BB%E5%A1%9Econnect"><span class="toc-number">7.5.</span> <span class="toc-text">IO复用的高级应用一：非阻塞connect</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IO%E5%A4%8D%E7%94%A8%E7%9A%84%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8%E4%BA%8C%EF%BC%9A%E8%81%8A%E5%A4%A9%E5%AE%A4%E7%A8%8B%E5%BA%8F"><span class="toc-number">7.6.</span> <span class="toc-text">IO复用的高级应用二：聊天室程序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">7.6.1.</span> <span class="toc-text">客户端</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IO%E5%A4%8D%E7%94%A8%E7%9A%84%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8%E4%B8%89%EF%BC%9A%E5%90%8C%E6%97%B6%E5%A4%84%E7%90%86TCP%E5%92%8CUDP%E6%9C%8D%E5%8A%A1"><span class="toc-number">7.7.</span> <span class="toc-text">IO复用的高级应用三：同时处理TCP和UDP服务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nc%E5%91%BD%E4%BB%A4%EF%BC%8C%EF%BC%88%E9%9D%9E%E4%B9%A6%E7%B1%8D%E5%86%85%E5%AE%B9%EF%BC%89"><span class="toc-number">7.8.</span> <span class="toc-text">nc命令，（非书籍内容）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B6%85%E7%BA%A7%E6%9C%8D%E5%8A%A1xinetd"><span class="toc-number">7.9.</span> <span class="toc-text">超级服务xinetd</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#xinetd%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">7.9.1.</span> <span class="toc-text">xinetd配置文件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7"><span class="toc-number">8.</span> <span class="toc-text">信号</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Linux%E4%BF%A1%E5%8F%B7%E6%A6%82%E8%BF%B0"><span class="toc-number">8.1.</span> <span class="toc-text">Linux信号概述</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E4%BF%A1%E5%8F%B7"><span class="toc-number">8.1.1.</span> <span class="toc-text">发送信号</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">8.1.2.</span> <span class="toc-text">信号处理方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Linux%E4%BF%A1%E5%8F%B7"><span class="toc-number">8.1.3.</span> <span class="toc-text">Linux信号</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">8.1.4.</span> <span class="toc-text">中断系统调用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E5%87%BD%E6%95%B0"><span class="toc-number">8.2.</span> <span class="toc-text">信号函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#signal%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E2%80%94%E2%80%94%E4%B8%BA%E4%BF%A1%E5%8F%B7%E8%AE%BE%E7%BD%AE%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%80%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">8.2.1.</span> <span class="toc-text">signal系统调用——为信号设置处理函数的一种方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sigaction%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E2%80%94%E2%80%94%E4%B8%BA%E4%BF%A1%E5%8F%B7%E8%AE%BE%E7%BD%AE%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%80%E7%A7%8D%E6%9B%B4%E5%81%A5%E5%A3%AE%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">8.2.2.</span> <span class="toc-text">sigaction系统调用——为信号设置处理函数的一种更健壮的方式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%9B%86"><span class="toc-number">8.3.</span> <span class="toc-text">信号集</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%9B%86%E5%87%BD%E6%95%B0"><span class="toc-number">8.3.1.</span> <span class="toc-text">信号集函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%BF%A1%E5%8F%B7%E6%8E%A9%E7%A0%81"><span class="toc-number">8.3.2.</span> <span class="toc-text">进程信号掩码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A2%AB%E6%8C%82%E8%B5%B7%E7%9A%84%E4%BF%A1%E5%8F%B7"><span class="toc-number">8.3.3.</span> <span class="toc-text">被挂起的信号</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%9F%E4%B8%80%E4%BA%8B%E4%BB%B6%E6%BA%90"><span class="toc-number">8.4.</span> <span class="toc-text">统一事件源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BF%A1%E5%8F%B7"><span class="toc-number">8.5.</span> <span class="toc-text">网络编程相关信号</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#SIGHUP"><span class="toc-number">8.5.1.</span> <span class="toc-text">SIGHUP</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SIGPIPE"><span class="toc-number">8.5.2.</span> <span class="toc-text">SIGPIPE</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SIGURG"><span class="toc-number">8.5.3.</span> <span class="toc-text">SIGURG</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">9.</span> <span class="toc-text">定时器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SO-RCVTIMEO%E5%92%8CSO-SNDTIMEO"><span class="toc-number">9.1.</span> <span class="toc-text">SO_RCVTIMEO和SO_SNDTIMEO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SIGALRM%E4%BF%A1%E5%8F%B7"><span class="toc-number">9.2.</span> <span class="toc-text">SIGALRM信号</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">9.2.1.</span> <span class="toc-text">基于升序链表的简单定时器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E9%9D%9E%E6%B4%BB%E5%8A%A8%E8%BF%9E%E6%8E%A5"><span class="toc-number">9.2.2.</span> <span class="toc-text">处理非活动连接</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E6%80%A7%E8%83%BD%E5%AE%9A%E6%97%B6%E5%99%A8%EF%BC%88%E5%AE%B9%E5%99%A8%EF%BC%89"><span class="toc-number">9.3.</span> <span class="toc-text">高性能定时器（容器）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E8%BD%AE"><span class="toc-number">9.3.1.</span> <span class="toc-text">时间轮</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A0%86"><span class="toc-number">9.3.2.</span> <span class="toc-text">时间堆</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E6%80%A7%E8%83%BDIO%E6%A1%86%E6%9E%B6%E5%BA%93Libevent"><span class="toc-number">10.</span> <span class="toc-text">高性能IO框架库Libevent</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IO%E6%A1%86%E6%9E%B6%E5%BA%93"><span class="toc-number">10.1.</span> <span class="toc-text">IO框架库</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%A5%E6%9F%84"><span class="toc-number">10.1.1.</span> <span class="toc-text">句柄</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%A4%9A%E8%B7%AF%E5%88%86%E5%8F%91%E5%99%A8"><span class="toc-number">10.1.2.</span> <span class="toc-text">事件多路分发器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%99%A8%E3%80%81%E5%85%B7%E4%BD%93%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">10.1.3.</span> <span class="toc-text">事件处理器、具体的事件处理器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Reactor"><span class="toc-number">10.1.4.</span> <span class="toc-text">Reactor</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B"><span class="toc-number">11.</span> <span class="toc-text">多进程编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#fork%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">11.1.</span> <span class="toc-text">fork系统调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exec%E7%B3%BB%E5%88%97%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">11.2.</span> <span class="toc-text">exec系列系统调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="toc-number">11.3.</span> <span class="toc-text">僵尸进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E9%81%93"><span class="toc-number">11.4.</span> <span class="toc-text">管道</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">11.5.</span> <span class="toc-text">信号量</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%8E%9F%E8%AF%AD"><span class="toc-number">11.5.1.</span> <span class="toc-text">信号量原语</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#semget%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">11.5.2.</span> <span class="toc-text">semget系统调用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#semop%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">11.5.3.</span> <span class="toc-text">semop系统调用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#semctl%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">11.5.4.</span> <span class="toc-text">semctl系统调用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E9%94%AE%E5%80%BCIPC-PRIVATE"><span class="toc-number">11.5.5.</span> <span class="toc-text">特殊键值IPC_PRIVATE</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="toc-number">11.6.</span> <span class="toc-text">共享内存</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#shmget%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%EF%BC%88System-V%EF%BC%89"><span class="toc-number">11.6.1.</span> <span class="toc-text">shmget系统调用（System V）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#shmat%E5%92%8Cshmdt"><span class="toc-number">11.6.2.</span> <span class="toc-text">shmat和shmdt</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#shmctl%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">11.6.3.</span> <span class="toc-text">shmctl系统调用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#shm-open%EF%BC%88POSIX%EF%BC%89"><span class="toc-number">11.6.4.</span> <span class="toc-text">shm_open（POSIX）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">11.7.</span> <span class="toc-text">消息队列</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#msgget"><span class="toc-number">11.7.1.</span> <span class="toc-text">msgget</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#msgsnd"><span class="toc-number">11.7.2.</span> <span class="toc-text">msgsnd</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#msgrcv"><span class="toc-number">11.7.3.</span> <span class="toc-text">msgrcv</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#msgctl"><span class="toc-number">11.7.4.</span> <span class="toc-text">msgctl</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E8%BF%9B%E7%A8%8B%E9%97%B4%E4%BC%A0%E9%80%92%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">11.8.</span> <span class="toc-text">在进程间传递文件描述符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B"><span class="toc-number">12.</span> <span class="toc-text">多线程编程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Linux%E7%BA%BF%E7%A8%8B%E5%BA%93"><span class="toc-number">12.0.1.</span> <span class="toc-text">Linux线程库</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BB%93%E6%9D%9F%E7%BA%BF%E7%A8%8B"><span class="toc-number">12.1.</span> <span class="toc-text">创建线程和结束线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%B1%9E%E6%80%A7"><span class="toc-number">12.2.</span> <span class="toc-text">线程属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#POSIX%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">12.3.</span> <span class="toc-text">POSIX信号量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-number">12.4.</span> <span class="toc-text">互斥锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7"><span class="toc-number">12.4.1.</span> <span class="toc-text">属性</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-number">12.5.</span> <span class="toc-text">条件变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-number">12.6.</span> <span class="toc-text">线程同步机制包装类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%8E%AF%E5%A2%83"><span class="toc-number">12.7.</span> <span class="toc-text">多线程环境</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B"><span class="toc-number">12.7.1.</span> <span class="toc-text">线程与进程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8E%E4%BF%A1%E5%8F%B7"><span class="toc-number">12.7.2.</span> <span class="toc-text">线程与信号</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%B1%A0%E4%BB%A5%E5%8F%8A%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">13.</span> <span class="toc-text">进程池以及线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%A4%9A%E5%AE%A2%E6%88%B7"><span class="toc-number">13.1.</span> <span class="toc-text">处理多客户</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%B0%83%E5%88%B6%E3%80%81%E8%B0%83%E8%AF%95%E5%92%8C%E6%B5%8B%E8%AF%95"><span class="toc-number">14.</span> <span class="toc-text">服务器调制、调试和测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E6%95%B4%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0"><span class="toc-number">14.1.</span> <span class="toc-text">调整内核参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gdb%E8%B0%83%E8%AF%95"><span class="toc-number">14.2.</span> <span class="toc-text">gdb调试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95"><span class="toc-number">14.3.</span> <span class="toc-text">压力测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%B5%8B%E5%B7%A5%E5%85%B7"><span class="toc-number">15.</span> <span class="toc-text">系统监测工具</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#tcpdump"><span class="toc-number">15.1.</span> <span class="toc-text">tcpdump</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lsof"><span class="toc-number">15.2.</span> <span class="toc-text">lsof</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/.github.io/2025/02/22/xv6/" title="xv6">xv6</a><time datetime="2025-02-22T13:38:24.000Z" title="发表于 2025-02-22 21:38:24">2025-02-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/.github.io/2024/12/04/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/" title="Linux高性能服务器编程">Linux高性能服务器编程</a><time datetime="2024-12-04T09:01:31.000Z" title="发表于 2024-12-04 17:01:31">2024-12-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/.github.io/2024/12/03/%E5%9B%BE%E8%A7%A3HTTP/" title="图解HTTP">图解HTTP</a><time datetime="2024-12-03T03:35:49.000Z" title="发表于 2024-12-03 11:35:49">2024-12-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/.github.io/2024/11/28/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/" title="自顶向下方法">自顶向下方法</a><time datetime="2024-11-28T12:05:16.000Z" title="发表于 2024-11-28 20:05:16">2024-11-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/.github.io/2024/11/12/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/" title="程序员的自我修养-第十一章">程序员的自我修养-第十一章</a><time datetime="2024-11-12T08:29:32.000Z" title="发表于 2024-11-12 16:29:32">2024-11-12</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://s2.loli.net/2023/02/26/9fQnztK2ImqyLwS.webp')"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2025 By John Doe</div><div class="footer_custom_text">Hi, welcome to my <a href="https://tjzhang-src.github.io/.github.io/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/.github.io/js/utils.js"></script><script src="/.github.io/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>function loadWaline () {
  function initWaline () {
    const waline = Waline.init(Object.assign({
      el: '#waline-wrap',
      serverURL: 'https://blog-comment-bfstu88s1-ttj2023.vercel.app/',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      path: window.location.pathname,
      comment: false,
    }, null))
  }

  const walineCSSLoad = document.getElementById('waline-css')

  if (typeof Waline === 'object') {
    walineCSSLoad ? initWaline() : getCSS('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.css','waline-css').then(initWaline)
  }
  else {
    getCSS('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.css','waline-css').then(() => {
      getScript('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.js').then(initWaline)
    })
  }
}

if ('Waline' === 'Waline' || !true) {
  if (true) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
  else setTimeout(loadWaline, 0)
} else {
  function loadOtherComment () {
    loadWaline()
  }
}</script><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'https://tjzhang-src.github.io/.github.io/2024/12/04/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/'
    this.page.identifier = '/.github.io/2024/12/04/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/'
    this.page.title = 'Linux高性能服务器编程'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }

  document.getElementById('darkmode').addEventListener('click', () => {
    setTimeout(() => window.disqusReset(), 200)
  })
}

if ('Waline' === 'Disqus' || !true) {
  if (true) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>